
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.head.appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() {}

    const identity = x => x;

    function assign(tar, src) {
      // @ts-ignore
      for (const k in src) tar[k] = src[k];

      return tar;
    }

    function is_promise(value) {
      return value && typeof value === 'object' && typeof value.then === 'function';
    }

    function add_location(element, file, line, column, char) {
      element.__svelte_meta = {
        loc: {
          file,
          line,
          column,
          char
        }
      };
    }

    function run(fn) {
      return fn();
    }

    function blank_object() {
      return Object.create(null);
    }

    function run_all(fns) {
      fns.forEach(run);
    }

    function is_function(thing) {
      return typeof thing === 'function';
    }

    function safe_not_equal(a, b) {
      return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';
    }

    function validate_store(store, name) {
      if (!store || typeof store.subscribe !== 'function') {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
      }
    }

    function subscribe(store, callback) {
      const unsub = store.subscribe(callback);
      return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }

    function component_subscribe(component, store, callback) {
      component.$$.on_destroy.push(subscribe(store, callback));
    }

    function create_slot(definition, ctx, $$scope, fn) {
      if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
      }
    }

    function get_slot_context(definition, ctx, $$scope, fn) {
      return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
    }

    function get_slot_changes(definition, $$scope, dirty, fn) {
      if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));

        if (typeof $$scope.dirty === 'object') {
          const merged = [];
          const len = Math.max($$scope.dirty.length, lets.length);

          for (let i = 0; i < len; i += 1) {
            merged[i] = $$scope.dirty[i] | lets[i];
          }

          return merged;
        }

        return $$scope.dirty | lets;
      }

      return $$scope.dirty;
    }

    function set_store_value(store, ret, value = ret) {
      store.set(value);
      return ret;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client ? () => window.performance.now() : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop; // used internally for testing

    const tasks = new Set();

    function run_tasks(now) {
      tasks.forEach(task => {
        if (!task.c(now)) {
          tasks.delete(task);
          task.f();
        }
      });
      if (tasks.size !== 0) raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */


    function loop(callback) {
      let task;
      if (tasks.size === 0) raf(run_tasks);
      return {
        promise: new Promise(fulfill => {
          tasks.add(task = {
            c: callback,
            f: fulfill
          });
        }),

        abort() {
          tasks.delete(task);
        }

      };
    }

    function append(target, node) {
      target.appendChild(node);
    }

    function insert(target, node, anchor) {
      target.insertBefore(node, anchor || null);
    }

    function detach(node) {
      node.parentNode.removeChild(node);
    }

    function destroy_each(iterations, detaching) {
      for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i]) iterations[i].d(detaching);
      }
    }

    function element(name) {
      return document.createElement(name);
    }

    function svg_element(name) {
      return document.createElementNS('http://www.w3.org/2000/svg', name);
    }

    function text(data) {
      return document.createTextNode(data);
    }

    function space() {
      return text(' ');
    }

    function empty() {
      return text('');
    }

    function listen(node, event, handler, options) {
      node.addEventListener(event, handler, options);
      return () => node.removeEventListener(event, handler, options);
    }

    function prevent_default(fn) {
      return function (event) {
        event.preventDefault(); // @ts-ignore

        return fn.call(this, event);
      };
    }

    function stop_propagation(fn) {
      return function (event) {
        event.stopPropagation(); // @ts-ignore

        return fn.call(this, event);
      };
    }

    function attr(node, attribute, value) {
      if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
    }

    function children(element) {
      return Array.from(element.childNodes);
    }

    function set_input_value(input, value) {
      if (value != null || input.value) {
        input.value = value;
      }
    }

    function set_style(node, key, value, important) {
      node.style.setProperty(key, value, important ? 'important' : '');
    }

    function toggle_class(element, name, toggle) {
      element.classList[toggle ? 'add' : 'remove'](name);
    }

    function custom_event(type, detail) {
      const e = document.createEvent('CustomEvent');
      e.initCustomEvent(type, false, false, detail);
      return e;
    }

    let stylesheet;
    let active = 0;
    let current_rules = {}; // https://github.com/darkskyapp/string-hash/blob/master/index.js

    function hash(str) {
      let hash = 5381;
      let i = str.length;

      while (i--) hash = (hash << 5) - hash ^ str.charCodeAt(i);

      return hash >>> 0;
    }

    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
      const step = 16.666 / duration;
      let keyframes = '{\n';

      for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
      }

      const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
      const name = `__svelte_${hash(rule)}_${uid}`;

      if (!current_rules[name]) {
        if (!stylesheet) {
          const style = element('style');
          document.head.appendChild(style);
          stylesheet = style.sheet;
        }

        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
      }

      const animation = node.style.animation || '';
      node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
      active += 1;
      return name;
    }

    function delete_rule(node, name) {
      node.style.animation = (node.style.animation || '').split(', ').filter(name ? anim => anim.indexOf(name) < 0 // remove specific animation
      : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
      ).join(', ');
      if (name && ! --active) clear_rules();
    }

    function clear_rules() {
      raf(() => {
        if (active) return;
        let i = stylesheet.cssRules.length;

        while (i--) stylesheet.deleteRule(i);

        current_rules = {};
      });
    }

    function create_animation(node, from, fn, params) {
      if (!from) return noop;
      const to = node.getBoundingClientRect();
      if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return noop;
      const {
        delay = 0,
        duration = 300,
        easing = identity,
        // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
        start: start_time = now() + delay,
        // @ts-ignore todo:
        end = start_time + duration,
        tick = noop,
        css
      } = fn(node, {
        from,
        to
      }, params);
      let running = true;
      let started = false;
      let name;

      function start() {
        if (css) {
          name = create_rule(node, 0, 1, duration, delay, easing, css);
        }

        if (!delay) {
          started = true;
        }
      }

      function stop() {
        if (css) delete_rule(node, name);
        running = false;
      }

      loop(now => {
        if (!started && now >= start_time) {
          started = true;
        }

        if (started && now >= end) {
          tick(1, 0);
          stop();
        }

        if (!running) {
          return false;
        }

        if (started) {
          const p = now - start_time;
          const t = 0 + 1 * easing(p / duration);
          tick(t, 1 - t);
        }

        return true;
      });
      start();
      tick(0, 1);
      return stop;
    }

    function fix_position(node) {
      const style = getComputedStyle(node);

      if (style.position !== 'absolute' && style.position !== 'fixed') {
        const {
          width,
          height
        } = style;
        const a = node.getBoundingClientRect();
        node.style.position = 'absolute';
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
      }
    }

    function add_transform(node, a) {
      const b = node.getBoundingClientRect();

      if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
      }
    }

    let current_component;

    function set_current_component(component) {
      current_component = component;
    }

    function get_current_component() {
      if (!current_component) throw new Error(`Function called outside component initialization`);
      return current_component;
    }

    function onMount(fn) {
      get_current_component().$$.on_mount.push(fn);
    }

    function createEventDispatcher() {
      const component = get_current_component();
      return (type, detail) => {
        const callbacks = component.$$.callbacks[type];

        if (callbacks) {
          // TODO are there situations where events could be dispatched
          // in a server (non-DOM) environment?
          const event = custom_event(type, detail);
          callbacks.slice().forEach(fn => {
            fn.call(component, event);
          });
        }
      };
    }
    // shorthand events, or if we want to implement
    // a real bubbling mechanism


    function bubble(component, event) {
      const callbacks = component.$$.callbacks[event.type];

      if (callbacks) {
        callbacks.slice().forEach(fn => fn(event));
      }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;

    function schedule_update() {
      if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
      }
    }

    function tick() {
      schedule_update();
      return resolved_promise;
    }

    function add_render_callback(fn) {
      render_callbacks.push(fn);
    }

    function add_flush_callback(fn) {
      flush_callbacks.push(fn);
    }

    function flush() {
      const seen_callbacks = new Set();

      do {
        // first, call beforeUpdate functions
        // and update components
        while (dirty_components.length) {
          const component = dirty_components.shift();
          set_current_component(component);
          update(component.$$);
        }

        while (binding_callbacks.length) binding_callbacks.pop()(); // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...


        for (let i = 0; i < render_callbacks.length; i += 1) {
          const callback = render_callbacks[i];

          if (!seen_callbacks.has(callback)) {
            callback(); // ...so guard against infinite loops

            seen_callbacks.add(callback);
          }
        }

        render_callbacks.length = 0;
      } while (dirty_components.length);

      while (flush_callbacks.length) {
        flush_callbacks.pop()();
      }

      update_scheduled = false;
    }

    function update($$) {
      if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
      }
    }

    let promise;

    function wait() {
      if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
          promise = null;
        });
      }

      return promise;
    }

    function dispatch(node, direction, kind) {
      node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }

    const outroing = new Set();
    let outros;

    function group_outros() {
      outros = {
        r: 0,
        c: [],
        p: outros // parent group

      };
    }

    function check_outros() {
      if (!outros.r) {
        run_all(outros.c);
      }

      outros = outros.p;
    }

    function transition_in(block, local) {
      if (block && block.i) {
        outroing.delete(block);
        block.i(local);
      }
    }

    function transition_out(block, local, detach, callback) {
      if (block && block.o) {
        if (outroing.has(block)) return;
        outroing.add(block);
        outros.c.push(() => {
          outroing.delete(block);

          if (callback) {
            if (detach) block.d(1);
            callback();
          }
        });
        block.o(local);
      }
    }

    const null_transition = {
      duration: 0
    };

    function create_in_transition(node, fn, params) {
      let config = fn(node, params);
      let running = false;
      let animation_name;
      let task;
      let uid = 0;

      function cleanup() {
        if (animation_name) delete_rule(node, animation_name);
      }

      function go() {
        const {
          delay = 0,
          duration = 300,
          easing = identity,
          tick = noop,
          css
        } = config || null_transition;
        if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task) task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
          if (running) {
            if (now >= end_time) {
              tick(1, 0);
              dispatch(node, true, 'end');
              cleanup();
              return running = false;
            }

            if (now >= start_time) {
              const t = easing((now - start_time) / duration);
              tick(t, 1 - t);
            }
          }

          return running;
        });
      }

      let started = false;
      return {
        start() {
          if (started) return;
          delete_rule(node);

          if (is_function(config)) {
            config = config();
            wait().then(go);
          } else {
            go();
          }
        },

        invalidate() {
          started = false;
        },

        end() {
          if (running) {
            cleanup();
            running = false;
          }
        }

      };
    }

    function create_out_transition(node, fn, params) {
      let config = fn(node, params);
      let running = true;
      let animation_name;
      const group = outros;
      group.r += 1;

      function go() {
        const {
          delay = 0,
          duration = 300,
          easing = identity,
          tick = noop,
          css
        } = config || null_transition;
        if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, 'start'));
        loop(now => {
          if (running) {
            if (now >= end_time) {
              tick(0, 1);
              dispatch(node, false, 'end');

              if (! --group.r) {
                // this will result in `end()` being called,
                // so we don't need to clean up here
                run_all(group.c);
              }

              return false;
            }

            if (now >= start_time) {
              const t = easing((now - start_time) / duration);
              tick(1 - t, t);
            }
          }

          return running;
        });
      }

      if (is_function(config)) {
        wait().then(() => {
          // @ts-ignore
          config = config();
          go();
        });
      } else {
        go();
      }

      return {
        end(reset) {
          if (reset && config.tick) {
            config.tick(1, 0);
          }

          if (running) {
            if (animation_name) delete_rule(node, animation_name);
            running = false;
          }
        }

      };
    }

    function create_bidirectional_transition(node, fn, params, intro) {
      let config = fn(node, params);
      let t = intro ? 0 : 1;
      let running_program = null;
      let pending_program = null;
      let animation_name = null;

      function clear_animation() {
        if (animation_name) delete_rule(node, animation_name);
      }

      function init(program, duration) {
        const d = program.b - t;
        duration *= Math.abs(d);
        return {
          a: t,
          b: program.b,
          d,
          duration,
          start: program.start,
          end: program.start + duration,
          group: program.group
        };
      }

      function go(b) {
        const {
          delay = 0,
          duration = 300,
          easing = identity,
          tick = noop,
          css
        } = config || null_transition;
        const program = {
          start: now() + delay,
          b
        };

        if (!b) {
          // @ts-ignore todo: improve typings
          program.group = outros;
          outros.r += 1;
        }

        if (running_program) {
          pending_program = program;
        } else {
          // if this is an intro, and there's a delay, we need to do
          // an initial tick and/or apply CSS animation immediately
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, b, duration, delay, easing, css);
          }

          if (b) tick(0, 1);
          running_program = init(program, duration);
          add_render_callback(() => dispatch(node, b, 'start'));
          loop(now => {
            if (pending_program && now > pending_program.start) {
              running_program = init(pending_program, duration);
              pending_program = null;
              dispatch(node, running_program.b, 'start');

              if (css) {
                clear_animation();
                animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
              }
            }

            if (running_program) {
              if (now >= running_program.end) {
                tick(t = running_program.b, 1 - t);
                dispatch(node, running_program.b, 'end');

                if (!pending_program) {
                  // we're done
                  if (running_program.b) {
                    // intro — we can tidy up immediately
                    clear_animation();
                  } else {
                    // outro — needs to be coordinated
                    if (! --running_program.group.r) run_all(running_program.group.c);
                  }
                }

                running_program = null;
              } else if (now >= running_program.start) {
                const p = now - running_program.start;
                t = running_program.a + running_program.d * easing(p / running_program.duration);
                tick(t, 1 - t);
              }
            }

            return !!(running_program || pending_program);
          });
        }
      }

      return {
        run(b) {
          if (is_function(config)) {
            wait().then(() => {
              // @ts-ignore
              config = config();
              go(b);
            });
          } else {
            go(b);
          }
        },

        end() {
          clear_animation();
          running_program = pending_program = null;
        }

      };
    }

    function handle_promise(promise, info) {
      const token = info.token = {};

      function update(type, index, key, value) {
        if (info.token !== token) return;
        info.resolved = value;
        let child_ctx = info.ctx;

        if (key !== undefined) {
          child_ctx = child_ctx.slice();
          child_ctx[key] = value;
        }

        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;

        if (info.block) {
          if (info.blocks) {
            info.blocks.forEach((block, i) => {
              if (i !== index && block) {
                group_outros();
                transition_out(block, 1, 1, () => {
                  info.blocks[i] = null;
                });
                check_outros();
              }
            });
          } else {
            info.block.d(1);
          }

          block.c();
          transition_in(block, 1);
          block.m(info.mount(), info.anchor);
          needs_flush = true;
        }

        info.block = block;
        if (info.blocks) info.blocks[index] = block;

        if (needs_flush) {
          flush();
        }
      }

      if (is_promise(promise)) {
        const current_component = get_current_component();
        promise.then(value => {
          set_current_component(current_component);
          update(info.then, 1, info.value, value);
          set_current_component(null);
        }, error => {
          set_current_component(current_component);
          update(info.catch, 2, info.error, error);
          set_current_component(null);
        }); // if we previously had a then/catch block, destroy it

        if (info.current !== info.pending) {
          update(info.pending, 0);
          return true;
        }
      } else {
        if (info.current !== info.then) {
          update(info.then, 1, info.value, promise);
          return true;
        }

        info.resolved = promise;
      }
    }

    const globals = typeof window !== 'undefined' ? window : global;

    function outro_and_destroy_block(block, lookup) {
      transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
      });
    }

    function fix_and_outro_and_destroy_block(block, lookup) {
      block.f();
      outro_and_destroy_block(block, lookup);
    }

    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
      let o = old_blocks.length;
      let n = list.length;
      let i = o;
      const old_indexes = {};

      while (i--) old_indexes[old_blocks[i].key] = i;

      const new_blocks = [];
      const new_lookup = new Map();
      const deltas = new Map();
      i = n;

      while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);

        if (!block) {
          block = create_each_block(key, child_ctx);
          block.c();
        } else if (dynamic) {
          block.p(child_ctx, dirty);
        }

        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
      }

      const will_move = new Set();
      const did_move = new Set();

      function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
      }

      while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;

        if (new_block === old_block) {
          // do nothing
          next = new_block.first;
          o--;
          n--;
        } else if (!new_lookup.has(old_key)) {
          // remove old block
          destroy(old_block, lookup);
          o--;
        } else if (!lookup.has(new_key) || will_move.has(new_key)) {
          insert(new_block);
        } else if (did_move.has(old_key)) {
          o--;
        } else if (deltas.get(new_key) > deltas.get(old_key)) {
          did_move.add(new_key);
          insert(new_block);
        } else {
          will_move.add(old_key);
          o--;
        }
      }

      while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
      }

      while (n) insert(new_blocks[n - 1]);

      return new_blocks;
    }

    function bind(component, name, callback) {
      const index = component.$$.props[name];

      if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
      }
    }

    function create_component(block) {
      block && block.c();
    }

    function mount_component(component, target, anchor) {
      const {
        fragment,
        on_mount,
        on_destroy,
        after_update
      } = component.$$;
      fragment && fragment.m(target, anchor); // onMount happens before the initial afterUpdate

      add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);

        if (on_destroy) {
          on_destroy.push(...new_on_destroy);
        } else {
          // Edge case - component was destroyed immediately,
          // most likely as a result of a binding initialising
          run_all(new_on_destroy);
        }

        component.$$.on_mount = [];
      });
      after_update.forEach(add_render_callback);
    }

    function destroy_component(component, detaching) {
      const $$ = component.$$;

      if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)

        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
      }
    }

    function make_dirty(component, i) {
      if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
      }

      component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
    }

    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
      const parent_component = current_component;
      set_current_component(component);
      const prop_values = options.props || {};
      const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty
      };
      let ready = false;
      $$.ctx = instance ? instance(component, prop_values, (i, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;

        if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
          if ($$.bound[i]) $$.bound[i](value);
          if (ready) make_dirty(component, i);
        }

        return ret;
      }) : [];
      $$.update();
      ready = true;
      run_all($$.before_update); // `false` as a special case of no DOM component

      $$.fragment = create_fragment ? create_fragment($$.ctx) : false;

      if (options.target) {
        if (options.hydrate) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          $$.fragment && $$.fragment.l(children(options.target));
        } else {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          $$.fragment && $$.fragment.c();
        }

        if (options.intro) transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
      }

      set_current_component(parent_component);
    }

    class SvelteComponent {
      $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
      }

      $on(type, callback) {
        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return () => {
          const index = callbacks.indexOf(callback);
          if (index !== -1) callbacks.splice(index, 1);
        };
      }

      $set() {// overridden by instance, if it has props
      }

    }

    function dispatch_dev(type, detail) {
      document.dispatchEvent(custom_event(type, Object.assign({
        version: '3.17.1'
      }, detail)));
    }

    function append_dev(target, node) {
      dispatch_dev("SvelteDOMInsert", {
        target,
        node
      });
      append(target, node);
    }

    function insert_dev(target, node, anchor) {
      dispatch_dev("SvelteDOMInsert", {
        target,
        node,
        anchor
      });
      insert(target, node, anchor);
    }

    function detach_dev(node) {
      dispatch_dev("SvelteDOMRemove", {
        node
      });
      detach(node);
    }

    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
      const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
      if (has_prevent_default) modifiers.push('preventDefault');
      if (has_stop_propagation) modifiers.push('stopPropagation');
      dispatch_dev("SvelteDOMAddEventListener", {
        node,
        event,
        handler,
        modifiers
      });
      const dispose = listen(node, event, handler, options);
      return () => {
        dispatch_dev("SvelteDOMRemoveEventListener", {
          node,
          event,
          handler,
          modifiers
        });
        dispose();
      };
    }

    function attr_dev(node, attribute, value) {
      attr(node, attribute, value);
      if (value == null) dispatch_dev("SvelteDOMRemoveAttribute", {
        node,
        attribute
      });else dispatch_dev("SvelteDOMSetAttribute", {
        node,
        attribute,
        value
      });
    }

    function prop_dev(node, property, value) {
      node[property] = value;
      dispatch_dev("SvelteDOMSetProperty", {
        node,
        property,
        value
      });
    }

    function set_data_dev(text, data) {
      data = '' + data;
      if (text.data === data) return;
      dispatch_dev("SvelteDOMSetData", {
        node: text,
        data
      });
      text.data = data;
    }

    class SvelteComponentDev extends SvelteComponent {
      constructor(options) {
        if (!options || !options.target && !options.$$inline) {
          throw new Error(`'target' is a required option`);
        }

        super();
      }

      $destroy() {
        super.$destroy();

        this.$destroy = () => {
          console.warn(`Component was already destroyed`); // eslint-disable-line no-console
        };
      }

    }

    function cubicOut(t) {
      const f = t - 1.0;
      return f * f * f + 1.0;
    }

    function quintOut(t) {
      return --t * t * t * t * t + 1;
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __rest(s, e) {
      var t = {};

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    }

    function fade(node, {
      delay = 0,
      duration = 400,
      easing = identity
    }) {
      const o = +getComputedStyle(node).opacity;
      return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
      };
    }

    function fly(node, {
      delay = 0,
      duration = 400,
      easing = cubicOut,
      x = 0,
      y = 0,
      opacity = 0
    }) {
      const style = getComputedStyle(node);
      const target_opacity = +style.opacity;
      const transform = style.transform === 'none' ? '' : style.transform;
      const od = target_opacity * (1 - opacity);
      return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - od * u}`
      };
    }

    function scale(node, {
      delay = 0,
      duration = 400,
      easing = cubicOut,
      start = 0,
      opacity = 0
    }) {
      const style = getComputedStyle(node);
      const target_opacity = +style.opacity;
      const transform = style.transform === 'none' ? '' : style.transform;
      const sd = 1 - start;
      const od = target_opacity * (1 - opacity);
      return {
        delay,
        duration,
        easing,
        css: (_t, u) => `
			transform: ${transform} scale(${1 - sd * u});
			opacity: ${target_opacity - od * u}
		`
      };
    }

    function crossfade(_a) {
      var {
        fallback
      } = _a,
          defaults = __rest(_a, ["fallback"]);

      const to_receive = new Map();
      const to_send = new Map();

      function crossfade(from, node, params) {
        const {
          delay = 0,
          duration = d => Math.sqrt(d) * 30,
          easing = cubicOut
        } = assign(assign({}, defaults), params);
        const to = node.getBoundingClientRect();
        const dx = from.left - to.left;
        const dy = from.top - to.top;
        const dw = from.width / to.width;
        const dh = from.height / to.height;
        const d = Math.sqrt(dx * dx + dy * dy);
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        const opacity = +style.opacity;
        return {
          delay,
          duration: is_function(duration) ? duration(d) : duration,
          easing,
          css: (t, u) => `
				opacity: ${t * opacity};
				transform-origin: top left;
				transform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${t + (1 - t) * dh});
			`
        };
      }

      function transition(items, counterparts, intro) {
        return (node, params) => {
          items.set(params.key, {
            rect: node.getBoundingClientRect()
          });
          return () => {
            if (counterparts.has(params.key)) {
              const {
                rect
              } = counterparts.get(params.key);
              counterparts.delete(params.key);
              return crossfade(rect, node, params);
            } // if the node is disappearing altogether
            // (i.e. wasn't claimed by the other list)
            // then we need to supply an outro


            items.delete(params.key);
            return fallback && fallback(node, params, intro);
          };
        };
      }

      return [transition(to_send, to_receive, false), transition(to_receive, to_send, true)];
    }

    function flip(node, animation, params) {
      const style = getComputedStyle(node);
      const transform = style.transform === 'none' ? '' : style.transform;
      const scaleX = animation.from.width / node.clientWidth;
      const scaleY = animation.from.height / node.clientHeight;
      const dx = (animation.from.left - animation.to.left) / scaleX;
      const dy = (animation.from.top - animation.to.top) / scaleY;
      const d = Math.sqrt(dx * dx + dy * dy);
      const {
        delay = 0,
        duration = d => Math.sqrt(d) * 120,
        easing = cubicOut
      } = params;
      return {
        delay,
        duration: is_function(duration) ? duration(d) : duration,
        easing,
        css: (_t, u) => `transform: ${transform} translate(${u * dx}px, ${u * dy}px);`
      };
    }

    /* node_modules\svelte-sortable-list\SortableList.svelte generated by Svelte v3.17.1 */
    const file = "node_modules\\svelte-sortable-list\\SortableList.svelte";

    const get_default_slot_changes = dirty => ({
      item: dirty &
      /*list*/
      1,
      index: dirty &
      /*list*/
      1
    });

    const get_default_slot_context = ctx => ({
      item:
      /*item*/
      ctx[15],
      index:
      /*index*/
      ctx[17]
    });

    function get_each_context(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[15] = list[i];
      child_ctx[17] = i;
      return child_ctx;
    } // (84:0) {#if list && list.length}


    function create_if_block(ctx) {
      let ul;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let current;
      let each_value =
      /*list*/
      ctx[0];

      const get_key = ctx =>
      /*getKey*/
      ctx[8](
      /*item*/
      ctx[15]);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
      }

      const block = {
        c: function create() {
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(ul, "class", "svelte-10oqu91");
          add_location(ul, file, 84, 2, 2733);
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          const each_value =
          /*list*/
          ctx[0];
          group_outros();

          for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();

          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, fix_and_outro_and_destroy_block, create_each_block, null, get_each_context);

          for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();

          check_outros();
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block.name,
        type: "if",
        source: "(84:0) {#if list && list.length}",
        ctx
      });
      return block;
    } // (86:4) {#each list as item, index (getKey(item))}


    function create_each_block(key_2, ctx) {
      let li;
      let p;
      let t0_value =
      /*getKey*/
      ctx[8](
      /*item*/
      ctx[15]) + "";
      let t0;
      let t1;
      let li_data_index_value;
      let li_data_id_value;
      let li_intro;
      let li_outro;
      let rect;
      let stop_animation = noop;
      let current;
      let dispose;
      const default_slot_template =
      /*$$slots*/
      ctx[14].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[13], get_default_slot_context);
      const block = {
        key: key_2,
        first: null,
        c: function create() {
          li = element("li");

          if (!default_slot) {
            p = element("p");
            t0 = text(t0_value);
          }

          if (default_slot) default_slot.c();
          t1 = space();

          if (!default_slot) {
            add_location(p, file, 99, 10, 3213);
          }

          attr_dev(li, "data-index", li_data_index_value =
          /*index*/
          ctx[17]);
          attr_dev(li, "draggable", "true");
          attr_dev(li, "data-id", li_data_id_value = JSON.stringify(
          /*getKey*/
          ctx[8](
          /*item*/
          ctx[15])));
          attr_dev(li, "class", "svelte-10oqu91");
          toggle_class(li, "over",
          /*getKey*/
          ctx[8](
          /*item*/
          ctx[15]) ===
          /*isOver*/
          ctx[1]);
          add_location(li, file, 86, 6, 2791);
          this.first = li;
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);

          if (!default_slot) {
            append_dev(li, p);
            append_dev(p, t0);
          }

          if (default_slot) {
            default_slot.m(li, null);
          }

          append_dev(li, t1);
          current = true;
          dispose = [listen_dev(li, "dragstart",
          /*start*/
          ctx[4], false, false, false), listen_dev(li, "dragover",
          /*over*/
          ctx[5], false, false, false), listen_dev(li, "dragleave",
          /*leave*/
          ctx[6], false, false, false), listen_dev(li, "drop",
          /*drop*/
          ctx[7], false, false, false)];
        },
        p: function update(ctx, dirty) {
          if (!default_slot) {
            if ((!current || dirty &
            /*list*/
            1) && t0_value !== (t0_value =
            /*getKey*/
            ctx[8](
            /*item*/
            ctx[15]) + "")) set_data_dev(t0, t0_value);
          }

          if (default_slot && default_slot.p && dirty &
          /*$$scope, list*/
          8193) {
            default_slot.p(get_slot_context(default_slot_template, ctx,
            /*$$scope*/
            ctx[13], get_default_slot_context), get_slot_changes(default_slot_template,
            /*$$scope*/
            ctx[13], dirty, get_default_slot_changes));
          }

          if (!current || dirty &
          /*list*/
          1 && li_data_index_value !== (li_data_index_value =
          /*index*/
          ctx[17])) {
            attr_dev(li, "data-index", li_data_index_value);
          }

          if (!current || dirty &
          /*list*/
          1 && li_data_id_value !== (li_data_id_value = JSON.stringify(
          /*getKey*/
          ctx[8](
          /*item*/
          ctx[15])))) {
            attr_dev(li, "data-id", li_data_id_value);
          }

          if (dirty &
          /*getKey, list, isOver*/
          259) {
            toggle_class(li, "over",
            /*getKey*/
            ctx[8](
            /*item*/
            ctx[15]) ===
            /*isOver*/
            ctx[1]);
          }
        },
        r: function measure() {
          rect = li.getBoundingClientRect();
        },
        f: function fix() {
          fix_position(li);
          stop_animation();
          add_transform(li, rect);
        },
        a: function animate() {
          stop_animation();
          stop_animation = create_animation(li, rect, flip, {
            duration: 300
          });
        },
        i: function intro(local) {
          if (current) return;
          transition_in(default_slot, local);
          add_render_callback(() => {
            if (li_outro) li_outro.end(1);
            if (!li_intro) li_intro = create_in_transition(li,
            /*receive*/
            ctx[3], {
              key:
              /*getKey*/
              ctx[8](
              /*item*/
              ctx[15])
            });
            li_intro.start();
          });
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          if (li_intro) li_intro.invalidate();
          li_outro = create_out_transition(li,
          /*send*/
          ctx[2], {
            key:
            /*getKey*/
            ctx[8](
            /*item*/
            ctx[15])
          });
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          if (default_slot) default_slot.d(detaching);
          if (detaching && li_outro) li_outro.end();
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block.name,
        type: "each",
        source: "(86:4) {#each list as item, index (getKey(item))}",
        ctx
      });
      return block;
    }

    function create_fragment(ctx) {
      let if_block_anchor;
      let current;
      let if_block =
      /*list*/
      ctx[0] &&
      /*list*/
      ctx[0].length && create_if_block(ctx);
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (
          /*list*/
          ctx[0] &&
          /*list*/
          ctx[0].length) {
            if (if_block) {
              if_block.p(ctx, dirty);
              transition_in(if_block, 1);
            } else {
              if_block = create_if_block(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance($$self, $$props, $$invalidate) {
      const [send, receive] = crossfade({
        duration: d => Math.sqrt(d * 200),

        fallback(node, params) {
          const style = getComputedStyle(node);
          const transform = style.transform === "none" ? "" : style.transform;
          return {
            duration: 600,
            easing: quintOut,
            css: t => `
					transform: ${transform} scale(${t});
					opacity: ${t}
				`
          };
        }

      });
      let isOver = false;

      const getDraggedParent = node => node.dataset.index && node.dataset || getDraggedParent(node.parentNode);

      const start = ev => {
        ev.dataTransfer.setData("source", ev.target.dataset.index);
      };

      const over = ev => {
        ev.preventDefault();
        let dragged = getDraggedParent(ev.target);
        if (isOver !== dragged.id) $$invalidate(1, isOver = JSON.parse(dragged.id));
      };

      const leave = ev => {
        let dragged = getDraggedParent(ev.target);
        if (isOver === dragged.id) $$invalidate(1, isOver = false);
      };

      const drop = ev => {
        $$invalidate(1, isOver = false);
        ev.preventDefault();
        let dragged = getDraggedParent(ev.target);
        let from = ev.dataTransfer.getData("source");
        let to = dragged.index;
        reorder({
          from,
          to
        });
      };

      const dispatch = createEventDispatcher();

      const reorder = ({
        from,
        to
      }) => {
        let newList = [...list];
        newList[from] = [newList[to], newList[to] = newList[from]][0];
        dispatch("sort", newList);
      };

      const getKey = item => key ? item[key] : item;

      let {
        list
      } = $$props;
      let {
        key
      } = $$props;
      const writable_props = ["list", "key"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SortableList> was created with unknown prop '${key}'`);
      });
      let {
        $$slots = {},
        $$scope
      } = $$props;

      $$self.$set = $$props => {
        if ("list" in $$props) $$invalidate(0, list = $$props.list);
        if ("key" in $$props) $$invalidate(9, key = $$props.key);
        if ("$$scope" in $$props) $$invalidate(13, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => {
        return {
          isOver,
          list,
          key
        };
      };

      $$self.$inject_state = $$props => {
        if ("isOver" in $$props) $$invalidate(1, isOver = $$props.isOver);
        if ("list" in $$props) $$invalidate(0, list = $$props.list);
        if ("key" in $$props) $$invalidate(9, key = $$props.key);
      };

      return [list, isOver, send, receive, start, over, leave, drop, getKey, key, getDraggedParent, dispatch, reorder, $$scope, $$slots];
    }

    class SortableList extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance, create_fragment, safe_not_equal, {
          list: 0,
          key: 9
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "SortableList",
          options,
          id: create_fragment.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*list*/
        ctx[0] === undefined && !("list" in props)) {
          console.warn("<SortableList> was created without expected prop 'list'");
        }

        if (
        /*key*/
        ctx[9] === undefined && !("key" in props)) {
          console.warn("<SortableList> was created without expected prop 'key'");
        }
      }

      get list() {
        throw new Error("<SortableList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set list(value) {
        throw new Error("<SortableList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get key() {
        throw new Error("<SortableList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set key(value) {
        throw new Error("<SortableList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    function cubicOut$1(t) {
      var f = t - 1.0;
      return f * f * f + 1.0;
    }

    const Datastore = require('nedb');

    const app = require('electron').remote.app;

    const root = app.getAppPath();

    let abbreviate = (content, limit) => {
      if (content && content.length > limit) return content.substr(0, limit) + '...';else return content;
    };

    function saveLOA(data, datadir = root + '/data') {
      return new Promise((resolve, reject) => {
        const db = new Datastore({
          filename: datadir + '/loas.db',
          autoload: true
        });
        const record = new Datastore({
          filename: datadir + '/records.db',
          autoload: true
        });
        let shrinkAccoms = data.accoms.map(accom => {
          return {
            _id: accom._id,
            name: accom.name
          };
        });
        let {
          accoms,
          ...shrinkData
        } = data;
        shrinkData.accoms = shrinkAccoms;
        db.update({
          "student._id": data.student._id
        }, //Find
        {
          $set: shrinkData
        }, //Update data
        {
          upsert: true
        }, //options
        err => {
          if (err) reject();else record.insert(data, err => {
            if (err) reject();
            resolve(true);
          });
        });
      });
    }

    function loadLOA(student, datadir = root + '/data') {
      return new Promise((resolve, reject) => {
        const db = new Datastore({
          filename: datadir + '/loas.db',
          autoload: true
        });
        db.findOne({
          "student._id": student._id
        }, (err, doc) => {
          if (err) reject(err);else resolve(doc);
        });
      });
    }

    function searchLOA(search, datadir = root + '/data') {
      return new Promise((resolve, reject) => {
        const db = new Datastore({
          filename: datadir + '/loas.db',
          autoload: true
        });
        db.find({
          $or: [{
            "student._id": search._id
          }, {
            $and: [{
              "student.fname": search.fname
            }, {
              "student.lname": search.lname
            }]
          }, {
            "student.fname": search.fname
          }, {
            "student.lname": search.lname
          }]
        }).limit(25).exec((err, doc) => {
          if (err) reject(err);else resolve(doc);
        });
      });
    }

    function loadAccommodations(datadir = root + '/data') {
      return new Promise((resolve, reject) => {
        const db = new Datastore({
          filename: datadir + '/accoms.db',
          autoload: true
        });
        db.find({}).sort({
          name: 1
        }).exec((err, doc) => {
          if (err) reject(err);else resolve(doc);
        });
      });
    }

    function saveAccommodation(data, datadir = root + '/data') {
      return new Promise((resolve, reject) => {
        const db = new Datastore({
          filename: datadir + '/accoms.db',
          autoload: true
        });
        db.update({
          _id: data._id
        }, //Find
        data, //Update data
        {
          upsert: true
        }, //options
        err => {
          if (err) reject();
          resolve(true);
        });
      });
    }

    function removeAccommodation(id, datadir = root + '/data') {
      return new Promise((resolve, reject) => {
        const db = new Datastore({
          filename: datadir + '/accoms.db',
          autoload: true
        });
        db.remove({
          _id: id
        }, {}, err => {
          if (err) reject();
          resolve(true);
        });
      });
    }

    function loadStudents(skip, take, search = "", datadir = root + '/data') {
      return new Promise((resolve, reject) => {
        const db = new Datastore({
          filename: datadir + '/loas.db',
          autoload: true
        });
        let findFunc = null;

        if (search && search.includes(' ') || search.includes(',')) {
          let searchTerms;
          if (search.includes(', ')) searchTerms = search.split(", ");else if (search.includes(',')) searchTerms = search.split(",");else searchTerms = search.split(" ");
          findFunc = db.find({
            $or: [{
              $and: [{
                "student.fname": new RegExp(searchTerms[0].replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'i')
              }, {
                "student.lname": new RegExp(searchTerms[1].replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'i')
              }]
            }, {
              $and: [{
                "student.fname": new RegExp(searchTerms[1].replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'i')
              }, {
                "student.lname": new RegExp(searchTerms[0].replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'i')
              }]
            }]
          });
        } else if (search) {
          findFunc = db.find({
            $or: [{
              "student._id": new RegExp(search.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'i')
            }, {
              "student.fname": new RegExp(search.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'i')
            }, {
              "student.lname": new RegExp(search.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'i')
            }]
          });
        } else {
          findFunc = db.find({});
        }

        findFunc.skip(skip).limit(take).exec((err, doc) => {
          if (err) reject(err);else {
            doc.forEach(student => {
              if (student.accoms) {
                student.accomsList = student.accoms.map(accom => {
                  return accom.name;
                });
              }
            });
            resolve(doc);
          }
        });
      });
    }

    function countStudents(datadir = root + '/data') {
      return new Promise((resolve, reject) => {
        const db = new Datastore({
          filename: datadir + '/loas.db',
          autoload: true
        });
        db.count({}, (err, count) => {
          if (err) reject(err);else resolve(count);
        });
      });
    }

    function saveStudent(data, datadir = root + '/data') {
      return new Promise((resolve, reject) => {
        const db = new Datastore({
          filename: datadir + '/loas.db',
          autoload: true
        });
        db.update({
          "student._id": data._id
        }, //Find
        {
          student: data
        }, //Update data
        {
          upsert: true
        }, //options
        err => {
          if (err) reject();
          resolve(true);
        });
      });
    }

    function removeStudent(id, datadir = root + '/data') {
      return new Promise((resolve, reject) => {
        const db = new Datastore({
          filename: datadir + '/loas.db',
          autoload: true
        });
        db.remove({
          "student._id": id
        }, {}, err => {
          if (err) reject();
          resolve(true);
        });
      });
    }

    function loadRecords(id, datadir = root + '/data') {
      return new Promise((resolve, reject) => {
        const loas = new Datastore({
          filename: datadir + '/loas.db',
          autoload: true
        });
        const records = new Datastore({
          filename: datadir + '/records.db',
          autoload: true
        });
        loas.findOne({
          "student._id": id
        }, (err, student) => {
          if (err) reject(err);else records.find({
            "student._id": id
          }, (err, records) => {
            if (err) reject(err);else {
              student.records = records.sort((a, b) => {
                return b.dateUpdated - a.dateUpdated;
              });
              resolve(student);
            }
          });
        });
      });
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */


    function writable(value, start = noop) {
      let stop;
      const subscribers = [];

      function set(new_value) {
        if (safe_not_equal(value, new_value)) {
          value = new_value;

          if (stop) {
            // store is ready
            const run_queue = !subscriber_queue.length;

            for (let i = 0; i < subscribers.length; i += 1) {
              const s = subscribers[i];
              s[1]();
              subscriber_queue.push(s, value);
            }

            if (run_queue) {
              for (let i = 0; i < subscriber_queue.length; i += 2) {
                subscriber_queue[i][0](subscriber_queue[i + 1]);
              }

              subscriber_queue.length = 0;
            }
          }
        }
      }

      function update(fn) {
        set(fn(value));
      }

      function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);

        if (subscribers.length === 1) {
          stop = start(set) || noop;
        }

        run(value);
        return () => {
          const index = subscribers.indexOf(subscriber);

          if (index !== -1) {
            subscribers.splice(index, 1);
          }

          if (subscribers.length === 0) {
            stop();
            stop = null;
          }
        };
      }

      return {
        set,
        update,
        subscribe
      };
    }

    const fs = require('fs');

    const app$1 = require('electron').remote.app;

    const root$1 = app$1.getAppPath();
    const settings = writable({});

    if (fs.existsSync(root$1 + '/appdata/appsettings.json')) {
      settings.set(JSON.parse(fs.readFileSync(root$1 + '/appdata/appsettings.json')));
    } else {
      settings.set({
        abbrev: "Notice",
        services: "Services",
        students: "Students"
      });
    }

    let pluralize = str => {
      if (str.length > 0) {
        if (str.charAt(str.length - 1) == 'x' || str.charAt(str.length - 1) == 'z' || str.charAt(str.length - 1) == 'h' && (str.charAt(str.length - 2) == 's' || str.charAt(str.length - 2) == 'c') || str.charAt(str.length - 1) == 's' && str.charAt(str.length - 2) == 's') {
          str = str.concat('es');
        } else if (str.charAt(str.length - 1) != 's') {
          str = str.concat('s');
        }
      }

      return str;
    };

    const formatText = (str, plur = true, uc = true, allcaps = false) => {
      if (plur) str = pluralize(str);else if (str.charAt(str.length - 1) == 's') str = str.substring(0, str.length - 1);

      if (!allcaps) {
        str = str.toLowerCase();
        if (uc) str = str.replace(str.charAt(0), str.charAt(0).toUpperCase(), 1);
      } else {
        if (str.length < 4) str = str.toUpperCase();else str = str.replace(str.charAt(0), str.charAt(0).toUpperCase(), 1);
      }

      return str;
    };
    let changeSettings = data => {
      fs.writeFileSync(root$1 + '/appdata/appsettings.json', JSON.stringify(data));
    };

    const getCalendarPage = (month, year, dayProps, weekStart = 0) => {
      let date = new Date(year, month, 1);
      date.setDate(date.getDate() - date.getDay() + weekStart);
      let nextMonth = month === 11 ? 0 : month + 1; // ensure days starts on Sunday
      // and end on saturday

      let weeks = [];

      while (date.getMonth() !== nextMonth || date.getDay() !== weekStart || weeks.length !== 6) {
        if (date.getDay() === weekStart) weeks.unshift({
          days: [],
          id: `${year}${month}${year}${weeks.length}`
        });
        const updated = Object.assign({
          partOfMonth: date.getMonth() === month,
          day: date.getDate(),
          month: date.getMonth(),
          year: date.getFullYear(),
          date: new Date(date)
        }, dayProps(date));
        weeks[0].days.push(updated);
        date.setDate(date.getDate() + 1);
      }

      weeks.reverse();
      return {
        month,
        year,
        weeks
      };
    };

    const getDayPropsHandler = (start, end, selectableCallback) => {
      let today = new Date();
      today.setHours(0, 0, 0, 0);
      return date => {
        const isInRange = date >= start && date <= end;
        return {
          isInRange,
          selectable: isInRange && (!selectableCallback || selectableCallback(date)),
          isToday: date.getTime() === today.getTime()
        };
      };
    };

    function getMonths(start, end, selectableCallback = null, weekStart = 0) {
      start.setHours(0, 0, 0, 0);
      end.setHours(0, 0, 0, 0);
      let endDate = new Date(end.getFullYear(), end.getMonth() + 1, 1);
      let months = [];
      let date = new Date(start.getFullYear(), start.getMonth(), 1);
      let dayPropsHandler = getDayPropsHandler(start, end, selectableCallback);

      while (date < endDate) {
        months.push(getCalendarPage(date.getMonth(), date.getFullYear(), dayPropsHandler, weekStart));
        date.setMonth(date.getMonth() + 1);
      }

      return months;
    }
    const areDatesEquivalent = (a, b) => a.getDate() === b.getDate() && a.getMonth() === b.getMonth() && a.getFullYear() === b.getFullYear();

    /* node_modules\svelte-calendar\src\Components\Week.svelte generated by Svelte v3.17.1 */
    const file$1 = "node_modules\\svelte-calendar\\src\\Components\\Week.svelte";

    function get_each_context$1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[7] = list[i];
      return child_ctx;
    } // (20:2) {#each days as day}


    function create_each_block$1(ctx) {
      let div;
      let button;
      let t0_value =
      /*day*/
      ctx[7].date.getDate() + "";
      let t0;
      let t1;
      let dispose;

      function click_handler(...args) {
        return (
          /*click_handler*/
          ctx[6](
          /*day*/
          ctx[7], ...args)
        );
      }

      const block = {
        c: function create() {
          div = element("div");
          button = element("button");
          t0 = text(t0_value);
          t1 = space();
          attr_dev(button, "class", "day--label svelte-14d04qe");
          attr_dev(button, "type", "button");
          toggle_class(button, "selected", areDatesEquivalent(
          /*day*/
          ctx[7].date,
          /*selected*/
          ctx[1]));
          toggle_class(button, "highlighted", areDatesEquivalent(
          /*day*/
          ctx[7].date,
          /*highlighted*/
          ctx[2]));
          toggle_class(button, "shake-date",
          /*shouldShakeDate*/
          ctx[3] && areDatesEquivalent(
          /*day*/
          ctx[7].date,
          /*shouldShakeDate*/
          ctx[3]));
          toggle_class(button, "disabled", !
          /*day*/
          ctx[7].selectable);
          add_location(button, file$1, 26, 6, 654);
          attr_dev(div, "class", "day svelte-14d04qe");
          toggle_class(div, "outside-month", !
          /*day*/
          ctx[7].partOfMonth);
          toggle_class(div, "is-today",
          /*day*/
          ctx[7].isToday);
          toggle_class(div, "is-disabled", !
          /*day*/
          ctx[7].selectable);
          add_location(div, file$1, 20, 4, 489);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, button);
          append_dev(button, t0);
          append_dev(div, t1);
          dispose = listen_dev(button, "click", click_handler, false, false, false);
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty &
          /*days*/
          1 && t0_value !== (t0_value =
          /*day*/
          ctx[7].date.getDate() + "")) set_data_dev(t0, t0_value);

          if (dirty &
          /*areDatesEquivalent, days, selected*/
          3) {
            toggle_class(button, "selected", areDatesEquivalent(
            /*day*/
            ctx[7].date,
            /*selected*/
            ctx[1]));
          }

          if (dirty &
          /*areDatesEquivalent, days, highlighted*/
          5) {
            toggle_class(button, "highlighted", areDatesEquivalent(
            /*day*/
            ctx[7].date,
            /*highlighted*/
            ctx[2]));
          }

          if (dirty &
          /*shouldShakeDate, areDatesEquivalent, days*/
          9) {
            toggle_class(button, "shake-date",
            /*shouldShakeDate*/
            ctx[3] && areDatesEquivalent(
            /*day*/
            ctx[7].date,
            /*shouldShakeDate*/
            ctx[3]));
          }

          if (dirty &
          /*days*/
          1) {
            toggle_class(button, "disabled", !
            /*day*/
            ctx[7].selectable);
          }

          if (dirty &
          /*days*/
          1) {
            toggle_class(div, "outside-month", !
            /*day*/
            ctx[7].partOfMonth);
          }

          if (dirty &
          /*days*/
          1) {
            toggle_class(div, "is-today",
            /*day*/
            ctx[7].isToday);
          }

          if (dirty &
          /*days*/
          1) {
            toggle_class(div, "is-disabled", !
            /*day*/
            ctx[7].selectable);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$1.name,
        type: "each",
        source: "(20:2) {#each days as day}",
        ctx
      });
      return block;
    }

    function create_fragment$1(ctx) {
      let div;
      let div_intro;
      let div_outro;
      let current;
      let each_value =
      /*days*/
      ctx[0];
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          div = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(div, "class", "week svelte-14d04qe");
          add_location(div, file$1, 14, 0, 343);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div, null);
          }

          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*days, areDatesEquivalent, selected, highlighted, shouldShakeDate, dispatch*/
          47) {
            each_value =
            /*days*/
            ctx[0];
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$1(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$1(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (div_outro) div_outro.end(1);
            if (!div_intro) div_intro = create_in_transition(div, fly, {
              x:
              /*direction*/
              ctx[4] * 50,
              duration: 180,
              delay: 90
            });
            div_intro.start();
          });
          current = true;
        },
        o: function outro(local) {
          if (div_intro) div_intro.invalidate();
          div_outro = create_out_transition(div, fade, {
            duration: 180
          });
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_each(each_blocks, detaching);
          if (detaching && div_outro) div_outro.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$1.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
      const dispatch = createEventDispatcher();
      let {
        days
      } = $$props;
      let {
        selected
      } = $$props;
      let {
        highlighted
      } = $$props;
      let {
        shouldShakeDate
      } = $$props;
      let {
        direction
      } = $$props;
      const writable_props = ["days", "selected", "highlighted", "shouldShakeDate", "direction"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Week> was created with unknown prop '${key}'`);
      });

      const click_handler = day => dispatch("dateSelected", day.date);

      $$self.$set = $$props => {
        if ("days" in $$props) $$invalidate(0, days = $$props.days);
        if ("selected" in $$props) $$invalidate(1, selected = $$props.selected);
        if ("highlighted" in $$props) $$invalidate(2, highlighted = $$props.highlighted);
        if ("shouldShakeDate" in $$props) $$invalidate(3, shouldShakeDate = $$props.shouldShakeDate);
        if ("direction" in $$props) $$invalidate(4, direction = $$props.direction);
      };

      $$self.$capture_state = () => {
        return {
          days,
          selected,
          highlighted,
          shouldShakeDate,
          direction
        };
      };

      $$self.$inject_state = $$props => {
        if ("days" in $$props) $$invalidate(0, days = $$props.days);
        if ("selected" in $$props) $$invalidate(1, selected = $$props.selected);
        if ("highlighted" in $$props) $$invalidate(2, highlighted = $$props.highlighted);
        if ("shouldShakeDate" in $$props) $$invalidate(3, shouldShakeDate = $$props.shouldShakeDate);
        if ("direction" in $$props) $$invalidate(4, direction = $$props.direction);
      };

      return [days, selected, highlighted, shouldShakeDate, direction, dispatch, click_handler];
    }

    class Week extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$1, create_fragment$1, safe_not_equal, {
          days: 0,
          selected: 1,
          highlighted: 2,
          shouldShakeDate: 3,
          direction: 4
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Week",
          options,
          id: create_fragment$1.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*days*/
        ctx[0] === undefined && !("days" in props)) {
          console.warn("<Week> was created without expected prop 'days'");
        }

        if (
        /*selected*/
        ctx[1] === undefined && !("selected" in props)) {
          console.warn("<Week> was created without expected prop 'selected'");
        }

        if (
        /*highlighted*/
        ctx[2] === undefined && !("highlighted" in props)) {
          console.warn("<Week> was created without expected prop 'highlighted'");
        }

        if (
        /*shouldShakeDate*/
        ctx[3] === undefined && !("shouldShakeDate" in props)) {
          console.warn("<Week> was created without expected prop 'shouldShakeDate'");
        }

        if (
        /*direction*/
        ctx[4] === undefined && !("direction" in props)) {
          console.warn("<Week> was created without expected prop 'direction'");
        }
      }

      get days() {
        throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set days(value) {
        throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get selected() {
        throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set selected(value) {
        throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get highlighted() {
        throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set highlighted(value) {
        throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get shouldShakeDate() {
        throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set shouldShakeDate(value) {
        throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get direction() {
        throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set direction(value) {
        throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* node_modules\svelte-calendar\src\Components\Month.svelte generated by Svelte v3.17.1 */
    const file$2 = "node_modules\\svelte-calendar\\src\\Components\\Month.svelte";

    function get_each_context$2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[8] = list[i];
      return child_ctx;
    } // (20:2) {#each visibleMonth.weeks as week (week.id) }


    function create_each_block$2(key_1, ctx) {
      let first;
      let current;
      const week = new Week({
        props: {
          days:
          /*week*/
          ctx[8].days,
          selected:
          /*selected*/
          ctx[1],
          highlighted:
          /*highlighted*/
          ctx[2],
          shouldShakeDate:
          /*shouldShakeDate*/
          ctx[3],
          direction:
          /*direction*/
          ctx[4]
        },
        $$inline: true
      });
      week.$on("dateSelected",
      /*dateSelected_handler*/
      ctx[7]);
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          first = empty();
          create_component(week.$$.fragment);
          this.first = first;
        },
        m: function mount(target, anchor) {
          insert_dev(target, first, anchor);
          mount_component(week, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const week_changes = {};
          if (dirty &
          /*visibleMonth*/
          1) week_changes.days =
          /*week*/
          ctx[8].days;
          if (dirty &
          /*selected*/
          2) week_changes.selected =
          /*selected*/
          ctx[1];
          if (dirty &
          /*highlighted*/
          4) week_changes.highlighted =
          /*highlighted*/
          ctx[2];
          if (dirty &
          /*shouldShakeDate*/
          8) week_changes.shouldShakeDate =
          /*shouldShakeDate*/
          ctx[3];
          if (dirty &
          /*direction*/
          16) week_changes.direction =
          /*direction*/
          ctx[4];
          week.$set(week_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(week.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(week.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(first);
          destroy_component(week, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$2.name,
        type: "each",
        source: "(20:2) {#each visibleMonth.weeks as week (week.id) }",
        ctx
      });
      return block;
    }

    function create_fragment$2(ctx) {
      let div;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let current;
      let each_value =
      /*visibleMonth*/
      ctx[0].weeks;

      const get_key = ctx =>
      /*week*/
      ctx[8].id;

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$2(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
      }

      const block = {
        c: function create() {
          div = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(div, "class", "month-container svelte-1mfpuyy");
          add_location(div, file$2, 18, 0, 286);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div, null);
          }

          current = true;
        },
        p: function update(ctx, [dirty]) {
          const each_value =
          /*visibleMonth*/
          ctx[0].weeks;
          group_outros();
          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
          check_outros();
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$2.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
      let {
        id
      } = $$props;
      let {
        visibleMonth
      } = $$props;
      let {
        selected
      } = $$props;
      let {
        highlighted
      } = $$props;
      let {
        shouldShakeDate
      } = $$props;
      let lastId = id;
      let direction;
      const writable_props = ["id", "visibleMonth", "selected", "highlighted", "shouldShakeDate"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Month> was created with unknown prop '${key}'`);
      });

      function dateSelected_handler(event) {
        bubble($$self, event);
      }

      $$self.$set = $$props => {
        if ("id" in $$props) $$invalidate(5, id = $$props.id);
        if ("visibleMonth" in $$props) $$invalidate(0, visibleMonth = $$props.visibleMonth);
        if ("selected" in $$props) $$invalidate(1, selected = $$props.selected);
        if ("highlighted" in $$props) $$invalidate(2, highlighted = $$props.highlighted);
        if ("shouldShakeDate" in $$props) $$invalidate(3, shouldShakeDate = $$props.shouldShakeDate);
      };

      $$self.$capture_state = () => {
        return {
          id,
          visibleMonth,
          selected,
          highlighted,
          shouldShakeDate,
          lastId,
          direction
        };
      };

      $$self.$inject_state = $$props => {
        if ("id" in $$props) $$invalidate(5, id = $$props.id);
        if ("visibleMonth" in $$props) $$invalidate(0, visibleMonth = $$props.visibleMonth);
        if ("selected" in $$props) $$invalidate(1, selected = $$props.selected);
        if ("highlighted" in $$props) $$invalidate(2, highlighted = $$props.highlighted);
        if ("shouldShakeDate" in $$props) $$invalidate(3, shouldShakeDate = $$props.shouldShakeDate);
        if ("lastId" in $$props) $$invalidate(6, lastId = $$props.lastId);
        if ("direction" in $$props) $$invalidate(4, direction = $$props.direction);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*lastId, id*/
        96) {
           {
            $$invalidate(4, direction = lastId < id ? 1 : -1);
            $$invalidate(6, lastId = id);
          }
        }
      };

      return [visibleMonth, selected, highlighted, shouldShakeDate, direction, id, lastId, dateSelected_handler];
    }

    class Month extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$2, create_fragment$2, safe_not_equal, {
          id: 5,
          visibleMonth: 0,
          selected: 1,
          highlighted: 2,
          shouldShakeDate: 3
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Month",
          options,
          id: create_fragment$2.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*id*/
        ctx[5] === undefined && !("id" in props)) {
          console.warn("<Month> was created without expected prop 'id'");
        }

        if (
        /*visibleMonth*/
        ctx[0] === undefined && !("visibleMonth" in props)) {
          console.warn("<Month> was created without expected prop 'visibleMonth'");
        }

        if (
        /*selected*/
        ctx[1] === undefined && !("selected" in props)) {
          console.warn("<Month> was created without expected prop 'selected'");
        }

        if (
        /*highlighted*/
        ctx[2] === undefined && !("highlighted" in props)) {
          console.warn("<Month> was created without expected prop 'highlighted'");
        }

        if (
        /*shouldShakeDate*/
        ctx[3] === undefined && !("shouldShakeDate" in props)) {
          console.warn("<Month> was created without expected prop 'shouldShakeDate'");
        }
      }

      get id() {
        throw new Error("<Month>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set id(value) {
        throw new Error("<Month>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get visibleMonth() {
        throw new Error("<Month>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set visibleMonth(value) {
        throw new Error("<Month>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get selected() {
        throw new Error("<Month>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set selected(value) {
        throw new Error("<Month>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get highlighted() {
        throw new Error("<Month>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set highlighted(value) {
        throw new Error("<Month>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get shouldShakeDate() {
        throw new Error("<Month>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set shouldShakeDate(value) {
        throw new Error("<Month>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* node_modules\svelte-calendar\src\Components\NavBar.svelte generated by Svelte v3.17.1 */
    const {
      Object: Object_1
    } = globals;
    const file$3 = "node_modules\\svelte-calendar\\src\\Components\\NavBar.svelte";

    function get_each_context$3(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[15] = list[i];
      child_ctx[17] = i;
      return child_ctx;
    } // (64:4) {#each availableMonths as monthDefinition, index}


    function create_each_block$3(ctx) {
      let div;
      let span;
      let t0_value =
      /*monthDefinition*/
      ctx[15].abbrev + "";
      let t0;
      let t1;
      let dispose;

      function click_handler_2(...args) {
        return (
          /*click_handler_2*/
          ctx[14](
          /*monthDefinition*/
          ctx[15],
          /*index*/
          ctx[17], ...args)
        );
      }

      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          t0 = text(t0_value);
          t1 = space();
          attr_dev(span, "class", "svelte-1g8k11q");
          add_location(span, file$3, 70, 8, 1978);
          attr_dev(div, "class", "month-selector--month svelte-1g8k11q");
          toggle_class(div, "selected",
          /*index*/
          ctx[17] ===
          /*month*/
          ctx[0]);
          toggle_class(div, "selectable",
          /*monthDefinition*/
          ctx[15].selectable);
          add_location(div, file$3, 64, 6, 1741);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
          append_dev(span, t0);
          append_dev(div, t1);
          dispose = listen_dev(div, "click", click_handler_2, false, false, false);
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty &
          /*availableMonths*/
          64 && t0_value !== (t0_value =
          /*monthDefinition*/
          ctx[15].abbrev + "")) set_data_dev(t0, t0_value);

          if (dirty &
          /*month*/
          1) {
            toggle_class(div, "selected",
            /*index*/
            ctx[17] ===
            /*month*/
            ctx[0]);
          }

          if (dirty &
          /*availableMonths*/
          64) {
            toggle_class(div, "selectable",
            /*monthDefinition*/
            ctx[15].selectable);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$3.name,
        type: "each",
        source: "(64:4) {#each availableMonths as monthDefinition, index}",
        ctx
      });
      return block;
    }

    function create_fragment$3(ctx) {
      let div5;
      let div3;
      let div0;
      let i0;
      let t0;
      let div1;
      let t1_value =
      /*monthsOfYear*/
      ctx[4][
      /*month*/
      ctx[0]][0] + "";
      let t1;
      let t2;
      let t3;
      let t4;
      let div2;
      let i1;
      let t5;
      let div4;
      let dispose;
      let each_value =
      /*availableMonths*/
      ctx[6];
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          div5 = element("div");
          div3 = element("div");
          div0 = element("div");
          i0 = element("i");
          t0 = space();
          div1 = element("div");
          t1 = text(t1_value);
          t2 = space();
          t3 = text(
          /*year*/
          ctx[1]);
          t4 = space();
          div2 = element("div");
          i1 = element("i");
          t5 = space();
          div4 = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(i0, "class", "arrow left svelte-1g8k11q");
          add_location(i0, file$3, 51, 6, 1286);
          attr_dev(div0, "class", "control svelte-1g8k11q");
          toggle_class(div0, "enabled",
          /*canDecrementMonth*/
          ctx[3]);
          add_location(div0, file$3, 48, 4, 1160);
          attr_dev(div1, "class", "label svelte-1g8k11q");
          add_location(div1, file$3, 53, 4, 1330);
          attr_dev(i1, "class", "arrow right svelte-1g8k11q");
          add_location(i1, file$3, 59, 6, 1566);
          attr_dev(div2, "class", "control svelte-1g8k11q");
          toggle_class(div2, "enabled",
          /*canIncrementMonth*/
          ctx[2]);
          add_location(div2, file$3, 56, 4, 1442);
          attr_dev(div3, "class", "heading-section svelte-1g8k11q");
          add_location(div3, file$3, 47, 2, 1125);
          attr_dev(div4, "class", "month-selector svelte-1g8k11q");
          toggle_class(div4, "open",
          /*monthSelectorOpen*/
          ctx[5]);
          add_location(div4, file$3, 62, 2, 1619);
          attr_dev(div5, "class", "title");
          add_location(div5, file$3, 46, 0, 1102);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div5, anchor);
          append_dev(div5, div3);
          append_dev(div3, div0);
          append_dev(div0, i0);
          append_dev(div3, t0);
          append_dev(div3, div1);
          append_dev(div1, t1);
          append_dev(div1, t2);
          append_dev(div1, t3);
          append_dev(div3, t4);
          append_dev(div3, div2);
          append_dev(div2, i1);
          append_dev(div5, t5);
          append_dev(div5, div4);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div4, null);
          }

          dispose = [listen_dev(div0, "click",
          /*click_handler*/
          ctx[12], false, false, false), listen_dev(div1, "click",
          /*toggleMonthSelectorOpen*/
          ctx[8], false, false, false), listen_dev(div2, "click",
          /*click_handler_1*/
          ctx[13], false, false, false)];
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*canDecrementMonth*/
          8) {
            toggle_class(div0, "enabled",
            /*canDecrementMonth*/
            ctx[3]);
          }

          if (dirty &
          /*monthsOfYear, month*/
          17 && t1_value !== (t1_value =
          /*monthsOfYear*/
          ctx[4][
          /*month*/
          ctx[0]][0] + "")) set_data_dev(t1, t1_value);
          if (dirty &
          /*year*/
          2) set_data_dev(t3,
          /*year*/
          ctx[1]);

          if (dirty &
          /*canIncrementMonth*/
          4) {
            toggle_class(div2, "enabled",
            /*canIncrementMonth*/
            ctx[2]);
          }

          if (dirty &
          /*month, availableMonths, monthSelected*/
          577) {
            each_value =
            /*availableMonths*/
            ctx[6];
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$3(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$3(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div4, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }

          if (dirty &
          /*monthSelectorOpen*/
          32) {
            toggle_class(div4, "open",
            /*monthSelectorOpen*/
            ctx[5]);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div5);
          destroy_each(each_blocks, detaching);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$3.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
      const dispatch = createEventDispatcher();
      let {
        month
      } = $$props;
      let {
        year
      } = $$props;
      let {
        start
      } = $$props;
      let {
        end
      } = $$props;
      let {
        canIncrementMonth
      } = $$props;
      let {
        canDecrementMonth
      } = $$props;
      let {
        monthsOfYear
      } = $$props;
      let monthSelectorOpen = false;
      let availableMonths;

      function toggleMonthSelectorOpen() {
        $$invalidate(5, monthSelectorOpen = !monthSelectorOpen);
      }

      function monthSelected(event, {
        m,
        i
      }) {
        event.stopPropagation();
        if (!m.selectable) return;
        dispatch("monthSelected", i);
        toggleMonthSelectorOpen();
      }

      const writable_props = ["month", "year", "start", "end", "canIncrementMonth", "canDecrementMonth", "monthsOfYear"];
      Object_1.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NavBar> was created with unknown prop '${key}'`);
      });

      const click_handler = () => dispatch("incrementMonth", -1);

      const click_handler_1 = () => dispatch("incrementMonth", 1);

      const click_handler_2 = (monthDefinition, index, e) => monthSelected(e, {
        m: monthDefinition,
        i: index
      });

      $$self.$set = $$props => {
        if ("month" in $$props) $$invalidate(0, month = $$props.month);
        if ("year" in $$props) $$invalidate(1, year = $$props.year);
        if ("start" in $$props) $$invalidate(10, start = $$props.start);
        if ("end" in $$props) $$invalidate(11, end = $$props.end);
        if ("canIncrementMonth" in $$props) $$invalidate(2, canIncrementMonth = $$props.canIncrementMonth);
        if ("canDecrementMonth" in $$props) $$invalidate(3, canDecrementMonth = $$props.canDecrementMonth);
        if ("monthsOfYear" in $$props) $$invalidate(4, monthsOfYear = $$props.monthsOfYear);
      };

      $$self.$capture_state = () => {
        return {
          month,
          year,
          start,
          end,
          canIncrementMonth,
          canDecrementMonth,
          monthsOfYear,
          monthSelectorOpen,
          availableMonths
        };
      };

      $$self.$inject_state = $$props => {
        if ("month" in $$props) $$invalidate(0, month = $$props.month);
        if ("year" in $$props) $$invalidate(1, year = $$props.year);
        if ("start" in $$props) $$invalidate(10, start = $$props.start);
        if ("end" in $$props) $$invalidate(11, end = $$props.end);
        if ("canIncrementMonth" in $$props) $$invalidate(2, canIncrementMonth = $$props.canIncrementMonth);
        if ("canDecrementMonth" in $$props) $$invalidate(3, canDecrementMonth = $$props.canDecrementMonth);
        if ("monthsOfYear" in $$props) $$invalidate(4, monthsOfYear = $$props.monthsOfYear);
        if ("monthSelectorOpen" in $$props) $$invalidate(5, monthSelectorOpen = $$props.monthSelectorOpen);
        if ("availableMonths" in $$props) $$invalidate(6, availableMonths = $$props.availableMonths);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*start, year, end, monthsOfYear*/
        3090) {
           {
            let isOnLowerBoundary = start.getFullYear() === year;
            let isOnUpperBoundary = end.getFullYear() === year;
            $$invalidate(6, availableMonths = monthsOfYear.map((m, i) => {
              return Object.assign({}, {
                name: m[0],
                abbrev: m[1]
              }, {
                selectable: !isOnLowerBoundary && !isOnUpperBoundary || (!isOnLowerBoundary || i >= start.getMonth()) && (!isOnUpperBoundary || i <= end.getMonth())
              });
            }));
          }
        }
      };

      return [month, year, canIncrementMonth, canDecrementMonth, monthsOfYear, monthSelectorOpen, availableMonths, dispatch, toggleMonthSelectorOpen, monthSelected, start, end, click_handler, click_handler_1, click_handler_2];
    }

    class NavBar extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$3, create_fragment$3, safe_not_equal, {
          month: 0,
          year: 1,
          start: 10,
          end: 11,
          canIncrementMonth: 2,
          canDecrementMonth: 3,
          monthsOfYear: 4
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "NavBar",
          options,
          id: create_fragment$3.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*month*/
        ctx[0] === undefined && !("month" in props)) {
          console.warn("<NavBar> was created without expected prop 'month'");
        }

        if (
        /*year*/
        ctx[1] === undefined && !("year" in props)) {
          console.warn("<NavBar> was created without expected prop 'year'");
        }

        if (
        /*start*/
        ctx[10] === undefined && !("start" in props)) {
          console.warn("<NavBar> was created without expected prop 'start'");
        }

        if (
        /*end*/
        ctx[11] === undefined && !("end" in props)) {
          console.warn("<NavBar> was created without expected prop 'end'");
        }

        if (
        /*canIncrementMonth*/
        ctx[2] === undefined && !("canIncrementMonth" in props)) {
          console.warn("<NavBar> was created without expected prop 'canIncrementMonth'");
        }

        if (
        /*canDecrementMonth*/
        ctx[3] === undefined && !("canDecrementMonth" in props)) {
          console.warn("<NavBar> was created without expected prop 'canDecrementMonth'");
        }

        if (
        /*monthsOfYear*/
        ctx[4] === undefined && !("monthsOfYear" in props)) {
          console.warn("<NavBar> was created without expected prop 'monthsOfYear'");
        }
      }

      get month() {
        throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set month(value) {
        throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get year() {
        throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set year(value) {
        throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get start() {
        throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set start(value) {
        throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get end() {
        throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set end(value) {
        throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get canIncrementMonth() {
        throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set canIncrementMonth(value) {
        throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get canDecrementMonth() {
        throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set canDecrementMonth(value) {
        throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get monthsOfYear() {
        throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set monthsOfYear(value) {
        throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* node_modules\svelte-calendar\src\Components\Popover.svelte generated by Svelte v3.17.1 */
    const {
      window: window_1
    } = globals;
    const file$4 = "node_modules\\svelte-calendar\\src\\Components\\Popover.svelte";

    const get_contents_slot_changes = dirty => ({});

    const get_contents_slot_context = ctx => ({});

    const get_trigger_slot_changes = dirty => ({});

    const get_trigger_slot_context = ctx => ({});

    function create_fragment$4(ctx) {
      let div4;
      let div0;
      let t;
      let div3;
      let div2;
      let div1;
      let current;
      let dispose;
      add_render_callback(
      /*onwindowresize*/
      ctx[19]);
      const trigger_slot_template =
      /*$$slots*/
      ctx[18].trigger;
      const trigger_slot = create_slot(trigger_slot_template, ctx,
      /*$$scope*/
      ctx[17], get_trigger_slot_context);
      const contents_slot_template =
      /*$$slots*/
      ctx[18].contents;
      const contents_slot = create_slot(contents_slot_template, ctx,
      /*$$scope*/
      ctx[17], get_contents_slot_context);
      const block = {
        c: function create() {
          div4 = element("div");
          div0 = element("div");
          if (trigger_slot) trigger_slot.c();
          t = space();
          div3 = element("div");
          div2 = element("div");
          div1 = element("div");
          if (contents_slot) contents_slot.c();
          attr_dev(div0, "class", "trigger");
          add_location(div0, file$4, 103, 2, 2365);
          attr_dev(div1, "class", "contents-inner svelte-11lswj2");
          add_location(div1, file$4, 114, 6, 2763);
          attr_dev(div2, "class", "contents svelte-11lswj2");
          add_location(div2, file$4, 113, 4, 2704);
          attr_dev(div3, "class", "contents-wrapper svelte-11lswj2");
          set_style(div3, "transform", "translate(-50%,-50%) translate(" +
          /*translateX*/
          ctx[8] + "px, " +
          /*translateY*/
          ctx[7] + "px)");
          toggle_class(div3, "visible",
          /*open*/
          ctx[0]);
          toggle_class(div3, "shrink",
          /*shrink*/
          ctx[1]);
          add_location(div3, file$4, 107, 2, 2487);
          attr_dev(div4, "class", "sc-popover svelte-11lswj2");
          add_location(div4, file$4, 102, 0, 2317);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div4, anchor);
          append_dev(div4, div0);

          if (trigger_slot) {
            trigger_slot.m(div0, null);
          }
          /*div0_binding*/


          ctx[20](div0);
          append_dev(div4, t);
          append_dev(div4, div3);
          append_dev(div3, div2);
          append_dev(div2, div1);

          if (contents_slot) {
            contents_slot.m(div1, null);
          }
          /*div2_binding*/


          ctx[21](div2);
          /*div3_binding*/

          ctx[22](div3);
          /*div4_binding*/

          ctx[23](div4);
          current = true;
          dispose = [listen_dev(window_1, "resize",
          /*onwindowresize*/
          ctx[19]), listen_dev(div0, "click",
          /*doOpen*/
          ctx[9], false, false, false)];
        },
        p: function update(ctx, [dirty]) {
          if (trigger_slot && trigger_slot.p && dirty &
          /*$$scope*/
          131072) {
            trigger_slot.p(get_slot_context(trigger_slot_template, ctx,
            /*$$scope*/
            ctx[17], get_trigger_slot_context), get_slot_changes(trigger_slot_template,
            /*$$scope*/
            ctx[17], dirty, get_trigger_slot_changes));
          }

          if (contents_slot && contents_slot.p && dirty &
          /*$$scope*/
          131072) {
            contents_slot.p(get_slot_context(contents_slot_template, ctx,
            /*$$scope*/
            ctx[17], get_contents_slot_context), get_slot_changes(contents_slot_template,
            /*$$scope*/
            ctx[17], dirty, get_contents_slot_changes));
          }

          if (!current || dirty &
          /*translateX, translateY*/
          384) {
            set_style(div3, "transform", "translate(-50%,-50%) translate(" +
            /*translateX*/
            ctx[8] + "px, " +
            /*translateY*/
            ctx[7] + "px)");
          }

          if (dirty &
          /*open*/
          1) {
            toggle_class(div3, "visible",
            /*open*/
            ctx[0]);
          }

          if (dirty &
          /*shrink*/
          2) {
            toggle_class(div3, "shrink",
            /*shrink*/
            ctx[1]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(trigger_slot, local);
          transition_in(contents_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(trigger_slot, local);
          transition_out(contents_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div4);
          if (trigger_slot) trigger_slot.d(detaching);
          /*div0_binding*/

          ctx[20](null);
          if (contents_slot) contents_slot.d(detaching);
          /*div2_binding*/

          ctx[21](null);
          /*div3_binding*/

          ctx[22](null);
          /*div4_binding*/

          ctx[23](null);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$4.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
      const dispatch = createEventDispatcher();

      let once = (el, evt, cb) => {
        function handler() {
          cb.apply(this, arguments);
          el.removeEventListener(evt, handler);
        }

        el.addEventListener(evt, handler);
      };

      let popover;
      let w;
      let triggerContainer;
      let contentsAnimated;
      let contentsWrapper;
      let translateY = 0;
      let translateX = 0;
      let {
        open = false
      } = $$props;
      let {
        shrink
      } = $$props;
      let {
        trigger
      } = $$props;

      const close = () => {
        $$invalidate(1, shrink = true);
        once(contentsAnimated, "animationend", () => {
          $$invalidate(1, shrink = false);
          $$invalidate(0, open = false);
          dispatch("closed");
        });
      };

      function checkForFocusLoss(evt) {
        if (!open) return;
        let el = evt.target;

        do {
          if (el === popover) return;
        } while (el = el.parentNode);

        close();
      }

      onMount(() => {
        document.addEventListener("click", checkForFocusLoss);
        if (!trigger) return;
        triggerContainer.appendChild(trigger.parentNode.removeChild(trigger));
        return () => {
          document.removeEventListener("click", checkForFocusLoss);
        };
      });

      const getDistanceToEdges = async () => {
        if (!open) {
          $$invalidate(0, open = true);
        }

        await tick();
        let rect = contentsWrapper.getBoundingClientRect();
        return {
          top: rect.top + -1 * translateY,
          bottom: window.innerHeight - rect.bottom + translateY,
          left: rect.left + -1 * translateX,
          right: document.body.clientWidth - rect.right + translateX
        };
      };

      const getTranslate = async () => {
        let dist = await getDistanceToEdges();
        let x;
        let y;

        if (w < 480) {
          y = dist.bottom;
        } else if (dist.top < 0) {
          y = Math.abs(dist.top);
        } else if (dist.bottom < 0) {
          y = dist.bottom;
        } else {
          y = 0;
        }

        if (dist.left < 0) {
          x = Math.abs(dist.left);
        } else if (dist.right < 0) {
          x = dist.right;
        } else {
          x = 0;
        }

        return {
          x,
          y
        };
      };

      const doOpen = async () => {
        const {
          x,
          y
        } = await getTranslate();
        $$invalidate(8, translateX = x);
        $$invalidate(7, translateY = y);
        $$invalidate(0, open = true);
        dispatch("opened");
      };

      const writable_props = ["open", "shrink", "trigger"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Popover> was created with unknown prop '${key}'`);
      });
      let {
        $$slots = {},
        $$scope
      } = $$props;

      function onwindowresize() {
        $$invalidate(3, w = window_1.innerWidth);
      }

      function div0_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(4, triggerContainer = $$value);
        });
      }

      function div2_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(5, contentsAnimated = $$value);
        });
      }

      function div3_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(6, contentsWrapper = $$value);
        });
      }

      function div4_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(2, popover = $$value);
        });
      }

      $$self.$set = $$props => {
        if ("open" in $$props) $$invalidate(0, open = $$props.open);
        if ("shrink" in $$props) $$invalidate(1, shrink = $$props.shrink);
        if ("trigger" in $$props) $$invalidate(10, trigger = $$props.trigger);
        if ("$$scope" in $$props) $$invalidate(17, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => {
        return {
          once,
          popover,
          w,
          triggerContainer,
          contentsAnimated,
          contentsWrapper,
          translateY,
          translateX,
          open,
          shrink,
          trigger
        };
      };

      $$self.$inject_state = $$props => {
        if ("once" in $$props) once = $$props.once;
        if ("popover" in $$props) $$invalidate(2, popover = $$props.popover);
        if ("w" in $$props) $$invalidate(3, w = $$props.w);
        if ("triggerContainer" in $$props) $$invalidate(4, triggerContainer = $$props.triggerContainer);
        if ("contentsAnimated" in $$props) $$invalidate(5, contentsAnimated = $$props.contentsAnimated);
        if ("contentsWrapper" in $$props) $$invalidate(6, contentsWrapper = $$props.contentsWrapper);
        if ("translateY" in $$props) $$invalidate(7, translateY = $$props.translateY);
        if ("translateX" in $$props) $$invalidate(8, translateX = $$props.translateX);
        if ("open" in $$props) $$invalidate(0, open = $$props.open);
        if ("shrink" in $$props) $$invalidate(1, shrink = $$props.shrink);
        if ("trigger" in $$props) $$invalidate(10, trigger = $$props.trigger);
      };

      return [open, shrink, popover, w, triggerContainer, contentsAnimated, contentsWrapper, translateY, translateX, doOpen, trigger, close, dispatch, once, checkForFocusLoss, getDistanceToEdges, getTranslate, $$scope, $$slots, onwindowresize, div0_binding, div2_binding, div3_binding, div4_binding];
    }

    class Popover extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$4, create_fragment$4, safe_not_equal, {
          open: 0,
          shrink: 1,
          trigger: 10,
          close: 11
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Popover",
          options,
          id: create_fragment$4.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*shrink*/
        ctx[1] === undefined && !("shrink" in props)) {
          console.warn("<Popover> was created without expected prop 'shrink'");
        }

        if (
        /*trigger*/
        ctx[10] === undefined && !("trigger" in props)) {
          console.warn("<Popover> was created without expected prop 'trigger'");
        }
      }

      get open() {
        throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set open(value) {
        throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get shrink() {
        throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set shrink(value) {
        throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get trigger() {
        throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set trigger(value) {
        throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get close() {
        return this.$$.ctx[11];
      }

      set close(value) {
        throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /**
     * generic function to inject data into token-laden string
     * @param str {String} Required
     * @param name {String} Required
     * @param value {String|Integer} Required
     * @returns {String}
     *
     * @example
     * injectStringData("The following is a token: #{tokenName}", "tokenName", 123); 
     * @returns {String} "The following is a token: 123"
     *
     */
    const injectStringData = (str, name, value) => str.replace(new RegExp('#{' + name + '}', 'g'), value);
    /**
     * Generic function to enforce length of string. 
     * 
     * Pass a string or number to this function and specify the desired length.
     * This function will either pad the # with leading 0's (if str.length < length)
     * or remove data from the end (@fromBack==false) or beginning (@fromBack==true)
     * of the string when str.length > length.
     *
     * When length == str.length or typeof length == 'undefined', this function
     * returns the original @str parameter.
     * 
     * @param str {String} Required
     * @param length {Integer} Required
     * @param fromBack {Boolean} Optional
     * @returns {String}
     *
     */


    const enforceLength = function (str, length, fromBack) {
      str = str.toString();
      if (typeof length == 'undefined') return str;
      if (str.length == length) return str;
      fromBack = typeof fromBack == 'undefined' ? false : fromBack;

      if (str.length < length) {
        // pad the beginning of the string w/ enough 0's to reach desired length:
        while (length - str.length > 0) str = '0' + str;
      } else if (str.length > length) {
        if (fromBack) {
          // grab the desired #/chars from end of string: ex: '2015' -> '15'
          str = str.substring(str.length - length);
        } else {
          // grab the desired #/chars from beginning of string: ex: '2015' -> '20'
          str = str.substring(0, length);
        }
      }

      return str;
    };

    const daysOfWeek = [['Sunday', 'Sun'], ['Monday', 'Mon'], ['Tuesday', 'Tue'], ['Wednesday', 'Wed'], ['Thursday', 'Thu'], ['Friday', 'Fri'], ['Saturday', 'Sat']];
    const monthsOfYear = [['January', 'Jan'], ['February', 'Feb'], ['March', 'Mar'], ['April', 'Apr'], ['May', 'May'], ['June', 'Jun'], ['July', 'Jul'], ['August', 'Aug'], ['September', 'Sep'], ['October', 'Oct'], ['November', 'Nov'], ['December', 'Dec']];
    let dictionary = {
      daysOfWeek,
      monthsOfYear
    };

    const extendDictionary = conf => Object.keys(conf).forEach(key => {
      if (dictionary[key] && dictionary[key].length == conf[key].length) {
        dictionary[key] = conf[key];
      }
    });

    var acceptedDateTokens = [{
      // d: day of the month, 2 digits with leading zeros:
      key: 'd',
      method: function (date) {
        return enforceLength(date.getDate(), 2);
      }
    }, {
      // D: textual representation of day, 3 letters: Sun thru Sat
      key: 'D',
      method: function (date) {
        return dictionary.daysOfWeek[date.getDay()][1];
      }
    }, {
      // j: day of month without leading 0's
      key: 'j',
      method: function (date) {
        return date.getDate();
      }
    }, {
      // l: full textual representation of day of week: Sunday thru Saturday
      key: 'l',
      method: function (date) {
        return dictionary.daysOfWeek[date.getDay()][0];
      }
    }, {
      // F: full text month: 'January' thru 'December'
      key: 'F',
      method: function (date) {
        return dictionary.monthsOfYear[date.getMonth()][0];
      }
    }, {
      // m: 2 digit numeric month: '01' - '12':
      key: 'm',
      method: function (date) {
        return enforceLength(date.getMonth() + 1, 2);
      }
    }, {
      // M: a short textual representation of the month, 3 letters: 'Jan' - 'Dec'
      key: 'M',
      method: function (date) {
        return dictionary.monthsOfYear[date.getMonth()][1];
      }
    }, {
      // n: numeric represetation of month w/o leading 0's, '1' - '12':
      key: 'n',
      method: function (date) {
        return date.getMonth() + 1;
      }
    }, {
      // Y: Full numeric year, 4 digits
      key: 'Y',
      method: function (date) {
        return date.getFullYear();
      }
    }, {
      // y: 2 digit numeric year:
      key: 'y',
      method: function (date) {
        return enforceLength(date.getFullYear(), 2, true);
      }
    }];
    var acceptedTimeTokens = [{
      // a: lowercase ante meridiem and post meridiem 'am' or 'pm'
      key: 'a',
      method: function (date) {
        return date.getHours() > 11 ? 'pm' : 'am';
      }
    }, {
      // A: uppercase ante merdiiem and post meridiem 'AM' or 'PM'
      key: 'A',
      method: function (date) {
        return date.getHours() > 11 ? 'PM' : 'AM';
      }
    }, {
      // g: 12-hour format of an hour without leading zeros 1-12
      key: 'g',
      method: function (date) {
        return date.getHours() % 12 || 12;
      }
    }, {
      // G: 24-hour format of an hour without leading zeros 0-23
      key: 'G',
      method: function (date) {
        return date.getHours();
      }
    }, {
      // h: 12-hour format of an hour with leading zeros 01-12
      key: 'h',
      method: function (date) {
        return enforceLength(date.getHours() % 12 || 12, 2);
      }
    }, {
      // H: 24-hour format of an hour with leading zeros: 00-23
      key: 'H',
      method: function (date) {
        return enforceLength(date.getHours(), 2);
      }
    }, {
      // i: Minutes with leading zeros 00-59
      key: 'i',
      method: function (date) {
        return enforceLength(date.getMinutes(), 2);
      }
    }, {
      // s: Seconds with leading zeros 00-59
      key: 's',
      method: function (date) {
        return enforceLength(date.getSeconds(), 2);
      }
    }];
    /**
     * Internationalization object for timeUtils.internationalize().
     * @typedef internationalizeObj
     * @property {Array} [daysOfWeek=[ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ]] daysOfWeek Weekday labels as strings, starting with Sunday.
     * @property {Array} [monthsOfYear=[ 'January','February','March','April','May','June','July','August','September','October','November','December' ]] monthsOfYear Month labels as strings, starting with January.
     */

    /**
     * This function can be used to support additional languages by passing an object with 
     * `daysOfWeek` and `monthsOfYear` attributes.  Each attribute should be an array of
     * strings (ex: `daysOfWeek: ['monday', 'tuesday', 'wednesday'...]`)
     *
     * @param {internationalizeObj} conf
     */

    const internationalize = (conf = {}) => {
      extendDictionary(conf);
    };
    /**
     * generic formatDate function which accepts dynamic templates
     * @param date {Date} Required
     * @param template {String} Optional
     * @returns {String}
     *
     * @example
     * formatDate(new Date(), '#{M}. #{j}, #{Y}')
     * @returns {Number} Returns a formatted date
     *
     */


    const formatDate = (date, template = '#{m}/#{d}/#{Y}') => {
      acceptedDateTokens.forEach(token => {
        if (template.indexOf(`#{${token.key}}`) == -1) return;
        template = injectStringData(template, token.key, token.method(date));
      });
      acceptedTimeTokens.forEach(token => {
        if (template.indexOf(`#{${token.key}}`) == -1) return;
        template = injectStringData(template, token.key, token.method(date));
      });
      return template;
    };

    const keyCodes = {
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      pgup: 33,
      pgdown: 34,
      enter: 13,
      escape: 27,
      tab: 9
    };
    const keyCodesArray = Object.keys(keyCodes).map(k => keyCodes[k]);

    /* node_modules\svelte-calendar\src\Components\Datepicker.svelte generated by Svelte v3.17.1 */
    const file$5 = "node_modules\\svelte-calendar\\src\\Components\\Datepicker.svelte";

    function get_each_context$4(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[62] = list[i];
      return child_ctx;
    } // (272:8) {#if !trigger}


    function create_if_block$1(ctx) {
      let button;
      let t;
      const block = {
        c: function create() {
          button = element("button");
          t = text(
          /*formattedSelected*/
          ctx[2]);
          attr_dev(button, "class", "calendar-button svelte-a2avkl");
          attr_dev(button, "type", "button");
          add_location(button, file$5, 272, 8, 7543);
        },
        m: function mount(target, anchor) {
          insert_dev(target, button, anchor);
          append_dev(button, t);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*formattedSelected*/
          4) set_data_dev(t,
          /*formattedSelected*/
          ctx[2]);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$1.name,
        type: "if",
        source: "(272:8) {#if !trigger}",
        ctx
      });
      return block;
    } // (270:4) <div slot="trigger">


    function create_trigger_slot(ctx) {
      let div;
      let current;
      const default_slot_template =
      /*$$slots*/
      ctx[54].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[61], null);
      let if_block = !
      /*trigger*/
      ctx[1] && create_if_block$1(ctx);
      const block = {
        c: function create() {
          div = element("div");

          if (!default_slot) {
            if (if_block) if_block.c();
          }

          if (default_slot) default_slot.c();
          attr_dev(div, "slot", "trigger");
          attr_dev(div, "class", "svelte-a2avkl");
          add_location(div, file$5, 269, 4, 7478);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          if (!default_slot) {
            if (if_block) if_block.m(div, null);
          }

          if (default_slot) {
            default_slot.m(div, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (!default_slot) {
            if (!
            /*trigger*/
            ctx[1]) {
              if (if_block) {
                if_block.p(ctx, dirty);
              } else {
                if_block = create_if_block$1(ctx);
                if_block.c();
                if_block.m(div, null);
              }
            } else if (if_block) {
              if_block.d(1);
              if_block = null;
            }
          }

          if (default_slot && default_slot.p && dirty[1] &
          /*$$scope*/
          1073741824) {
            default_slot.p(get_slot_context(default_slot_template, ctx,
            /*$$scope*/
            ctx[61], null), get_slot_changes(default_slot_template,
            /*$$scope*/
            ctx[61], dirty, null));
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);

          if (!default_slot) {
            if (if_block) if_block.d();
          }

          if (default_slot) default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_trigger_slot.name,
        type: "slot",
        source: "(270:4) <div slot=\\\"trigger\\\">",
        ctx
      });
      return block;
    } // (293:10) {#each sortedDaysOfWeek as day}


    function create_each_block$4(ctx) {
      let span;
      let t_value =
      /*day*/
      ctx[62][1] + "";
      let t;
      const block = {
        c: function create() {
          span = element("span");
          t = text(t_value);
          attr_dev(span, "class", "svelte-a2avkl");
          add_location(span, file$5, 293, 10, 8112);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$4.name,
        type: "each",
        source: "(293:10) {#each sortedDaysOfWeek as day}",
        ctx
      });
      return block;
    } // (279:4) <div slot="contents">


    function create_contents_slot(ctx) {
      let div0;
      let div2;
      let t0;
      let div1;
      let t1;
      let current;
      const navbar = new NavBar({
        props: {
          month:
          /*month*/
          ctx[9],
          year:
          /*year*/
          ctx[10],
          canIncrementMonth:
          /*canIncrementMonth*/
          ctx[15],
          canDecrementMonth:
          /*canDecrementMonth*/
          ctx[16],
          start:
          /*start*/
          ctx[3],
          end:
          /*end*/
          ctx[4],
          monthsOfYear:
          /*monthsOfYear*/
          ctx[5]
        },
        $$inline: true
      });
      navbar.$on("monthSelected",
      /*monthSelected_handler*/
      ctx[55]);
      navbar.$on("incrementMonth",
      /*incrementMonth_handler*/
      ctx[56]);
      let each_value =
      /*sortedDaysOfWeek*/
      ctx[18];
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
      }

      const month_1 = new Month({
        props: {
          visibleMonth:
          /*visibleMonth*/
          ctx[13],
          selected:
          /*selected*/
          ctx[0],
          highlighted:
          /*highlighted*/
          ctx[7],
          shouldShakeDate:
          /*shouldShakeDate*/
          ctx[8],
          id:
          /*visibleMonthId*/
          ctx[14]
        },
        $$inline: true
      });
      month_1.$on("dateSelected",
      /*dateSelected_handler*/
      ctx[57]);
      const block = {
        c: function create() {
          div0 = element("div");
          div2 = element("div");
          create_component(navbar.$$.fragment);
          t0 = space();
          div1 = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t1 = space();
          create_component(month_1.$$.fragment);
          attr_dev(div1, "class", "legend svelte-a2avkl");
          add_location(div1, file$5, 291, 8, 8039);
          attr_dev(div2, "class", "calendar svelte-a2avkl");
          add_location(div2, file$5, 279, 6, 7709);
          attr_dev(div0, "slot", "contents");
          attr_dev(div0, "class", "svelte-a2avkl");
          add_location(div0, file$5, 278, 4, 7681);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div0, anchor);
          append_dev(div0, div2);
          mount_component(navbar, div2, null);
          append_dev(div2, t0);
          append_dev(div2, div1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div1, null);
          }

          append_dev(div2, t1);
          mount_component(month_1, div2, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const navbar_changes = {};
          if (dirty[0] &
          /*month*/
          512) navbar_changes.month =
          /*month*/
          ctx[9];
          if (dirty[0] &
          /*year*/
          1024) navbar_changes.year =
          /*year*/
          ctx[10];
          if (dirty[0] &
          /*canIncrementMonth*/
          32768) navbar_changes.canIncrementMonth =
          /*canIncrementMonth*/
          ctx[15];
          if (dirty[0] &
          /*canDecrementMonth*/
          65536) navbar_changes.canDecrementMonth =
          /*canDecrementMonth*/
          ctx[16];
          if (dirty[0] &
          /*start*/
          8) navbar_changes.start =
          /*start*/
          ctx[3];
          if (dirty[0] &
          /*end*/
          16) navbar_changes.end =
          /*end*/
          ctx[4];
          if (dirty[0] &
          /*monthsOfYear*/
          32) navbar_changes.monthsOfYear =
          /*monthsOfYear*/
          ctx[5];
          navbar.$set(navbar_changes);

          if (dirty[0] &
          /*sortedDaysOfWeek*/
          262144) {
            each_value =
            /*sortedDaysOfWeek*/
            ctx[18];
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$4(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$4(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div1, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }

          const month_1_changes = {};
          if (dirty[0] &
          /*visibleMonth*/
          8192) month_1_changes.visibleMonth =
          /*visibleMonth*/
          ctx[13];
          if (dirty[0] &
          /*selected*/
          1) month_1_changes.selected =
          /*selected*/
          ctx[0];
          if (dirty[0] &
          /*highlighted*/
          128) month_1_changes.highlighted =
          /*highlighted*/
          ctx[7];
          if (dirty[0] &
          /*shouldShakeDate*/
          256) month_1_changes.shouldShakeDate =
          /*shouldShakeDate*/
          ctx[8];
          if (dirty[0] &
          /*visibleMonthId*/
          16384) month_1_changes.id =
          /*visibleMonthId*/
          ctx[14];
          month_1.$set(month_1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(navbar.$$.fragment, local);
          transition_in(month_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(navbar.$$.fragment, local);
          transition_out(month_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div0);
          destroy_component(navbar);
          destroy_each(each_blocks, detaching);
          destroy_component(month_1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_contents_slot.name,
        type: "slot",
        source: "(279:4) <div slot=\\\"contents\\\">",
        ctx
      });
      return block;
    } // (262:2) <Popover     bind:this="{popover}"     bind:open="{isOpen}"     bind:shrink="{isClosing}"     {trigger}     on:opened="{registerOpen}"     on:closed="{registerClose}"   >


    function create_default_slot(ctx) {
      let t;
      const block = {
        c: function create() {
          t = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot.name,
        type: "slot",
        source: "(262:2) <Popover     bind:this=\\\"{popover}\\\"     bind:open=\\\"{isOpen}\\\"     bind:shrink=\\\"{isClosing}\\\"     {trigger}     on:opened=\\\"{registerOpen}\\\"     on:closed=\\\"{registerClose}\\\"   >",
        ctx
      });
      return block;
    }

    function create_fragment$5(ctx) {
      let div;
      let updating_open;
      let updating_shrink;
      let current;

      function popover_1_open_binding(value) {
        /*popover_1_open_binding*/
        ctx[59].call(null, value);
      }

      function popover_1_shrink_binding(value_1) {
        /*popover_1_shrink_binding*/
        ctx[60].call(null, value_1);
      }

      let popover_1_props = {
        trigger:
        /*trigger*/
        ctx[1],
        $$slots: {
          default: [create_default_slot],
          contents: [create_contents_slot],
          trigger: [create_trigger_slot]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*isOpen*/
      ctx[11] !== void 0) {
        popover_1_props.open =
        /*isOpen*/
        ctx[11];
      }

      if (
      /*isClosing*/
      ctx[12] !== void 0) {
        popover_1_props.shrink =
        /*isClosing*/
        ctx[12];
      }

      const popover_1 = new Popover({
        props: popover_1_props,
        $$inline: true
      });
      /*popover_1_binding*/

      ctx[58](popover_1);
      binding_callbacks.push(() => bind(popover_1, "open", popover_1_open_binding));
      binding_callbacks.push(() => bind(popover_1, "shrink", popover_1_shrink_binding));
      popover_1.$on("opened",
      /*registerOpen*/
      ctx[23]);
      popover_1.$on("closed",
      /*registerClose*/
      ctx[22]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(popover_1.$$.fragment);
          attr_dev(div, "class", "datepicker svelte-a2avkl");
          attr_dev(div, "style",
          /*wrapperStyle*/
          ctx[17]);
          toggle_class(div, "open",
          /*isOpen*/
          ctx[11]);
          toggle_class(div, "closing",
          /*isClosing*/
          ctx[12]);
          add_location(div, file$5, 255, 0, 7193);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(popover_1, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const popover_1_changes = {};
          if (dirty[0] &
          /*trigger*/
          2) popover_1_changes.trigger =
          /*trigger*/
          ctx[1];

          if (dirty[0] &
          /*visibleMonth, selected, highlighted, shouldShakeDate, visibleMonthId, month, year, canIncrementMonth, canDecrementMonth, start, end, monthsOfYear, trigger, formattedSelected*/
          124863 | dirty[1] &
          /*$$scope*/
          1073741824) {
            popover_1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_open && dirty[0] &
          /*isOpen*/
          2048) {
            updating_open = true;
            popover_1_changes.open =
            /*isOpen*/
            ctx[11];
            add_flush_callback(() => updating_open = false);
          }

          if (!updating_shrink && dirty[0] &
          /*isClosing*/
          4096) {
            updating_shrink = true;
            popover_1_changes.shrink =
            /*isClosing*/
            ctx[12];
            add_flush_callback(() => updating_shrink = false);
          }

          popover_1.$set(popover_1_changes);

          if (!current || dirty[0] &
          /*wrapperStyle*/
          131072) {
            attr_dev(div, "style",
            /*wrapperStyle*/
            ctx[17]);
          }

          if (dirty[0] &
          /*isOpen*/
          2048) {
            toggle_class(div, "open",
            /*isOpen*/
            ctx[11]);
          }

          if (dirty[0] &
          /*isClosing*/
          4096) {
            toggle_class(div, "closing",
            /*isClosing*/
            ctx[12]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(popover_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(popover_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          /*popover_1_binding*/

          ctx[58](null);
          destroy_component(popover_1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$5.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
      const dispatch = createEventDispatcher();
      const today = new Date();
      let popover;
      let {
        format = "#{m}/#{d}/#{Y}"
      } = $$props;
      let {
        start = new Date(1987, 9, 29)
      } = $$props;
      let {
        end = new Date(2020, 9, 29)
      } = $$props;
      let {
        selected = today
      } = $$props;
      let {
        dateChosen = false
      } = $$props;
      let {
        trigger = null
      } = $$props;
      let {
        selectableCallback = null
      } = $$props;
      let {
        weekStart = 0
      } = $$props;
      let {
        daysOfWeek = [["Sunday", "Sun"], ["Monday", "Mon"], ["Tuesday", "Tue"], ["Wednesday", "Wed"], ["Thursday", "Thu"], ["Friday", "Fri"], ["Saturday", "Sat"]]
      } = $$props;
      let {
        monthsOfYear = [["January", "Jan"], ["February", "Feb"], ["March", "Mar"], ["April", "Apr"], ["May", "May"], ["June", "Jun"], ["July", "Jul"], ["August", "Aug"], ["September", "Sep"], ["October", "Oct"], ["November", "Nov"], ["December", "Dec"]]
      } = $$props;
      let {
        style = ""
      } = $$props;
      let {
        buttonBackgroundColor = "#fff"
      } = $$props;
      let {
        buttonBorderColor = "#eee"
      } = $$props;
      let {
        buttonTextColor = "#333"
      } = $$props;
      let {
        highlightColor = "#f7901e"
      } = $$props;
      let {
        dayBackgroundColor = "none"
      } = $$props;
      let {
        dayTextColor = "#4a4a4a"
      } = $$props;
      let {
        dayHighlightedBackgroundColor = "#efefef"
      } = $$props;
      let {
        dayHighlightedTextColor = "#4a4a4a"
      } = $$props;
      internationalize({
        daysOfWeek,
        monthsOfYear
      });
      let sortedDaysOfWeek = weekStart === 0 ? daysOfWeek : (() => {
        let dow = daysOfWeek.slice();
        dow.push(dow.shift());
        return dow;
      })();
      let highlighted = today;
      let shouldShakeDate = false;
      let shakeHighlightTimeout;
      let month = today.getMonth();
      let year = today.getFullYear();
      let isOpen = false;
      let isClosing = false;
      today.setHours(0, 0, 0, 0);

      function assignmentHandler(formatted) {
        if (!trigger) return;
        $$invalidate(1, trigger.innerHTML = formatted, trigger);
      }

      let monthIndex = 0;
      let {
        formattedSelected
      } = $$props;
      onMount(() => {
        $$invalidate(9, month = selected.getMonth());
        $$invalidate(10, year = selected.getFullYear());
      });

      function changeMonth(selectedMonth) {
        $$invalidate(9, month = selectedMonth);
        $$invalidate(7, highlighted = new Date(year, month, 1));
      }

      function incrementMonth(direction, day = 1) {
        if (direction === 1 && !canIncrementMonth) return;
        if (direction === -1 && !canDecrementMonth) return;
        let current = new Date(year, month, 1);
        current.setMonth(current.getMonth() + direction);
        $$invalidate(9, month = current.getMonth());
        $$invalidate(10, year = current.getFullYear());
        $$invalidate(7, highlighted = new Date(year, month, day));
      }

      function getDefaultHighlighted() {
        return new Date(selected);
      }

      const getDay = (m, d, y) => {
        let theMonth = months.find(aMonth => aMonth.month === m && aMonth.year === y);
        if (!theMonth) return null;

        for (let i = 0; i < theMonth.weeks.length; ++i) {
          for (let j = 0; j < theMonth.weeks[i].days.length; ++j) {
            let aDay = theMonth.weeks[i].days[j];
            if (aDay.month === m && aDay.day === d && aDay.year === y) return aDay;
          }
        }

        return null;
      };

      function incrementDayHighlighted(amount) {
        let proposedDate = new Date(highlighted);
        proposedDate.setDate(highlighted.getDate() + amount);
        let correspondingDayObj = getDay(proposedDate.getMonth(), proposedDate.getDate(), proposedDate.getFullYear());
        if (!correspondingDayObj || !correspondingDayObj.isInRange) return;
        $$invalidate(7, highlighted = proposedDate);

        if (amount > 0 && highlighted > lastVisibleDate) {
          incrementMonth(1, highlighted.getDate());
        }

        if (amount < 0 && highlighted < firstVisibleDate) {
          incrementMonth(-1, highlighted.getDate());
        }
      }

      function checkIfVisibleDateIsSelectable(date) {
        const proposedDay = getDay(date.getMonth(), date.getDate(), date.getFullYear());
        return proposedDay && proposedDay.selectable;
      }

      function shakeDate(date) {
        clearTimeout(shakeHighlightTimeout);
        $$invalidate(8, shouldShakeDate = date);
        shakeHighlightTimeout = setTimeout(() => {
          $$invalidate(8, shouldShakeDate = false);
        }, 700);
      }

      function assignValueToTrigger(formatted) {
        assignmentHandler(formatted);
      }

      function registerSelection(chosen) {
        if (!checkIfVisibleDateIsSelectable(chosen)) return shakeDate(chosen);
        close();
        $$invalidate(0, selected = chosen);
        $$invalidate(24, dateChosen = true);
        assignValueToTrigger(formattedSelected);
        return dispatch("dateSelected", {
          date: chosen
        });
      }

      function handleKeyPress(evt) {
        if (keyCodesArray.indexOf(evt.keyCode) === -1) return;
        evt.preventDefault();

        switch (evt.keyCode) {
          case keyCodes.left:
            incrementDayHighlighted(-1);
            break;

          case keyCodes.up:
            incrementDayHighlighted(-7);
            break;

          case keyCodes.right:
            incrementDayHighlighted(1);
            break;

          case keyCodes.down:
            incrementDayHighlighted(7);
            break;

          case keyCodes.pgup:
            incrementMonth(-1);
            break;

          case keyCodes.pgdown:
            incrementMonth(1);
            break;

          case keyCodes.escape:
            close();
            break;

          case keyCodes.enter:
            registerSelection(highlighted);
            break;
        }
      }

      function registerClose() {
        document.removeEventListener("keydown", handleKeyPress);
        dispatch("close");
      }

      function close() {
        popover.close();
        registerClose();
      }

      function registerOpen() {
        $$invalidate(7, highlighted = getDefaultHighlighted());
        $$invalidate(9, month = selected.getMonth());
        $$invalidate(10, year = selected.getFullYear());
        document.addEventListener("keydown", handleKeyPress);
        dispatch("open");
      }

      const writable_props = ["format", "start", "end", "selected", "dateChosen", "trigger", "selectableCallback", "weekStart", "daysOfWeek", "monthsOfYear", "style", "buttonBackgroundColor", "buttonBorderColor", "buttonTextColor", "highlightColor", "dayBackgroundColor", "dayTextColor", "dayHighlightedBackgroundColor", "dayHighlightedTextColor", "formattedSelected"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Datepicker> was created with unknown prop '${key}'`);
      });
      let {
        $$slots = {},
        $$scope
      } = $$props;

      const monthSelected_handler = e => changeMonth(e.detail);

      const incrementMonth_handler = e => incrementMonth(e.detail);

      const dateSelected_handler = e => registerSelection(e.detail);

      function popover_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(6, popover = $$value);
        });
      }

      function popover_1_open_binding(value) {
        isOpen = value;
        $$invalidate(11, isOpen);
      }

      function popover_1_shrink_binding(value_1) {
        isClosing = value_1;
        $$invalidate(12, isClosing);
      }

      $$self.$set = $$props => {
        if ("format" in $$props) $$invalidate(25, format = $$props.format);
        if ("start" in $$props) $$invalidate(3, start = $$props.start);
        if ("end" in $$props) $$invalidate(4, end = $$props.end);
        if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
        if ("dateChosen" in $$props) $$invalidate(24, dateChosen = $$props.dateChosen);
        if ("trigger" in $$props) $$invalidate(1, trigger = $$props.trigger);
        if ("selectableCallback" in $$props) $$invalidate(26, selectableCallback = $$props.selectableCallback);
        if ("weekStart" in $$props) $$invalidate(27, weekStart = $$props.weekStart);
        if ("daysOfWeek" in $$props) $$invalidate(28, daysOfWeek = $$props.daysOfWeek);
        if ("monthsOfYear" in $$props) $$invalidate(5, monthsOfYear = $$props.monthsOfYear);
        if ("style" in $$props) $$invalidate(29, style = $$props.style);
        if ("buttonBackgroundColor" in $$props) $$invalidate(30, buttonBackgroundColor = $$props.buttonBackgroundColor);
        if ("buttonBorderColor" in $$props) $$invalidate(31, buttonBorderColor = $$props.buttonBorderColor);
        if ("buttonTextColor" in $$props) $$invalidate(32, buttonTextColor = $$props.buttonTextColor);
        if ("highlightColor" in $$props) $$invalidate(33, highlightColor = $$props.highlightColor);
        if ("dayBackgroundColor" in $$props) $$invalidate(34, dayBackgroundColor = $$props.dayBackgroundColor);
        if ("dayTextColor" in $$props) $$invalidate(35, dayTextColor = $$props.dayTextColor);
        if ("dayHighlightedBackgroundColor" in $$props) $$invalidate(36, dayHighlightedBackgroundColor = $$props.dayHighlightedBackgroundColor);
        if ("dayHighlightedTextColor" in $$props) $$invalidate(37, dayHighlightedTextColor = $$props.dayHighlightedTextColor);
        if ("formattedSelected" in $$props) $$invalidate(2, formattedSelected = $$props.formattedSelected);
        if ("$$scope" in $$props) $$invalidate(61, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => {
        return {
          popover,
          format,
          start,
          end,
          selected,
          dateChosen,
          trigger,
          selectableCallback,
          weekStart,
          daysOfWeek,
          monthsOfYear,
          style,
          buttonBackgroundColor,
          buttonBorderColor,
          buttonTextColor,
          highlightColor,
          dayBackgroundColor,
          dayTextColor,
          dayHighlightedBackgroundColor,
          dayHighlightedTextColor,
          sortedDaysOfWeek,
          highlighted,
          shouldShakeDate,
          shakeHighlightTimeout,
          month,
          year,
          isOpen,
          isClosing,
          monthIndex,
          formattedSelected,
          months,
          visibleMonth,
          visibleMonthId,
          lastVisibleDate,
          firstVisibleDate,
          canIncrementMonth,
          canDecrementMonth,
          wrapperStyle
        };
      };

      $$self.$inject_state = $$props => {
        if ("popover" in $$props) $$invalidate(6, popover = $$props.popover);
        if ("format" in $$props) $$invalidate(25, format = $$props.format);
        if ("start" in $$props) $$invalidate(3, start = $$props.start);
        if ("end" in $$props) $$invalidate(4, end = $$props.end);
        if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
        if ("dateChosen" in $$props) $$invalidate(24, dateChosen = $$props.dateChosen);
        if ("trigger" in $$props) $$invalidate(1, trigger = $$props.trigger);
        if ("selectableCallback" in $$props) $$invalidate(26, selectableCallback = $$props.selectableCallback);
        if ("weekStart" in $$props) $$invalidate(27, weekStart = $$props.weekStart);
        if ("daysOfWeek" in $$props) $$invalidate(28, daysOfWeek = $$props.daysOfWeek);
        if ("monthsOfYear" in $$props) $$invalidate(5, monthsOfYear = $$props.monthsOfYear);
        if ("style" in $$props) $$invalidate(29, style = $$props.style);
        if ("buttonBackgroundColor" in $$props) $$invalidate(30, buttonBackgroundColor = $$props.buttonBackgroundColor);
        if ("buttonBorderColor" in $$props) $$invalidate(31, buttonBorderColor = $$props.buttonBorderColor);
        if ("buttonTextColor" in $$props) $$invalidate(32, buttonTextColor = $$props.buttonTextColor);
        if ("highlightColor" in $$props) $$invalidate(33, highlightColor = $$props.highlightColor);
        if ("dayBackgroundColor" in $$props) $$invalidate(34, dayBackgroundColor = $$props.dayBackgroundColor);
        if ("dayTextColor" in $$props) $$invalidate(35, dayTextColor = $$props.dayTextColor);
        if ("dayHighlightedBackgroundColor" in $$props) $$invalidate(36, dayHighlightedBackgroundColor = $$props.dayHighlightedBackgroundColor);
        if ("dayHighlightedTextColor" in $$props) $$invalidate(37, dayHighlightedTextColor = $$props.dayHighlightedTextColor);
        if ("sortedDaysOfWeek" in $$props) $$invalidate(18, sortedDaysOfWeek = $$props.sortedDaysOfWeek);
        if ("highlighted" in $$props) $$invalidate(7, highlighted = $$props.highlighted);
        if ("shouldShakeDate" in $$props) $$invalidate(8, shouldShakeDate = $$props.shouldShakeDate);
        if ("shakeHighlightTimeout" in $$props) shakeHighlightTimeout = $$props.shakeHighlightTimeout;
        if ("month" in $$props) $$invalidate(9, month = $$props.month);
        if ("year" in $$props) $$invalidate(10, year = $$props.year);
        if ("isOpen" in $$props) $$invalidate(11, isOpen = $$props.isOpen);
        if ("isClosing" in $$props) $$invalidate(12, isClosing = $$props.isClosing);
        if ("monthIndex" in $$props) $$invalidate(39, monthIndex = $$props.monthIndex);
        if ("formattedSelected" in $$props) $$invalidate(2, formattedSelected = $$props.formattedSelected);
        if ("months" in $$props) $$invalidate(40, months = $$props.months);
        if ("visibleMonth" in $$props) $$invalidate(13, visibleMonth = $$props.visibleMonth);
        if ("visibleMonthId" in $$props) $$invalidate(14, visibleMonthId = $$props.visibleMonthId);
        if ("lastVisibleDate" in $$props) lastVisibleDate = $$props.lastVisibleDate;
        if ("firstVisibleDate" in $$props) firstVisibleDate = $$props.firstVisibleDate;
        if ("canIncrementMonth" in $$props) $$invalidate(15, canIncrementMonth = $$props.canIncrementMonth);
        if ("canDecrementMonth" in $$props) $$invalidate(16, canDecrementMonth = $$props.canDecrementMonth);
        if ("wrapperStyle" in $$props) $$invalidate(17, wrapperStyle = $$props.wrapperStyle);
      };

      let months;
      let visibleMonth;
      let visibleMonthId;
      let lastVisibleDate;
      let firstVisibleDate;
      let canIncrementMonth;
      let canDecrementMonth;
      let wrapperStyle;

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] &
        /*start, end, selectableCallback, weekStart*/
        201326616) {
           $$invalidate(40, months = getMonths(start, end, selectableCallback, weekStart));
        }

        if ($$self.$$.dirty[0] &
        /*month, year*/
        1536 | $$self.$$.dirty[1] &
        /*months*/
        512) {
           {
            $$invalidate(39, monthIndex = 0);

            for (let i = 0; i < months.length; i += 1) {
              if (months[i].month === month && months[i].year === year) {
                $$invalidate(39, monthIndex = i);
              }
            }
          }
        }

        if ($$self.$$.dirty[1] &
        /*months, monthIndex*/
        768) {
           $$invalidate(13, visibleMonth = months[monthIndex]);
        }

        if ($$self.$$.dirty[0] &
        /*year, month*/
        1536) {
           $$invalidate(14, visibleMonthId = year + month / 100);
        }

        if ($$self.$$.dirty[0] &
        /*visibleMonth*/
        8192) {
           lastVisibleDate = visibleMonth.weeks[visibleMonth.weeks.length - 1].days[6].date;
        }

        if ($$self.$$.dirty[0] &
        /*visibleMonth*/
        8192) {
           firstVisibleDate = visibleMonth.weeks[0].days[0].date;
        }

        if ($$self.$$.dirty[1] &
        /*monthIndex, months*/
        768) {
           $$invalidate(15, canIncrementMonth = monthIndex < months.length - 1);
        }

        if ($$self.$$.dirty[1] &
        /*monthIndex*/
        256) {
           $$invalidate(16, canDecrementMonth = monthIndex > 0);
        }

        if ($$self.$$.dirty[0] &
        /*buttonBackgroundColor, style*/
        1610612736 | $$self.$$.dirty[1] &
        /*buttonBorderColor, buttonTextColor, highlightColor, dayBackgroundColor, dayTextColor, dayHighlightedBackgroundColor, dayHighlightedTextColor*/
        127) {
           $$invalidate(17, wrapperStyle = `
    --button-background-color: ${buttonBackgroundColor};
    --button-border-color: ${buttonBorderColor};
    --button-text-color: ${buttonTextColor};
    --highlight-color: ${highlightColor};
    --day-background-color: ${dayBackgroundColor};
    --day-text-color: ${dayTextColor};
    --day-highlighted-background-color: ${dayHighlightedBackgroundColor};
    --day-highlighted-text-color: ${dayHighlightedTextColor};
    ${style}
  `);
        }

        if ($$self.$$.dirty[0] &
        /*format, selected*/
        33554433) {
           {
            $$invalidate(2, formattedSelected = typeof format === "function" ? format(selected) : formatDate(selected, format));
          }
        }
      };

      return [selected, trigger, formattedSelected, start, end, monthsOfYear, popover, highlighted, shouldShakeDate, month, year, isOpen, isClosing, visibleMonth, visibleMonthId, canIncrementMonth, canDecrementMonth, wrapperStyle, sortedDaysOfWeek, changeMonth, incrementMonth, registerSelection, registerClose, registerOpen, dateChosen, format, selectableCallback, weekStart, daysOfWeek, style, buttonBackgroundColor, buttonBorderColor, buttonTextColor, highlightColor, dayBackgroundColor, dayTextColor, dayHighlightedBackgroundColor, dayHighlightedTextColor, shakeHighlightTimeout, monthIndex, months, lastVisibleDate, firstVisibleDate, dispatch, today, assignmentHandler, getDefaultHighlighted, getDay, incrementDayHighlighted, checkIfVisibleDateIsSelectable, shakeDate, assignValueToTrigger, handleKeyPress, close, $$slots, monthSelected_handler, incrementMonth_handler, dateSelected_handler, popover_1_binding, popover_1_open_binding, popover_1_shrink_binding, $$scope];
    }

    class Datepicker extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$5, create_fragment$5, safe_not_equal, {
          format: 25,
          start: 3,
          end: 4,
          selected: 0,
          dateChosen: 24,
          trigger: 1,
          selectableCallback: 26,
          weekStart: 27,
          daysOfWeek: 28,
          monthsOfYear: 5,
          style: 29,
          buttonBackgroundColor: 30,
          buttonBorderColor: 31,
          buttonTextColor: 32,
          highlightColor: 33,
          dayBackgroundColor: 34,
          dayTextColor: 35,
          dayHighlightedBackgroundColor: 36,
          dayHighlightedTextColor: 37,
          formattedSelected: 2
        }, [-1, -1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Datepicker",
          options,
          id: create_fragment$5.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*formattedSelected*/
        ctx[2] === undefined && !("formattedSelected" in props)) {
          console.warn("<Datepicker> was created without expected prop 'formattedSelected'");
        }
      }

      get format() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set format(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get start() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set start(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get end() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set end(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get selected() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set selected(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get dateChosen() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set dateChosen(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get trigger() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set trigger(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get selectableCallback() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set selectableCallback(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get weekStart() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set weekStart(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get daysOfWeek() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set daysOfWeek(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get monthsOfYear() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set monthsOfYear(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get style() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set style(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get buttonBackgroundColor() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set buttonBackgroundColor(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get buttonBorderColor() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set buttonBorderColor(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get buttonTextColor() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set buttonTextColor(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get highlightColor() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set highlightColor(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get dayBackgroundColor() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set dayBackgroundColor(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get dayTextColor() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set dayTextColor(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get dayHighlightedBackgroundColor() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set dayHighlightedBackgroundColor(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get dayHighlightedTextColor() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set dayHighlightedTextColor(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get formattedSelected() {
        throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set formattedSelected(value) {
        throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\widgets\Modal.svelte generated by Svelte v3.17.1 */
    const file$6 = "src\\widgets\\Modal.svelte";

    function create_fragment$6(ctx) {
      let div3;
      let div2;
      let div0;
      let t1;
      let div1;
      let t2;
      let div2_intro;
      let div2_outro;
      let div3_intro;
      let div3_outro;
      let current;
      let dispose;
      const default_slot_template =
      /*$$slots*/
      ctx[2].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[1], null);
      const block = {
        c: function create() {
          div3 = element("div");
          div2 = element("div");
          div0 = element("div");
          div0.textContent = "×";
          t1 = space();
          div1 = element("div");

          if (!default_slot) {
            t2 = text("No content specified");
          }

          if (default_slot) default_slot.c();
          attr_dev(div0, "class", "close svelte-hmjina");
          add_location(div0, file$6, 47, 8, 1160);
          attr_dev(div1, "class", "inner svelte-hmjina");
          add_location(div1, file$6, 49, 8, 1252);
          attr_dev(div2, "class", "modal-inner top-border-secondary svelte-hmjina");
          add_location(div2, file$6, 46, 4, 1012);
          attr_dev(div3, "class", "modal-background svelte-hmjina");
          add_location(div3, file$6, 45, 0, 911);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div3, anchor);
          append_dev(div3, div2);
          append_dev(div2, div0);
          append_dev(div2, t1);
          append_dev(div2, div1);

          if (!default_slot) {
            append_dev(div1, t2);
          }

          if (default_slot) {
            default_slot.m(div1, null);
          }

          current = true;
          dispose = [listen_dev(div0, "click",
          /*click_handler_1*/
          ctx[4], false, false, false), listen_dev(div2, "click", stop_propagation(
          /*click_handler*/
          ctx[3]), false, false, true)];
        },
        p: function update(ctx, [dirty]) {
          if (default_slot && default_slot.p && dirty &
          /*$$scope*/
          2) {
            default_slot.p(get_slot_context(default_slot_template, ctx,
            /*$$scope*/
            ctx[1], null), get_slot_changes(default_slot_template,
            /*$$scope*/
            ctx[1], dirty, null));
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(default_slot, local);
          add_render_callback(() => {
            if (div2_outro) div2_outro.end(1);
            if (!div2_intro) div2_intro = create_in_transition(div2, scale, {
              duration: 150,
              delay: 200
            });
            div2_intro.start();
          });
          add_render_callback(() => {
            if (div3_outro) div3_outro.end(1);
            if (!div3_intro) div3_intro = create_in_transition(div3, fade, {
              duration: 300
            });
            div3_intro.start();
          });
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          if (div2_intro) div2_intro.invalidate();
          div2_outro = create_out_transition(div2, scale, {
            duration: 150
          });
          if (div3_intro) div3_intro.invalidate();
          div3_outro = create_out_transition(div3, fade, {
            duration: 300,
            delay: 150
          });
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div3);
          if (default_slot) default_slot.d(detaching);
          if (detaching && div2_outro) div2_outro.end();
          if (detaching && div3_outro) div3_outro.end();
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$6.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
      const dispatch = createEventDispatcher();
      let {
        $$slots = {},
        $$scope
      } = $$props;

      function click_handler(event) {
        bubble($$self, event);
      }

      const click_handler_1 = () => {
        dispatch("forceClose");
      };

      $$self.$set = $$props => {
        if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => {
        return {};
      };

      $$self.$inject_state = $$props => {};

      return [dispatch, $$scope, $$slots, click_handler, click_handler_1];
    }

    class Modal extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$6, create_fragment$6, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Modal",
          options,
          id: create_fragment$6.name
        });
      }

    }

    /* src\Write.svelte generated by Svelte v3.17.1 */
    const file$7 = "src\\Write.svelte";

    function get_each_context$5(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[75] = list[i];
      return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[78] = list[i];
      return child_ctx;
    } // (367:4) {:else}


    function create_else_block_2(ctx) {
      let div;
      let h2;
      let t0;
      let t1_value =
      /*student*/
      ctx[8].fname + "";
      let t1;
      let t2;
      let t3_value = formatText(
      /*$settings*/
      ctx[19].abbrev, false, false, true) + "";
      let t3;
      let t4;
      let p;
      let t5;
      let button;
      let t7;
      let div_intro;
      let div_outro;
      let current;
      let dispose;
      const block = {
        c: function create() {
          div = element("div");
          h2 = element("h2");
          t0 = text("Edit ");
          t1 = text(t1_value);
          t2 = text("'s ");
          t3 = text(t3_value);
          t4 = space();
          p = element("p");
          t5 = text("...or ");
          button = element("button");
          button.textContent = "write a new one";
          t7 = text(".");
          attr_dev(h2, "class", "svelte-1tqh5hp");
          add_location(h2, file$7, 368, 12, 13917);
          attr_dev(button, "class", "just-text svelte-1tqh5hp");
          add_location(button, file$7, 369, 34, 14035);
          attr_dev(p, "class", "mt-0");
          add_location(p, file$7, 369, 12, 14013);
          attr_dev(div, "class", "switchable svelte-1tqh5hp");
          add_location(div, file$7, 367, 8, 13788);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, h2);
          append_dev(h2, t0);
          append_dev(h2, t1);
          append_dev(h2, t2);
          append_dev(h2, t3);
          append_dev(div, t4);
          append_dev(div, p);
          append_dev(p, t5);
          append_dev(p, button);
          append_dev(p, t7);
          current = true;
          dispose = listen_dev(button, "click",
          /*writeNewLOA*/
          ctx[23], false, false, false);
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*student*/
          256) && t1_value !== (t1_value =
          /*student*/
          ctx[8].fname + "")) set_data_dev(t1, t1_value);
          if ((!current || dirty[0] &
          /*$settings*/
          524288) && t3_value !== (t3_value = formatText(
          /*$settings*/
          ctx[19].abbrev, false, false, true) + "")) set_data_dev(t3, t3_value);
        },
        i: function intro(local) {
          if (current) return;

          if (local) {
            add_render_callback(() => {
              if (div_outro) div_outro.end(1);
              if (!div_intro) div_intro = create_in_transition(div, fly, {
                x: 100,
                delay: 500
              });
              div_intro.start();
            });
          }

          current = true;
        },
        o: function outro(local) {
          if (div_intro) div_intro.invalidate();

          if (local) {
            div_outro = create_out_transition(div, flyModified, {
              x: 100,
              position: "absolute"
            });
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching && div_outro) div_outro.end();
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_2.name,
        type: "else",
        source: "(367:4) {:else}",
        ctx
      });
      return block;
    } // (362:4) {#if LOAnew}


    function create_if_block_11(ctx) {
      let div;
      let h2;
      let t0;
      let t1_value = formatText(
      /*$settings*/
      ctx[19].abbrev, false, false, true) + "";
      let t1;
      let t2;
      let p;
      let t3;
      let button;
      let t5;
      let div_intro;
      let div_outro;
      let current;
      let dispose;
      const block = {
        c: function create() {
          div = element("div");
          h2 = element("h2");
          t0 = text("Issue a New ");
          t1 = text(t1_value);
          t2 = space();
          p = element("p");
          t3 = text("...or ");
          button = element("button");
          button.textContent = "search for an existing one";
          t5 = text(".");
          attr_dev(h2, "class", "svelte-1tqh5hp");
          add_location(h2, file$7, 363, 12, 13548);
          attr_dev(button, "class", "just-text svelte-1tqh5hp");
          add_location(button, file$7, 364, 34, 13655);
          attr_dev(p, "class", "mt-0");
          add_location(p, file$7, 364, 12, 13633);
          attr_dev(div, "class", "switchable svelte-1tqh5hp");
          add_location(div, file$7, 362, 8, 13419);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, h2);
          append_dev(h2, t0);
          append_dev(h2, t1);
          append_dev(div, t2);
          append_dev(div, p);
          append_dev(p, t3);
          append_dev(p, button);
          append_dev(p, t5);
          current = true;
          dispose = listen_dev(button, "click",
          /*searchForStudent*/
          ctx[24], false, false, false);
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*$settings*/
          524288) && t1_value !== (t1_value = formatText(
          /*$settings*/
          ctx[19].abbrev, false, false, true) + "")) set_data_dev(t1, t1_value);
        },
        i: function intro(local) {
          if (current) return;

          if (local) {
            add_render_callback(() => {
              if (div_outro) div_outro.end(1);
              if (!div_intro) div_intro = create_in_transition(div, fly, {
                x: 100,
                delay: 500
              });
              div_intro.start();
            });
          }

          current = true;
        },
        o: function outro(local) {
          if (div_intro) div_intro.invalidate();

          if (local) {
            div_outro = create_out_transition(div, flyModified, {
              x: 100,
              position: "absolute"
            });
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching && div_outro) div_outro.end();
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_11.name,
        type: "if",
        source: "(362:4) {#if LOAnew}",
        ctx
      });
      return block;
    } // (376:12) <Datepicker style={style} start={new Date(2020, 0, 1)} end={new Date(Date.now())} bind:selected={dateUpdated}>


    function create_default_slot_8(ctx) {
      let input;
      let input_value_value;
      const block = {
        c: function create() {
          input = element("input");
          attr_dev(input, "type", "text");
          input.value = input_value_value =
          /*months*/
          ctx[21][new Date(Date.now()).getMonth()] + " " + new Date(Date.now()).getDate() + ", " +
          /*dateUpdated*/
          ctx[12].getFullYear();
          attr_dev(input, "class", "svelte-1tqh5hp");
          add_location(input, file$7, 376, 16, 14379);
        },
        m: function mount(target, anchor) {
          insert_dev(target, input, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*dateUpdated*/
          4096 && input_value_value !== (input_value_value =
          /*months*/
          ctx[21][new Date(Date.now()).getMonth()] + " " + new Date(Date.now()).getDate() + ", " +
          /*dateUpdated*/
          ctx[12].getFullYear()) && input.value !== input_value_value) {
            prop_dev(input, "value", input_value_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(input);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_8.name,
        type: "slot",
        source: "(376:12) <Datepicker style={style} start={new Date(2020, 0, 1)} end={new Date(Date.now())} bind:selected={dateUpdated}>",
        ctx
      });
      return block;
    } // (424:16) {:else}


    function create_else_block_1(ctx) {
      let li;
      let t0;
      let t1_value = formatText(
      /*$settings*/
      ctx[19].services, true, false) + "";
      let t1;
      let t2;
      let a;
      let dispose;
      const block = {
        c: function create() {
          li = element("li");
          t0 = text("No ");
          t1 = text(t1_value);
          t2 = text(" listed - ");
          a = element("a");
          a.textContent = "add some!";
          attr_dev(a, "href", "addAccom");
          add_location(a, file$7, 424, 82, 17054);
          add_location(li, file$7, 424, 20, 16992);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, t1);
          append_dev(li, t2);
          append_dev(li, a);
          dispose = listen_dev(a, "click", prevent_default(
          /*click_handler_2*/
          ctx[45]), false, true, false);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$settings*/
          524288 && t1_value !== (t1_value = formatText(
          /*$settings*/
          ctx[19].services, true, false) + "")) set_data_dev(t1, t1_value);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_1.name,
        type: "else",
        source: "(424:16) {:else}",
        ctx
      });
      return block;
    } // (398:16) {#if selectedAccoms.length > 0}


    function create_if_block_10(ctx) {
      let t0;
      let li;
      let a;
      let current;
      let dispose;
      const sortablelist = new SortableList({
        props: {
          list:
          /*selectedAccoms*/
          ctx[18],
          key: "_id",
          $$slots: {
            default: [create_default_slot_7, ({
              item,
              index
            }) => ({
              81: item,
              82: index
            }), ({
              item,
              index
            }) => [0, 0, (item ? 524288 : 0) | (index ? 1048576 : 0)]]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      sortablelist.$on("sort",
      /*sortAccoms*/
      ctx[20]);
      const block = {
        c: function create() {
          create_component(sortablelist.$$.fragment);
          t0 = space();
          li = element("li");
          a = element("a");
          a.textContent = "Add more";
          attr_dev(a, "href", "addAccom");
          add_location(a, file$7, 422, 24, 16852);
          add_location(li, file$7, 422, 20, 16848);
        },
        m: function mount(target, anchor) {
          mount_component(sortablelist, target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, li, anchor);
          append_dev(li, a);
          current = true;
          dispose = listen_dev(a, "click", prevent_default(
          /*click_handler_1*/
          ctx[44]), false, true, false);
        },
        p: function update(ctx, dirty) {
          const sortablelist_changes = {};
          if (dirty[0] &
          /*selectedAccoms*/
          262144) sortablelist_changes.list =
          /*selectedAccoms*/
          ctx[18];

          if (dirty[0] &
          /*accoms*/
          1024 | dirty[2] &
          /*$$scope, item*/
          2621440) {
            sortablelist_changes.$$scope = {
              dirty,
              ctx
            };
          }

          sortablelist.$set(sortablelist_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(sortablelist.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(sortablelist.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(sortablelist, detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(li);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_10.name,
        type: "if",
        source: "(398:16) {#if selectedAccoms.length > 0}",
        ctx
      });
      return block;
    } // (411:20) <SortableList                           list={selectedAccoms}                           key="_id"                          on:sort={sortAccoms}                           let:item                          let:index>


    function create_default_slot_7(ctx) {
      let li;
      let h4;
      let t0_value =
      /*item*/
      ctx[81].name + "";
      let t0;
      let t1;
      let p;
      let t2_value = abbreviate(
      /*item*/
      ctx[81].content, 150) + "";
      let t2;
      let t3;
      let div;
      let dispose;

      function click_handler(...args) {
        return (
          /*click_handler*/
          ctx[43](
          /*item*/
          ctx[81], ...args)
        );
      }

      const block = {
        c: function create() {
          li = element("li");
          h4 = element("h4");
          t0 = text(t0_value);
          t1 = space();
          p = element("p");
          t2 = text(t2_value);
          t3 = space();
          div = element("div");
          div.textContent = "×";
          add_location(h4, file$7, 417, 28, 16550);
          add_location(p, file$7, 418, 28, 16600);
          attr_dev(div, "class", "close");
          add_location(div, file$7, 419, 28, 16668);
          attr_dev(li, "class", "whitebox accommodation svelte-1tqh5hp");
          add_location(li, file$7, 416, 24, 16485);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, h4);
          append_dev(h4, t0);
          append_dev(li, t1);
          append_dev(li, p);
          append_dev(p, t2);
          append_dev(li, t3);
          append_dev(li, div);
          dispose = listen_dev(div, "click", click_handler, false, false, false);
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[2] &
          /*item*/
          524288 && t0_value !== (t0_value =
          /*item*/
          ctx[81].name + "")) set_data_dev(t0, t0_value);
          if (dirty[2] &
          /*item*/
          524288 && t2_value !== (t2_value = abbreviate(
          /*item*/
          ctx[81].content, 150) + "")) set_data_dev(t2, t2_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_7.name,
        type: "slot",
        source: "(411:20) <SortableList                           list={selectedAccoms}                           key=\\\"_id\\\"                          on:sort={sortAccoms}                           let:item                          let:index>",
        ctx
      });
      return block;
    } // (432:12) {#if studentNotesHighlighted}


    function create_if_block_9(ctx) {
      let div;
      let t_value = (
      /*studentNotes*/
      ctx[11] ? 250 -
      /*studentNotes*/
      ctx[11].length : 250) + "";
      let t;
      let div_transition;
      let current;
      const block = {
        c: function create() {
          div = element("div");
          t = text(t_value);
          attr_dev(div, "class", "remaining-characters");
          add_location(div, file$7, 432, 16, 17387);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t);
          current = true;
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*studentNotes*/
          2048) && t_value !== (t_value = (
          /*studentNotes*/
          ctx[11] ? 250 -
          /*studentNotes*/
          ctx[11].length : 250) + "")) set_data_dev(t, t_value);
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (!div_transition) div_transition = create_bidirectional_transition(div, scale, {}, true);
            div_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          if (!div_transition) div_transition = create_bidirectional_transition(div, scale, {}, false);
          div_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching && div_transition) div_transition.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_9.name,
        type: "if",
        source: "(432:12) {#if studentNotesHighlighted}",
        ctx
      });
      return block;
    } // (448:4) {#if showSearchModal}


    function create_if_block_8(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_6]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler*/
      ctx[55]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty[0] &
          /*searchStud, $settings*/
          524800 | dirty[2] &
          /*$$scope*/
          2097152) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_8.name,
        type: "if",
        source: "(448:4) {#if showSearchModal}",
        ctx
      });
      return block;
    } // (449:8) <Modal on:forceClose={()=>{ showSearchModal = false; }}>


    function create_default_slot_6(ctx) {
      let h3;
      let t0;
      let t1_value = formatText(
      /*$settings*/
      ctx[19].students, false, true) + "";
      let t1;
      let t2;
      let p;
      let t4;
      let form;
      let div0;
      let label0;
      let t6;
      let input0;
      let t7;
      let div1;
      let label1;
      let t9;
      let input1;
      let t10;
      let div2;
      let label2;
      let t12;
      let input2;
      let t13;
      let button;
      let dispose;
      const block = {
        c: function create() {
          h3 = element("h3");
          t0 = text("Find a ");
          t1 = text(t1_value);
          t2 = space();
          p = element("p");
          p.textContent = "Search by ID or first and last name.";
          t4 = space();
          form = element("form");
          div0 = element("div");
          label0 = element("label");
          label0.textContent = "ID#";
          t6 = space();
          input0 = element("input");
          t7 = space();
          div1 = element("div");
          label1 = element("label");
          label1.textContent = "First Name";
          t9 = space();
          input1 = element("input");
          t10 = space();
          div2 = element("div");
          label2 = element("label");
          label2.textContent = "Last Name";
          t12 = space();
          input2 = element("input");
          t13 = space();
          button = element("button");
          button.textContent = "Find them!";
          add_location(h3, file$7, 449, 12, 18215);
          add_location(p, file$7, 450, 12, 18290);
          attr_dev(label0, "for", "search-id");
          add_location(label0, file$7, 453, 20, 18418);
          attr_dev(input0, "id", "search-id");
          attr_dev(input0, "type", "text");
          attr_dev(input0, "maxlength", "20");
          attr_dev(input0, "class", "svelte-1tqh5hp");
          add_location(input0, file$7, 454, 20, 18474);
          attr_dev(div0, "class", "form-halves");
          add_location(div0, file$7, 452, 16, 18371);
          attr_dev(label1, "for", "search-fname");
          add_location(label1, file$7, 457, 20, 18640);
          attr_dev(input1, "id", "search-fname");
          attr_dev(input1, "type", "text");
          attr_dev(input1, "maxlength", "100");
          attr_dev(input1, "class", "svelte-1tqh5hp");
          add_location(input1, file$7, 458, 20, 18706);
          attr_dev(div1, "class", "form-halves");
          add_location(div1, file$7, 456, 16, 18593);
          attr_dev(label2, "for", "search-lname");
          add_location(label2, file$7, 461, 20, 18878);
          attr_dev(input2, "id", "search-lname");
          attr_dev(input2, "type", "text");
          attr_dev(input2, "maxlength", "100");
          attr_dev(input2, "class", "svelte-1tqh5hp");
          add_location(input2, file$7, 462, 20, 18943);
          attr_dev(div2, "class", "form-halves");
          add_location(div2, file$7, 460, 16, 18831);
          attr_dev(button, "class", "centered blue");
          attr_dev(button, "type", "submit");
          add_location(button, file$7, 465, 16, 19070);
          add_location(form, file$7, 451, 12, 18347);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          append_dev(h3, t0);
          append_dev(h3, t1);
          insert_dev(target, t2, anchor);
          insert_dev(target, p, anchor);
          insert_dev(target, t4, anchor);
          insert_dev(target, form, anchor);
          append_dev(form, div0);
          append_dev(div0, label0);
          append_dev(div0, t6);
          append_dev(div0, input0);
          set_input_value(input0,
          /*searchStud*/
          ctx[9]._id);
          append_dev(form, t7);
          append_dev(form, div1);
          append_dev(div1, label1);
          append_dev(div1, t9);
          append_dev(div1, input1);
          set_input_value(input1,
          /*searchStud*/
          ctx[9].fname);
          append_dev(form, t10);
          append_dev(form, div2);
          append_dev(div2, label2);
          append_dev(div2, t12);
          append_dev(div2, input2);
          set_input_value(input2,
          /*searchStud*/
          ctx[9].lname);
          append_dev(form, t13);
          append_dev(form, button);
          dispose = [listen_dev(input0, "input",
          /*input0_input_handler_1*/
          ctx[52]), listen_dev(input1, "input",
          /*input1_input_handler_1*/
          ctx[53]), listen_dev(input2, "input",
          /*input2_input_handler_1*/
          ctx[54]), listen_dev(button, "click", prevent_default(
          /*search*/
          ctx[28]), false, true, false)];
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$settings*/
          524288 && t1_value !== (t1_value = formatText(
          /*$settings*/
          ctx[19].students, false, true) + "")) set_data_dev(t1, t1_value);

          if (dirty[0] &
          /*searchStud*/
          512 && input0.value !==
          /*searchStud*/
          ctx[9]._id) {
            set_input_value(input0,
            /*searchStud*/
            ctx[9]._id);
          }

          if (dirty[0] &
          /*searchStud*/
          512 && input1.value !==
          /*searchStud*/
          ctx[9].fname) {
            set_input_value(input1,
            /*searchStud*/
            ctx[9].fname);
          }

          if (dirty[0] &
          /*searchStud*/
          512 && input2.value !==
          /*searchStud*/
          ctx[9].lname) {
            set_input_value(input2,
            /*searchStud*/
            ctx[9].lname);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(p);
          if (detaching) detach_dev(t4);
          if (detaching) detach_dev(form);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_6.name,
        type: "slot",
        source: "(449:8) <Modal on:forceClose={()=>{ showSearchModal = false; }}>",
        ctx
      });
      return block;
    } // (471:4) {#if showOverwriteModal}


    function create_if_block_7(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_1*/
      ctx[58]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty[0] &
          /*showOverwriteModal, $settings*/
          524296 | dirty[2] &
          /*$$scope*/
          2097152) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_7.name,
        type: "if",
        source: "(471:4) {#if showOverwriteModal}",
        ctx
      });
      return block;
    } // (472:8) <Modal on:forceClose={()=>{ showOverwriteModal = false }}>


    function create_default_slot_5(ctx) {
      let h3;
      let t0;
      let t1_value = formatText(
      /*$settings*/
      ctx[19].students, false, false) + "";
      let t1;
      let t2;
      let t3;
      let p;
      let t4;
      let t5_value = formatText(
      /*$settings*/
      ctx[19].students, false, false) + "";
      let t5;
      let t6;
      let t7_value = formatText(
      /*$settings*/
      ctx[19].abbrev, false, false, true) + "";
      let t7;
      let t8;
      let t9;
      let div;
      let button0;
      let t11;
      let button1;
      let dispose;
      const block = {
        c: function create() {
          h3 = element("h3");
          t0 = text("Found an existing ");
          t1 = text(t1_value);
          t2 = text("!");
          t3 = space();
          p = element("p");
          t4 = text("A ");
          t5 = text(t5_value);
          t6 = text(" with that ID already exists. Do you want to issue a new ");
          t7 = text(t7_value);
          t8 = text(" for them?");
          t9 = space();
          div = element("div");
          button0 = element("button");
          button0.textContent = "Yes";
          t11 = space();
          button1 = element("button");
          button1.textContent = "No";
          add_location(h3, file$7, 472, 12, 19330);
          add_location(p, file$7, 473, 12, 19418);
          attr_dev(button0, "class", "centered");
          attr_dev(button0, "type", "submit");
          add_location(button0, file$7, 475, 20, 19654);
          attr_dev(button1, "class", "centered blue");
          attr_dev(button1, "type", "submit");
          add_location(button1, file$7, 476, 20, 19800);
          attr_dev(div, "class", "align-ends");
          add_location(div, file$7, 474, 16, 19608);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          append_dev(h3, t0);
          append_dev(h3, t1);
          append_dev(h3, t2);
          insert_dev(target, t3, anchor);
          insert_dev(target, p, anchor);
          append_dev(p, t4);
          append_dev(p, t5);
          append_dev(p, t6);
          append_dev(p, t7);
          append_dev(p, t8);
          insert_dev(target, t9, anchor);
          insert_dev(target, div, anchor);
          append_dev(div, button0);
          append_dev(div, t11);
          append_dev(div, button1);
          dispose = [listen_dev(button0, "click", prevent_default(
          /*click_handler_5*/
          ctx[56]), false, true, false), listen_dev(button1, "click", prevent_default(
          /*click_handler_6*/
          ctx[57]), false, true, false)];
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$settings*/
          524288 && t1_value !== (t1_value = formatText(
          /*$settings*/
          ctx[19].students, false, false) + "")) set_data_dev(t1, t1_value);
          if (dirty[0] &
          /*$settings*/
          524288 && t5_value !== (t5_value = formatText(
          /*$settings*/
          ctx[19].students, false, false) + "")) set_data_dev(t5, t5_value);
          if (dirty[0] &
          /*$settings*/
          524288 && t7_value !== (t7_value = formatText(
          /*$settings*/
          ctx[19].abbrev, false, false, true) + "")) set_data_dev(t7, t7_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(p);
          if (detaching) detach_dev(t9);
          if (detaching) detach_dev(div);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5.name,
        type: "slot",
        source: "(472:8) <Modal on:forceClose={()=>{ showOverwriteModal = false }}>",
        ctx
      });
      return block;
    } // (482:4) {#if showSearchListModal}


    function create_if_block_5(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_2*/
      ctx[61]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty[0] &
          /*showSearchListModal, showSearchModal, searchResults, $settings*/
          524422 | dirty[2] &
          /*$$scope*/
          2097152) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5.name,
        type: "if",
        source: "(482:4) {#if showSearchListModal}",
        ctx
      });
      return block;
    } // (487:12) {:else}


    function create_else_block(ctx) {
      let p;
      let t0;
      let t1_value = formatText(
      /*$settings*/
      ctx[19].students, true, false) + "";
      let t1;
      let t2;
      let t3;
      let ul;
      let each_value_1 =
      /*searchResults*/
      ctx[7];
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
      }

      const block = {
        c: function create() {
          p = element("p");
          t0 = text("We found the following ");
          t1 = text(t1_value);
          t2 = text(":");
          t3 = space();
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          add_location(p, file$7, 487, 16, 20238);
          attr_dev(ul, "class", "selectables svelte-1tqh5hp");
          add_location(ul, file$7, 488, 16, 20332);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
          append_dev(p, t0);
          append_dev(p, t1);
          append_dev(p, t2);
          insert_dev(target, t3, anchor);
          insert_dev(target, ul, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$settings*/
          524288 && t1_value !== (t1_value = formatText(
          /*$settings*/
          ctx[19].students, true, false) + "")) set_data_dev(t1, t1_value);

          if (dirty[0] &
          /*loadStudent, searchResults*/
          134217856) {
            each_value_1 =
            /*searchResults*/
            ctx[7];
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_1(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(ul, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_1.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(ul);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block.name,
        type: "else",
        source: "(487:12) {:else}",
        ctx
      });
      return block;
    } // (485:12) {#if searchResults.length == 0}


    function create_if_block_6(ctx) {
      let p;
      const block = {
        c: function create() {
          p = element("p");
          p.textContent = "No results were found. :-(";
          add_location(p, file$7, 485, 16, 20166);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6.name,
        type: "if",
        source: "(485:12) {#if searchResults.length == 0}",
        ctx
      });
      return block;
    } // (490:16) {#each searchResults as result}


    function create_each_block_1(ctx) {
      let li;
      let t0_value =
      /*result*/
      ctx[78].student.lname + "";
      let t0;
      let t1;
      let t2_value =
      /*result*/
      ctx[78].student.fname + "";
      let t2;
      let t3;
      let t4_value =
      /*result*/
      ctx[78].student._id + "";
      let t4;
      let dispose;

      function click_handler_7(...args) {
        return (
          /*click_handler_7*/
          ctx[59](
          /*result*/
          ctx[78], ...args)
        );
      }

      const block = {
        c: function create() {
          li = element("li");
          t0 = text(t0_value);
          t1 = text(", ");
          t2 = text(t2_value);
          t3 = text(" - ");
          t4 = text(t4_value);
          attr_dev(li, "class", "svelte-1tqh5hp");
          add_location(li, file$7, 490, 20, 20427);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, t1);
          append_dev(li, t2);
          append_dev(li, t3);
          append_dev(li, t4);
          dispose = listen_dev(li, "click", click_handler_7, false, false, false);
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] &
          /*searchResults*/
          128 && t0_value !== (t0_value =
          /*result*/
          ctx[78].student.lname + "")) set_data_dev(t0, t0_value);
          if (dirty[0] &
          /*searchResults*/
          128 && t2_value !== (t2_value =
          /*result*/
          ctx[78].student.fname + "")) set_data_dev(t2, t2_value);
          if (dirty[0] &
          /*searchResults*/
          128 && t4_value !== (t4_value =
          /*result*/
          ctx[78].student._id + "")) set_data_dev(t4, t4_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1.name,
        type: "each",
        source: "(490:16) {#each searchResults as result}",
        ctx
      });
      return block;
    } // (483:8) <Modal on:forceClose={()=> { showSearchListModal = false; }}>


    function create_default_slot_4(ctx) {
      let h3;
      let t1;
      let t2;
      let button;
      let dispose;

      function select_block_type_2(ctx, dirty) {
        if (
        /*searchResults*/
        ctx[7].length == 0) return create_if_block_6;
        return create_else_block;
      }

      let current_block_type = select_block_type_2(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "Results";
          t1 = space();
          if_block.c();
          t2 = space();
          button = element("button");
          button.textContent = "Back";
          add_location(h3, file$7, 483, 12, 20087);
          attr_dev(button, "class", "centered");
          attr_dev(button, "type", "submit");
          add_location(button, file$7, 494, 12, 20633);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          insert_dev(target, t1, anchor);
          if_block.m(target, anchor);
          insert_dev(target, t2, anchor);
          insert_dev(target, button, anchor);
          dispose = listen_dev(button, "click", prevent_default(
          /*click_handler_8*/
          ctx[60]), false, true, false);
        },
        p: function update(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(t2.parentNode, t2);
            }
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t1);
          if_block.d(detaching);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(button);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4.name,
        type: "slot",
        source: "(483:8) <Modal on:forceClose={()=> { showSearchListModal = false; }}>",
        ctx
      });
      return block;
    } // (499:4) {#if showSavedModal}


    function create_if_block_4(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_3*/
      ctx[63]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty[0] &
          /*$settings, student*/
          524544 | dirty[2] &
          /*$$scope*/
          2097152) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4.name,
        type: "if",
        source: "(499:4) {#if showSavedModal}",
        ctx
      });
      return block;
    } // (500:8) <Modal on:forceClose={()=> { endSave() }}>


    function create_default_slot_3(ctx) {
      let h3;
      let t1;
      let p;
      let t2;
      let t3_value =
      /*student*/
      ctx[8].fname + "";
      let t3;
      let t4;
      let t5_value =
      /*student*/
      ctx[8].lname + "";
      let t5;
      let t6;
      let t7_value = formatText(
      /*$settings*/
      ctx[19].abbrev, false, false, true) + "";
      let t7;
      let t8;
      let t9;
      let button;
      let dispose;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "Saved!";
          t1 = space();
          p = element("p");
          t2 = text("You saved ");
          t3 = text(t3_value);
          t4 = space();
          t5 = text(t5_value);
          t6 = text("'s ");
          t7 = text(t7_value);
          t8 = text(".");
          t9 = space();
          button = element("button");
          button.textContent = "OK";
          add_location(h3, file$7, 500, 12, 20896);
          add_location(p, file$7, 501, 12, 20925);
          attr_dev(button, "class", "centered blue");
          attr_dev(button, "type", "submit");
          add_location(button, file$7, 502, 12, 21041);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, p, anchor);
          append_dev(p, t2);
          append_dev(p, t3);
          append_dev(p, t4);
          append_dev(p, t5);
          append_dev(p, t6);
          append_dev(p, t7);
          append_dev(p, t8);
          insert_dev(target, t9, anchor);
          insert_dev(target, button, anchor);
          dispose = listen_dev(button, "click", prevent_default(
          /*click_handler_9*/
          ctx[62]), false, true, false);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*student*/
          256 && t3_value !== (t3_value =
          /*student*/
          ctx[8].fname + "")) set_data_dev(t3, t3_value);
          if (dirty[0] &
          /*student*/
          256 && t5_value !== (t5_value =
          /*student*/
          ctx[8].lname + "")) set_data_dev(t5, t5_value);
          if (dirty[0] &
          /*$settings*/
          524288 && t7_value !== (t7_value = formatText(
          /*$settings*/
          ctx[19].abbrev, false, false, true) + "")) set_data_dev(t7, t7_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(p);
          if (detaching) detach_dev(t9);
          if (detaching) detach_dev(button);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3.name,
        type: "slot",
        source: "(500:8) <Modal on:forceClose={()=> { endSave() }}>",
        ctx
      });
      return block;
    } // (507:4) {#if showFormErrorModal}


    function create_if_block_3(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_4*/
      ctx[65]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty[0] &
          /*showFormErrorModal, $settings*/
          524320 | dirty[2] &
          /*$$scope*/
          2097152) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3.name,
        type: "if",
        source: "(507:4) {#if showFormErrorModal}",
        ctx
      });
      return block;
    } // (508:8) <Modal on:forceClose={()=> { showFormErrorModal = false }}>


    function create_default_slot_2(ctx) {
      let h3;
      let t1;
      let p;
      let t2;
      let t3_value = formatText(
      /*$settings*/
      ctx[19].students, false, false) + "";
      let t3;
      let t4;
      let t5_value = formatText(
      /*$settings*/
      ctx[19].services, true, false) + "";
      let t5;
      let t6;
      let t7_value = formatText(
      /*$settings*/
      ctx[19].students, false, false) + "";
      let t7;
      let t8;
      let t9;
      let button;
      let dispose;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "Whoops!";
          t1 = space();
          p = element("p");
          t2 = text("Looks like you didn't fill in all the ");
          t3 = text(t3_value);
          t4 = text("'s information. Also make sure that you've added all the ");
          t5 = text(t5_value);
          t6 = text(" the ");
          t7 = text(t7_value);
          t8 = text(" needs.");
          t9 = space();
          button = element("button");
          button.textContent = "OK";
          add_location(h3, file$7, 508, 12, 21285);
          add_location(p, file$7, 509, 12, 21315);
          attr_dev(button, "class", "centered blue");
          attr_dev(button, "type", "submit");
          add_location(button, file$7, 510, 12, 21580);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, p, anchor);
          append_dev(p, t2);
          append_dev(p, t3);
          append_dev(p, t4);
          append_dev(p, t5);
          append_dev(p, t6);
          append_dev(p, t7);
          append_dev(p, t8);
          insert_dev(target, t9, anchor);
          insert_dev(target, button, anchor);
          dispose = listen_dev(button, "click", prevent_default(
          /*click_handler_10*/
          ctx[64]), false, true, false);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$settings*/
          524288 && t3_value !== (t3_value = formatText(
          /*$settings*/
          ctx[19].students, false, false) + "")) set_data_dev(t3, t3_value);
          if (dirty[0] &
          /*$settings*/
          524288 && t5_value !== (t5_value = formatText(
          /*$settings*/
          ctx[19].services, true, false) + "")) set_data_dev(t5, t5_value);
          if (dirty[0] &
          /*$settings*/
          524288 && t7_value !== (t7_value = formatText(
          /*$settings*/
          ctx[19].students, false, false) + "")) set_data_dev(t7, t7_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(p);
          if (detaching) detach_dev(t9);
          if (detaching) detach_dev(button);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2.name,
        type: "slot",
        source: "(508:8) <Modal on:forceClose={()=> { showFormErrorModal = false }}>",
        ctx
      });
      return block;
    } // (515:4) {#if showAccomsModal}


    function create_if_block_2(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_5*/
      ctx[68]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty[0] &
          /*showAccomsModal, $settings, accoms*/
          525376 | dirty[2] &
          /*$$scope*/
          2097152) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2.name,
        type: "if",
        source: "(515:4) {#if showAccomsModal}",
        ctx
      });
      return block;
    } // (519:16) {#each accoms as accom}


    function create_each_block$5(ctx) {
      let li;
      let t_value = abbreviate(
      /*accom*/
      ctx[75].name, 25) + "";
      let t;
      let dispose;

      function click_handler_11(...args) {
        return (
          /*click_handler_11*/
          ctx[66](
          /*accom*/
          ctx[75], ...args)
        );
      }

      const block = {
        c: function create() {
          li = element("li");
          t = text(t_value);
          attr_dev(li, "class", "svelte-1tqh5hp");
          toggle_class(li, "selected",
          /*accom*/
          ctx[75].selected);
          add_location(li, file$7, 519, 20, 21998);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t);
          dispose = listen_dev(li, "click", click_handler_11, false, false, false);
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] &
          /*accoms*/
          1024 && t_value !== (t_value = abbreviate(
          /*accom*/
          ctx[75].name, 25) + "")) set_data_dev(t, t_value);

          if (dirty[0] &
          /*accoms*/
          1024) {
            toggle_class(li, "selected",
            /*accom*/
            ctx[75].selected);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$5.name,
        type: "each",
        source: "(519:16) {#each accoms as accom}",
        ctx
      });
      return block;
    } // (516:8) <Modal on:forceClose={()=>{ showAccomsModal = false }}>


    function create_default_slot_1(ctx) {
      let h3;
      let t0;
      let t1_value = formatText(
      /*$settings*/
      ctx[19].services, true, true) + "";
      let t1;
      let t2;
      let ul;
      let t3;
      let p;
      let t4;
      let a;
      let t5;
      let t6_value = formatText(
      /*$settings*/
      ctx[19].services, false, false) + "";
      let t6;
      let t7;
      let t8;
      let button;
      let dispose;
      let each_value =
      /*accoms*/
      ctx[10];
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          h3 = element("h3");
          t0 = text("Select ");
          t1 = text(t1_value);
          t2 = space();
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t3 = space();
          p = element("p");
          t4 = text("...or ");
          a = element("a");
          t5 = text("add a custom ");
          t6 = text(t6_value);
          t7 = text(".");
          t8 = space();
          button = element("button");
          button.textContent = "OK";
          add_location(h3, file$7, 516, 12, 21834);
          attr_dev(ul, "id", "accoms-modal-list");
          attr_dev(ul, "class", "svelte-1tqh5hp");
          add_location(ul, file$7, 517, 12, 21908);
          attr_dev(a, "href", "custom");
          add_location(a, file$7, 522, 21, 22185);
          add_location(p, file$7, 522, 12, 22176);
          attr_dev(button, "class", "centered blue");
          attr_dev(button, "type", "submit");
          add_location(button, file$7, 523, 12, 22325);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          append_dev(h3, t0);
          append_dev(h3, t1);
          insert_dev(target, t2, anchor);
          insert_dev(target, ul, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          insert_dev(target, t3, anchor);
          insert_dev(target, p, anchor);
          append_dev(p, t4);
          append_dev(p, a);
          append_dev(a, t5);
          append_dev(a, t6);
          append_dev(a, t7);
          insert_dev(target, t8, anchor);
          insert_dev(target, button, anchor);
          dispose = [listen_dev(a, "click", prevent_default(
          /*addCustomAccom*/
          ctx[30]), false, true, false), listen_dev(button, "click", prevent_default(
          /*click_handler_12*/
          ctx[67]), false, true, false)];
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$settings*/
          524288 && t1_value !== (t1_value = formatText(
          /*$settings*/
          ctx[19].services, true, true) + "")) set_data_dev(t1, t1_value);

          if (dirty[0] &
          /*accoms*/
          1024) {
            each_value =
            /*accoms*/
            ctx[10];
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$5(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$5(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(ul, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }

          if (dirty[0] &
          /*$settings*/
          524288 && t6_value !== (t6_value = formatText(
          /*$settings*/
          ctx[19].services, false, false) + "")) set_data_dev(t6, t6_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(ul);
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(p);
          if (detaching) detach_dev(t8);
          if (detaching) detach_dev(button);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1.name,
        type: "slot",
        source: "(516:8) <Modal on:forceClose={()=>{ showAccomsModal = false }}>",
        ctx
      });
      return block;
    } // (528:4) {#if accomCreatorOpen}


    function create_if_block$2(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_6*/
      ctx[74]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty[0] &
          /*newAccom, accomContentHighlighted, $settings*/
          720896 | dirty[2] &
          /*$$scope*/
          2097152) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$2.name,
        type: "if",
        source: "(528:4) {#if accomCreatorOpen}",
        ctx
      });
      return block;
    } // (539:24) {#if accomContentHighlighted}


    function create_if_block_1(ctx) {
      let div;
      let t_value = (
      /*newAccom*/
      ctx[17].content.length ? 1200 -
      /*newAccom*/
      ctx[17].content.length : 1200) + "";
      let t;
      let div_transition;
      let current;
      const block = {
        c: function create() {
          div = element("div");
          t = text(t_value);
          attr_dev(div, "class", "remaining-characters");
          add_location(div, file$7, 539, 28, 23170);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t);
          current = true;
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*newAccom*/
          131072) && t_value !== (t_value = (
          /*newAccom*/
          ctx[17].content.length ? 1200 -
          /*newAccom*/
          ctx[17].content.length : 1200) + "")) set_data_dev(t, t_value);
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (!div_transition) div_transition = create_bidirectional_transition(div, scale, {}, true);
            div_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          if (!div_transition) div_transition = create_bidirectional_transition(div, scale, {}, false);
          div_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching && div_transition) div_transition.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1.name,
        type: "if",
        source: "(539:24) {#if accomContentHighlighted}",
        ctx
      });
      return block;
    } // (529:8) <Modal on:forceClose={()=>{ accomCreatorOpen = false; newAccom = { name: "", content: "" } }}>


    function create_default_slot$1(ctx) {
      let h3;
      let t0_value = formatText(
      /*$settings*/
      ctx[19].services, false, true) + "";
      let t0;
      let t1;
      let t2;
      let form;
      let div0;
      let label0;
      let t4;
      let input;
      let t5;
      let div2;
      let label1;
      let br;
      let t7;
      let div1;
      let t8;
      let textarea;
      let t9;
      let button;
      let current;
      let dispose;
      let if_block =
      /*accomContentHighlighted*/
      ctx[16] && create_if_block_1(ctx);
      const block = {
        c: function create() {
          h3 = element("h3");
          t0 = text(t0_value);
          t1 = text(" Details");
          t2 = space();
          form = element("form");
          div0 = element("div");
          label0 = element("label");
          label0.textContent = "Name";
          t4 = space();
          input = element("input");
          t5 = space();
          div2 = element("div");
          label1 = element("label");
          label1.textContent = "Content";
          br = element("br");
          t7 = space();
          div1 = element("div");
          if (if_block) if_block.c();
          t8 = space();
          textarea = element("textarea");
          t9 = space();
          button = element("button");
          button.textContent = "OK";
          attr_dev(h3, "class", "extend svelte-1tqh5hp");
          add_location(h3, file$7, 529, 12, 22616);
          attr_dev(label0, "for", "name");
          attr_dev(label0, "class", "svelte-1tqh5hp");
          add_location(label0, file$7, 532, 20, 22799);
          attr_dev(input, "type", "text");
          attr_dev(input, "id", "name");
          attr_dev(input, "class", "svelte-1tqh5hp");
          add_location(input, file$7, 533, 20, 22851);
          attr_dev(div0, "class", "form-halves2 svelte-1tqh5hp");
          add_location(div0, file$7, 531, 16, 22751);
          attr_dev(label1, "for", "content");
          add_location(label1, file$7, 536, 20, 22987);
          add_location(br, file$7, 536, 56, 23023);
          attr_dev(textarea, "type", "text");
          attr_dev(textarea, "id", "content");
          attr_dev(textarea, "rows", "5");
          attr_dev(textarea, "maxlength", "1200");
          attr_dev(textarea, "class", "svelte-1tqh5hp");
          add_location(textarea, file$7, 543, 24, 23414);
          attr_dev(div1, "class", "accom-content-wrapper svelte-1tqh5hp");
          add_location(div1, file$7, 537, 20, 23050);
          attr_dev(div2, "class", "in");
          add_location(div2, file$7, 535, 16, 22949);
          attr_dev(button, "class", "centered blue");
          attr_dev(button, "type", "submit");
          add_location(button, file$7, 547, 16, 23684);
          attr_dev(form, "id", "new-accom-form");
          attr_dev(form, "class", "svelte-1tqh5hp");
          add_location(form, file$7, 530, 12, 22707);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          append_dev(h3, t0);
          append_dev(h3, t1);
          insert_dev(target, t2, anchor);
          insert_dev(target, form, anchor);
          append_dev(form, div0);
          append_dev(div0, label0);
          append_dev(div0, t4);
          append_dev(div0, input);
          set_input_value(input,
          /*newAccom*/
          ctx[17].name);
          append_dev(form, t5);
          append_dev(form, div2);
          append_dev(div2, label1);
          append_dev(div2, br);
          append_dev(div2, t7);
          append_dev(div2, div1);
          if (if_block) if_block.m(div1, null);
          append_dev(div1, t8);
          append_dev(div1, textarea);
          set_input_value(textarea,
          /*newAccom*/
          ctx[17].content);
          append_dev(form, t9);
          append_dev(form, button);
          current = true;
          dispose = [listen_dev(input, "input",
          /*input_input_handler*/
          ctx[69]), listen_dev(textarea, "input",
          /*textarea_input_handler_1*/
          ctx[70]), listen_dev(textarea, "focus",
          /*focus_handler_1*/
          ctx[71], false, false, false), listen_dev(textarea, "blur",
          /*blur_handler_1*/
          ctx[72], false, false, false), listen_dev(button, "click", prevent_default(
          /*click_handler_13*/
          ctx[73]), false, true, false)];
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*$settings*/
          524288) && t0_value !== (t0_value = formatText(
          /*$settings*/
          ctx[19].services, false, true) + "")) set_data_dev(t0, t0_value);

          if (dirty[0] &
          /*newAccom*/
          131072 && input.value !==
          /*newAccom*/
          ctx[17].name) {
            set_input_value(input,
            /*newAccom*/
            ctx[17].name);
          }

          if (
          /*accomContentHighlighted*/
          ctx[16]) {
            if (if_block) {
              if_block.p(ctx, dirty);
              transition_in(if_block, 1);
            } else {
              if_block = create_if_block_1(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div1, t8);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }

          if (dirty[0] &
          /*newAccom*/
          131072) {
            set_input_value(textarea,
            /*newAccom*/
            ctx[17].content);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(form);
          if (if_block) if_block.d();
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$1.name,
        type: "slot",
        source: "(529:8) <Modal on:forceClose={()=>{ accomCreatorOpen = false; newAccom = { name: \\\"\\\", content: \\\"\\\" } }}>",
        ctx
      });
      return block;
    }

    function create_fragment$7(ctx) {
      let div7;
      let current_block_type_index;
      let if_block0;
      let t0;
      let form;
      let div0;
      let label0;
      let t2;
      let updating_selected;
      let t3;
      let h30;
      let t4_value = formatText(
      /*$settings*/
      ctx[19].students, false, true) + "";
      let t4;
      let t5;
      let t6;
      let div1;
      let label1;
      let t8;
      let input0;
      let t9;
      let div2;
      let label2;
      let t11;
      let input1;
      let t12;
      let div3;
      let label3;
      let t14;
      let input2;
      let t15;
      let div4;
      let h31;
      let t16;
      let t17_value = formatText(
      /*$settings*/
      ctx[19].services, true, true) + "";
      let t17;
      let t18;
      let ul;
      let current_block_type_index_1;
      let if_block1;
      let t19;
      let h32;
      let t20_value = formatText(
      /*$settings*/
      ctx[19].students, false, true) + "";
      let t20;
      let t21;
      let t22;
      let div5;
      let t23;
      let textarea;
      let t24;
      let div6;
      let button0;
      let t26;
      let button1;
      let t28;
      let t29;
      let t30;
      let t31;
      let t32;
      let t33;
      let t34;
      let div7_intro;
      let div7_outro;
      let current;
      let dispose;
      const if_block_creators = [create_if_block_11, create_else_block_2];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (
        /*LOAnew*/
        ctx[0]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type(ctx);
      if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

      function datepicker_selected_binding(value) {
        /*datepicker_selected_binding*/
        ctx[39].call(null, value);
      }

      let datepicker_props = {
        style:
        /*style*/
        ctx[22],
        start: new Date(2020, 0, 1),
        end: new Date(Date.now()),
        $$slots: {
          default: [create_default_slot_8]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*dateUpdated*/
      ctx[12] !== void 0) {
        datepicker_props.selected =
        /*dateUpdated*/
        ctx[12];
      }

      const datepicker = new Datepicker({
        props: datepicker_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(datepicker, "selected", datepicker_selected_binding));
      const if_block_creators_1 = [create_if_block_10, create_else_block_1];
      const if_blocks_1 = [];

      function select_block_type_1(ctx, dirty) {
        if (
        /*selectedAccoms*/
        ctx[18].length > 0) return 0;
        return 1;
      }

      current_block_type_index_1 = select_block_type_1(ctx);
      if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
      let if_block2 =
      /*studentNotesHighlighted*/
      ctx[13] && create_if_block_9(ctx);
      let if_block3 =
      /*showSearchModal*/
      ctx[1] && create_if_block_8(ctx);
      let if_block4 =
      /*showOverwriteModal*/
      ctx[3] && create_if_block_7(ctx);
      let if_block5 =
      /*showSearchListModal*/
      ctx[2] && create_if_block_5(ctx);
      let if_block6 =
      /*showSavedModal*/
      ctx[4] && create_if_block_4(ctx);
      let if_block7 =
      /*showFormErrorModal*/
      ctx[5] && create_if_block_3(ctx);
      let if_block8 =
      /*showAccomsModal*/
      ctx[6] && create_if_block_2(ctx);
      let if_block9 =
      /*accomCreatorOpen*/
      ctx[15] && create_if_block$2(ctx);
      const block = {
        c: function create() {
          div7 = element("div");
          if_block0.c();
          t0 = space();
          form = element("form");
          div0 = element("div");
          label0 = element("label");
          label0.textContent = "Date";
          t2 = space();
          create_component(datepicker.$$.fragment);
          t3 = space();
          h30 = element("h3");
          t4 = text(t4_value);
          t5 = text(" Information");
          t6 = space();
          div1 = element("div");
          label1 = element("label");
          label1.textContent = "First Name";
          t8 = space();
          input0 = element("input");
          t9 = space();
          div2 = element("div");
          label2 = element("label");
          label2.textContent = "Last Name";
          t11 = space();
          input1 = element("input");
          t12 = space();
          div3 = element("div");
          label3 = element("label");
          label3.textContent = "ID#";
          t14 = space();
          input2 = element("input");
          t15 = space();
          div4 = element("div");
          h31 = element("h3");
          t16 = text("Approved ");
          t17 = text(t17_value);
          t18 = space();
          ul = element("ul");
          if_block1.c();
          t19 = space();
          h32 = element("h3");
          t20 = text(t20_value);
          t21 = text(" Notes");
          t22 = space();
          div5 = element("div");
          if (if_block2) if_block2.c();
          t23 = space();
          textarea = element("textarea");
          t24 = space();
          div6 = element("div");
          button0 = element("button");
          button0.textContent = "Issue";
          t26 = space();
          button1 = element("button");
          button1.textContent = "Clear";
          t28 = space();
          if (if_block3) if_block3.c();
          t29 = space();
          if (if_block4) if_block4.c();
          t30 = space();
          if (if_block5) if_block5.c();
          t31 = space();
          if (if_block6) if_block6.c();
          t32 = space();
          if (if_block7) if_block7.c();
          t33 = space();
          if (if_block8) if_block8.c();
          t34 = space();
          if (if_block9) if_block9.c();
          attr_dev(label0, "for", "issued");
          add_location(label0, file$7, 374, 12, 14205);
          attr_dev(div0, "class", "form-halves");
          add_location(div0, file$7, 373, 8, 14166);
          add_location(h30, file$7, 380, 8, 14575);
          attr_dev(label1, "for", "fname");
          add_location(label1, file$7, 382, 12, 14690);
          attr_dev(input0, "type", "text");
          attr_dev(input0, "id", "fname");
          attr_dev(input0, "maxlength", "100");
          attr_dev(input0, "class", "svelte-1tqh5hp");
          add_location(input0, file$7, 383, 12, 14741);
          attr_dev(div1, "class", "form-halves");
          add_location(div1, file$7, 381, 8, 14651);
          attr_dev(label2, "for", "lname");
          add_location(label2, file$7, 386, 12, 14879);
          attr_dev(input1, "type", "text");
          attr_dev(input1, "id", "lname");
          attr_dev(input1, "maxlength", "100");
          attr_dev(input1, "class", "svelte-1tqh5hp");
          add_location(input1, file$7, 387, 12, 14929);
          attr_dev(div2, "class", "form-halves");
          add_location(div2, file$7, 385, 8, 14840);
          attr_dev(label3, "for", "sid");
          add_location(label3, file$7, 390, 12, 15067);
          attr_dev(input2, "type", "text");
          attr_dev(input2, "id", "sid");
          attr_dev(input2, "maxlength", "20");
          attr_dev(input2, "class", "svelte-1tqh5hp");
          add_location(input2, file$7, 391, 12, 15109);
          attr_dev(div3, "class", "form-halves");
          add_location(div3, file$7, 389, 8, 15028);
          add_location(h31, file$7, 395, 12, 15256);
          attr_dev(ul, "id", "accoms-list");
          add_location(ul, file$7, 396, 12, 15332);
          set_style(div4, "position", "relative");
          add_location(div4, file$7, 394, 8, 15209);
          add_location(h32, file$7, 429, 8, 17222);
          attr_dev(textarea, "name", "student-notes");
          attr_dev(textarea, "id", "student-notes");
          attr_dev(textarea, "rows", "5");
          attr_dev(textarea, "maxlength", "250");
          attr_dev(textarea, "class", "svelte-1tqh5hp");
          add_location(textarea, file$7, 436, 12, 17566);
          attr_dev(div5, "id", "student-notes-container");
          attr_dev(div5, "class", "svelte-1tqh5hp");
          add_location(div5, file$7, 430, 8, 17292);
          attr_dev(button0, "class", "blue svelte-1tqh5hp");
          attr_dev(button0, "type", "submit");
          add_location(button0, file$7, 440, 12, 17877);
          attr_dev(button1, "type", "submit");
          attr_dev(button1, "class", "svelte-1tqh5hp");
          add_location(button1, file$7, 441, 12, 17979);
          attr_dev(div6, "class", "inline-buttons svelte-1tqh5hp");
          add_location(div6, file$7, 439, 8, 17835);
          add_location(form, file$7, 372, 4, 14150);
          set_style(div7, "position", "relative");
          add_location(div7, file$7, 360, 0, 13309);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div7, anchor);
          if_blocks[current_block_type_index].m(div7, null);
          append_dev(div7, t0);
          append_dev(div7, form);
          append_dev(form, div0);
          append_dev(div0, label0);
          append_dev(div0, t2);
          mount_component(datepicker, div0, null);
          append_dev(form, t3);
          append_dev(form, h30);
          append_dev(h30, t4);
          append_dev(h30, t5);
          append_dev(form, t6);
          append_dev(form, div1);
          append_dev(div1, label1);
          append_dev(div1, t8);
          append_dev(div1, input0);
          set_input_value(input0,
          /*student*/
          ctx[8].fname);
          append_dev(form, t9);
          append_dev(form, div2);
          append_dev(div2, label2);
          append_dev(div2, t11);
          append_dev(div2, input1);
          set_input_value(input1,
          /*student*/
          ctx[8].lname);
          append_dev(form, t12);
          append_dev(form, div3);
          append_dev(div3, label3);
          append_dev(div3, t14);
          append_dev(div3, input2);
          set_input_value(input2,
          /*student*/
          ctx[8]._id);
          append_dev(form, t15);
          append_dev(form, div4);
          append_dev(div4, h31);
          append_dev(h31, t16);
          append_dev(h31, t17);
          append_dev(div4, t18);
          append_dev(div4, ul);
          if_blocks_1[current_block_type_index_1].m(ul, null);
          append_dev(form, t19);
          append_dev(form, h32);
          append_dev(h32, t20);
          append_dev(h32, t21);
          append_dev(form, t22);
          append_dev(form, div5);
          if (if_block2) if_block2.m(div5, null);
          append_dev(div5, t23);
          append_dev(div5, textarea);
          /*textarea_binding*/

          ctx[46](textarea);
          set_input_value(textarea,
          /*studentNotes*/
          ctx[11]);
          append_dev(form, t24);
          append_dev(form, div6);
          append_dev(div6, button0);
          append_dev(div6, t26);
          append_dev(div6, button1);
          append_dev(div7, t28);
          if (if_block3) if_block3.m(div7, null);
          append_dev(div7, t29);
          if (if_block4) if_block4.m(div7, null);
          append_dev(div7, t30);
          if (if_block5) if_block5.m(div7, null);
          append_dev(div7, t31);
          if (if_block6) if_block6.m(div7, null);
          append_dev(div7, t32);
          if (if_block7) if_block7.m(div7, null);
          append_dev(div7, t33);
          if (if_block8) if_block8.m(div7, null);
          append_dev(div7, t34);
          if (if_block9) if_block9.m(div7, null);
          current = true;
          dispose = [listen_dev(input0, "input",
          /*input0_input_handler*/
          ctx[40]), listen_dev(input1, "input",
          /*input1_input_handler*/
          ctx[41]), listen_dev(input2, "input",
          /*input2_input_handler*/
          ctx[42]), listen_dev(textarea, "focus",
          /*focus_handler*/
          ctx[47], false, false, false), listen_dev(textarea, "blur",
          /*blur_handler*/
          ctx[48], false, false, false), listen_dev(textarea, "input",
          /*textarea_input_handler*/
          ctx[49]), listen_dev(button0, "click", prevent_default(
          /*click_handler_3*/
          ctx[50]), false, true, false), listen_dev(button1, "click", prevent_default(
          /*click_handler_4*/
          ctx[51]), false, true, false)];
        },
        p: function update(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block0 = if_blocks[current_block_type_index];

            if (!if_block0) {
              if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block0.c();
            }

            transition_in(if_block0, 1);
            if_block0.m(div7, t0);
          }

          const datepicker_changes = {};

          if (dirty[0] &
          /*dateUpdated*/
          4096 | dirty[2] &
          /*$$scope*/
          2097152) {
            datepicker_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_selected && dirty[0] &
          /*dateUpdated*/
          4096) {
            updating_selected = true;
            datepicker_changes.selected =
            /*dateUpdated*/
            ctx[12];
            add_flush_callback(() => updating_selected = false);
          }

          datepicker.$set(datepicker_changes);
          if ((!current || dirty[0] &
          /*$settings*/
          524288) && t4_value !== (t4_value = formatText(
          /*$settings*/
          ctx[19].students, false, true) + "")) set_data_dev(t4, t4_value);

          if (dirty[0] &
          /*student*/
          256 && input0.value !==
          /*student*/
          ctx[8].fname) {
            set_input_value(input0,
            /*student*/
            ctx[8].fname);
          }

          if (dirty[0] &
          /*student*/
          256 && input1.value !==
          /*student*/
          ctx[8].lname) {
            set_input_value(input1,
            /*student*/
            ctx[8].lname);
          }

          if (dirty[0] &
          /*student*/
          256 && input2.value !==
          /*student*/
          ctx[8]._id) {
            set_input_value(input2,
            /*student*/
            ctx[8]._id);
          }

          if ((!current || dirty[0] &
          /*$settings*/
          524288) && t17_value !== (t17_value = formatText(
          /*$settings*/
          ctx[19].services, true, true) + "")) set_data_dev(t17, t17_value);
          let previous_block_index_1 = current_block_type_index_1;
          current_block_type_index_1 = select_block_type_1(ctx);

          if (current_block_type_index_1 === previous_block_index_1) {
            if_blocks_1[current_block_type_index_1].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
              if_blocks_1[previous_block_index_1] = null;
            });
            check_outros();
            if_block1 = if_blocks_1[current_block_type_index_1];

            if (!if_block1) {
              if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
              if_block1.c();
            }

            transition_in(if_block1, 1);
            if_block1.m(ul, null);
          }

          if ((!current || dirty[0] &
          /*$settings*/
          524288) && t20_value !== (t20_value = formatText(
          /*$settings*/
          ctx[19].students, false, true) + "")) set_data_dev(t20, t20_value);

          if (
          /*studentNotesHighlighted*/
          ctx[13]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);
              transition_in(if_block2, 1);
            } else {
              if_block2 = create_if_block_9(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div5, t23);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          if (dirty[0] &
          /*studentNotes*/
          2048) {
            set_input_value(textarea,
            /*studentNotes*/
            ctx[11]);
          }

          if (
          /*showSearchModal*/
          ctx[1]) {
            if (if_block3) {
              if_block3.p(ctx, dirty);
              transition_in(if_block3, 1);
            } else {
              if_block3 = create_if_block_8(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div7, t29);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }

          if (
          /*showOverwriteModal*/
          ctx[3]) {
            if (if_block4) {
              if_block4.p(ctx, dirty);
              transition_in(if_block4, 1);
            } else {
              if_block4 = create_if_block_7(ctx);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(div7, t30);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }

          if (
          /*showSearchListModal*/
          ctx[2]) {
            if (if_block5) {
              if_block5.p(ctx, dirty);
              transition_in(if_block5, 1);
            } else {
              if_block5 = create_if_block_5(ctx);
              if_block5.c();
              transition_in(if_block5, 1);
              if_block5.m(div7, t31);
            }
          } else if (if_block5) {
            group_outros();
            transition_out(if_block5, 1, 1, () => {
              if_block5 = null;
            });
            check_outros();
          }

          if (
          /*showSavedModal*/
          ctx[4]) {
            if (if_block6) {
              if_block6.p(ctx, dirty);
              transition_in(if_block6, 1);
            } else {
              if_block6 = create_if_block_4(ctx);
              if_block6.c();
              transition_in(if_block6, 1);
              if_block6.m(div7, t32);
            }
          } else if (if_block6) {
            group_outros();
            transition_out(if_block6, 1, 1, () => {
              if_block6 = null;
            });
            check_outros();
          }

          if (
          /*showFormErrorModal*/
          ctx[5]) {
            if (if_block7) {
              if_block7.p(ctx, dirty);
              transition_in(if_block7, 1);
            } else {
              if_block7 = create_if_block_3(ctx);
              if_block7.c();
              transition_in(if_block7, 1);
              if_block7.m(div7, t33);
            }
          } else if (if_block7) {
            group_outros();
            transition_out(if_block7, 1, 1, () => {
              if_block7 = null;
            });
            check_outros();
          }

          if (
          /*showAccomsModal*/
          ctx[6]) {
            if (if_block8) {
              if_block8.p(ctx, dirty);
              transition_in(if_block8, 1);
            } else {
              if_block8 = create_if_block_2(ctx);
              if_block8.c();
              transition_in(if_block8, 1);
              if_block8.m(div7, t34);
            }
          } else if (if_block8) {
            group_outros();
            transition_out(if_block8, 1, 1, () => {
              if_block8 = null;
            });
            check_outros();
          }

          if (
          /*accomCreatorOpen*/
          ctx[15]) {
            if (if_block9) {
              if_block9.p(ctx, dirty);
              transition_in(if_block9, 1);
            } else {
              if_block9 = create_if_block$2(ctx);
              if_block9.c();
              transition_in(if_block9, 1);
              if_block9.m(div7, null);
            }
          } else if (if_block9) {
            group_outros();
            transition_out(if_block9, 1, 1, () => {
              if_block9 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(datepicker.$$.fragment, local);
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(if_block3);
          transition_in(if_block4);
          transition_in(if_block5);
          transition_in(if_block6);
          transition_in(if_block7);
          transition_in(if_block8);
          transition_in(if_block9);
          add_render_callback(() => {
            if (div7_outro) div7_outro.end(1);
            if (!div7_intro) div7_intro = create_in_transition(div7, fly, {
              x: 100,
              delay: 500
            });
            div7_intro.start();
          });
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(datepicker.$$.fragment, local);
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(if_block3);
          transition_out(if_block4);
          transition_out(if_block5);
          transition_out(if_block6);
          transition_out(if_block7);
          transition_out(if_block8);
          transition_out(if_block9);
          if (div7_intro) div7_intro.invalidate();
          div7_outro = create_out_transition(div7, fly, {
            x: 100
          });
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div7);
          if_blocks[current_block_type_index].d();
          destroy_component(datepicker);
          if_blocks_1[current_block_type_index_1].d();
          if (if_block2) if_block2.d();
          /*textarea_binding*/

          ctx[46](null);
          if (if_block3) if_block3.d();
          if (if_block4) if_block4.d();
          if (if_block5) if_block5.d();
          if (if_block6) if_block6.d();
          if (if_block7) if_block7.d();
          if (if_block8) if_block8.d();
          if (if_block9) if_block9.d();
          if (detaching && div7_outro) div7_outro.end();
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$7.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function flyModified(node, {
      delay = 0,
      duration = 400,
      easing = cubicOut$1,
      x = 0,
      y = 0,
      position = "relative"
    }) {
      const style = getComputedStyle(node);
      const opacity = +style.opacity;
      const transform = style.transform === "none" ? "" : style.transform;
      return {
        delay,
        duration,
        easing,
        css: t => `
            transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
            opacity: ${t * opacity};
            position: ${position};`
      };
    }

    function instance$7($$self, $$props, $$invalidate) {
      let $settings;
      validate_store(settings, "settings");
      component_subscribe($$self, settings, $$value => $$invalidate(19, $settings = $$value));
      const dispatch = createEventDispatcher();

      class extDate extends Date {
        addDays(days) {
          let date = new extDate(this.valueOf());
          date.setDate(date.getDate() + days);
          return date;
        }

      }

      let LOAnew = true;
      let abs1 = false;
      let abs2 = false;
      let showSearchModal = false;
      let showSearchListModal = false;
      let showOverwriteModal = false;
      let showSavedModal = false;
      let showFormErrorModal = false;
      let showAccomsModal = false;
      let searchResults = [];
      let student = {
        fname: "",
        lname: "",
        _id: ""
      };
      let searchStud = {
        fname: "",
        lname: "",
        _id: ""
      };
      let accoms = [];
      let studentNotes = "";
      let dateIssued = new Date(Date.now());
      let dateIssuedNext = dateIssued;
      let dateUpdated = new Date(Date.now());

      let sortAccoms = ev => {
        $$invalidate(18, selectedAccoms = ev.detail);
      };

      let studentNotesHighlighted = false;
      let months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "November", "December"];
      let style = "margin: 0;";
      let studentNotesTextarea = null;

      let writeNewLOA = () => {
        $$invalidate(1, showSearchModal = false);
        clear();
      };

      let searchForStudent = () => {
        $$invalidate(9, searchStud = {
          fname: "",
          lname: "",
          _id: ""
        });
        $$invalidate(1, showSearchModal = true);
      };

      let save = (upsert = false) => {
        $$invalidate(8, student.lname = student.lname.trim(), student);
        $$invalidate(8, student.fname = student.fname.trim(), student);
        $$invalidate(8, student.lname = student.lname.substr(0, 1).toUpperCase() + student.lname.substr(1), student);
        $$invalidate(8, student.fname = student.fname.substr(0, 1).toUpperCase() + student.fname.substr(1), student);

        if (student.fname.length < 2 || student.lname.length < 2 || student._id.length < 2 || accoms.length < 1) {
          $$invalidate(5, showFormErrorModal = true);
          return;
        }

        if (!upsert) {
          loadLOA(student, $settings.databasedir).then(existing => {
            if (existing != null) {
              $$invalidate(3, showOverwriteModal = true);
            } else {
              saveLOA({
                student,
                accoms: selectedAccoms,
                studentNotes,
                dateUpdated,
                dateIssued
              }, $settings.databasedir).then(() => {
                $$invalidate(4, showSavedModal = true);
              });
            }
          });
        } else saveLOA({
          student,
          accoms: selectedAccoms,
          studentNotes,
          dateUpdated,
          dateIssued
        }, $settings.databasedir).then(() => {
          $$invalidate(4, showSavedModal = true);
        });
      };

      let endSave = () => {
        clear();
        $$invalidate(4, showSavedModal = false);
      };

      let loadStudent = inputstudent => {
        loadLOA(inputstudent, $settings.databasedir).then(result => {
          $$invalidate(8, student = result.student || {});
          accoms.forEach(accom => {
            accom.selected = (() => {
              let returnVal = false;

              if (result.accoms) {
                result.accoms.forEach(raccom => {
                  if (accom._id == raccom._id) {
                    returnVal = true;
                  }
                });
              }

              return returnVal;
            })();
          });
          $$invalidate(18, selectedAccoms = $$invalidate(18, selectedAccoms = accoms.filter(accom => {
            return accom.selected === true;
          })));
          $$invalidate(11, studentNotes = result.studentNotes || "");
          $$invalidate(32, dateIssued = result.dateIssued || new Date());
          $$invalidate(12, dateUpdated = result.dateUpdated || new Date());
          $$invalidate(0, LOAnew = false);
          $$invalidate(2, showSearchListModal = false);
        });
      };

      let search = () => {
        searchLOA(searchStud, $settings.databasedir).then(value => {
          $$invalidate(7, searchResults = value);
          $$invalidate(1, showSearchModal = false);
          $$invalidate(2, showSearchListModal = true);
        });
      };

      let clear = () => {
        $$invalidate(8, student = {
          fname: "",
          lname: "",
          _id: ""
        });
        accoms.forEach(accom => {
          accom.selected = false;
        });
        $$invalidate(18, selectedAccoms = []);
        $$invalidate(11, studentNotes = "");
        $$invalidate(0, LOAnew = true);
        $$invalidate(32, dateIssued = new Date(Date.now()));
        $$invalidate(12, dateUpdated = new Date(Date.now()));
        dispatch("scrollUp");
      };

      onMount(() => {
        loadAccommodations($settings.databasedir).then(loadedAccoms => {
          $$invalidate(10, accoms = loadedAccoms);
        });
      });
      let accomCreatorOpen = false;
      let accomContentHighlighted = false;
      let newAccom = {};

      let addCustomAccom = () => {
        $$invalidate(6, showAccomsModal = false);
        $$invalidate(17, newAccom = {
          name: "",
          content: "",
          selected: true
        });
        $$invalidate(15, accomCreatorOpen = true);
      };

      let setCustomAccom = () => {
        $$invalidate(15, accomCreatorOpen = false);
        accoms.push({ ...newAccom,
          _id: accoms.length + 1
        });
        $$invalidate(10, accoms);
      };

      function datepicker_selected_binding(value) {
        dateUpdated = value;
        $$invalidate(12, dateUpdated);
      }

      function input0_input_handler() {
        student.fname = this.value;
        $$invalidate(8, student);
      }

      function input1_input_handler() {
        student.lname = this.value;
        $$invalidate(8, student);
      }

      function input2_input_handler() {
        student._id = this.value;
        $$invalidate(8, student);
      }

      const click_handler = item => {
        item.selected = false;
        $$invalidate(10, accoms);
      };

      const click_handler_1 = () => {
        $$invalidate(6, showAccomsModal = true);
      };

      const click_handler_2 = () => {
        $$invalidate(6, showAccomsModal = true);
      };

      function textarea_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(14, studentNotesTextarea = $$value);
        });
      }

      const focus_handler = () => {
        $$invalidate(13, studentNotesHighlighted = true);
      };

      const blur_handler = () => {
        $$invalidate(13, studentNotesHighlighted = false);
      };

      function textarea_input_handler() {
        studentNotes = this.value;
        $$invalidate(11, studentNotes);
      }

      const click_handler_3 = () => {
        save();
      };

      const click_handler_4 = () => {
        clear();
      };

      function input0_input_handler_1() {
        searchStud._id = this.value;
        $$invalidate(9, searchStud);
      }

      function input1_input_handler_1() {
        searchStud.fname = this.value;
        $$invalidate(9, searchStud);
      }

      function input2_input_handler_1() {
        searchStud.lname = this.value;
        $$invalidate(9, searchStud);
      }

      const forceClose_handler = () => {
        $$invalidate(1, showSearchModal = false);
      };

      const click_handler_5 = () => {
        save(true);
        $$invalidate(3, showOverwriteModal = false);
      };

      const click_handler_6 = () => {
        $$invalidate(3, showOverwriteModal = false);
      };

      const forceClose_handler_1 = () => {
        $$invalidate(3, showOverwriteModal = false);
      };

      const click_handler_7 = result => {
        loadStudent(result.student);
      };

      const click_handler_8 = () => {
        $$invalidate(2, showSearchListModal = false);
        $$invalidate(1, showSearchModal = true);
      };

      const forceClose_handler_2 = () => {
        $$invalidate(2, showSearchListModal = false);
      };

      const click_handler_9 = () => {
        endSave();
      };

      const forceClose_handler_3 = () => {
        endSave();
      };

      const click_handler_10 = () => {
        $$invalidate(5, showFormErrorModal = false);
      };

      const forceClose_handler_4 = () => {
        $$invalidate(5, showFormErrorModal = false);
      };

      const click_handler_11 = accom => {
        $$invalidate(10, accom.selected = !accom.selected, accoms);
      };

      const click_handler_12 = () => {
        $$invalidate(6, showAccomsModal = false);
      };

      const forceClose_handler_5 = () => {
        $$invalidate(6, showAccomsModal = false);
      };

      function input_input_handler() {
        newAccom.name = this.value;
        $$invalidate(17, newAccom);
      }

      function textarea_input_handler_1() {
        newAccom.content = this.value;
        $$invalidate(17, newAccom);
      }

      const focus_handler_1 = () => {
        $$invalidate(16, accomContentHighlighted = true);
      };

      const blur_handler_1 = () => {
        $$invalidate(16, accomContentHighlighted = false);
      };

      const click_handler_13 = () => {
        setCustomAccom();
      };

      const forceClose_handler_6 = () => {
        $$invalidate(15, accomCreatorOpen = false);
        $$invalidate(17, newAccom = {
          name: "",
          content: ""
        });
      };

      $$self.$capture_state = () => {
        return {};
      };

      $$self.$inject_state = $$props => {
        if ("LOAnew" in $$props) $$invalidate(0, LOAnew = $$props.LOAnew);
        if ("abs1" in $$props) abs1 = $$props.abs1;
        if ("abs2" in $$props) abs2 = $$props.abs2;
        if ("showSearchModal" in $$props) $$invalidate(1, showSearchModal = $$props.showSearchModal);
        if ("showSearchListModal" in $$props) $$invalidate(2, showSearchListModal = $$props.showSearchListModal);
        if ("showOverwriteModal" in $$props) $$invalidate(3, showOverwriteModal = $$props.showOverwriteModal);
        if ("showSavedModal" in $$props) $$invalidate(4, showSavedModal = $$props.showSavedModal);
        if ("showFormErrorModal" in $$props) $$invalidate(5, showFormErrorModal = $$props.showFormErrorModal);
        if ("showAccomsModal" in $$props) $$invalidate(6, showAccomsModal = $$props.showAccomsModal);
        if ("searchResults" in $$props) $$invalidate(7, searchResults = $$props.searchResults);
        if ("student" in $$props) $$invalidate(8, student = $$props.student);
        if ("searchStud" in $$props) $$invalidate(9, searchStud = $$props.searchStud);
        if ("accoms" in $$props) $$invalidate(10, accoms = $$props.accoms);
        if ("studentNotes" in $$props) $$invalidate(11, studentNotes = $$props.studentNotes);
        if ("dateIssued" in $$props) $$invalidate(32, dateIssued = $$props.dateIssued);
        if ("dateIssuedNext" in $$props) dateIssuedNext = $$props.dateIssuedNext;
        if ("dateUpdated" in $$props) $$invalidate(12, dateUpdated = $$props.dateUpdated);
        if ("sortAccoms" in $$props) $$invalidate(20, sortAccoms = $$props.sortAccoms);
        if ("studentNotesHighlighted" in $$props) $$invalidate(13, studentNotesHighlighted = $$props.studentNotesHighlighted);
        if ("months" in $$props) $$invalidate(21, months = $$props.months);
        if ("style" in $$props) $$invalidate(22, style = $$props.style);
        if ("studentNotesTextarea" in $$props) $$invalidate(14, studentNotesTextarea = $$props.studentNotesTextarea);
        if ("writeNewLOA" in $$props) $$invalidate(23, writeNewLOA = $$props.writeNewLOA);
        if ("searchForStudent" in $$props) $$invalidate(24, searchForStudent = $$props.searchForStudent);
        if ("save" in $$props) $$invalidate(25, save = $$props.save);
        if ("endSave" in $$props) $$invalidate(26, endSave = $$props.endSave);
        if ("loadStudent" in $$props) $$invalidate(27, loadStudent = $$props.loadStudent);
        if ("search" in $$props) $$invalidate(28, search = $$props.search);
        if ("clear" in $$props) $$invalidate(29, clear = $$props.clear);
        if ("accomCreatorOpen" in $$props) $$invalidate(15, accomCreatorOpen = $$props.accomCreatorOpen);
        if ("accomContentHighlighted" in $$props) $$invalidate(16, accomContentHighlighted = $$props.accomContentHighlighted);
        if ("newAccom" in $$props) $$invalidate(17, newAccom = $$props.newAccom);
        if ("addCustomAccom" in $$props) $$invalidate(30, addCustomAccom = $$props.addCustomAccom);
        if ("setCustomAccom" in $$props) $$invalidate(31, setCustomAccom = $$props.setCustomAccom);
        if ("selectedAccoms" in $$props) $$invalidate(18, selectedAccoms = $$props.selectedAccoms);
        if ("disableUpdated" in $$props) disableUpdated = $$props.disableUpdated;
        if ("$settings" in $$props) settings.set($settings = $$props.$settings);
      };

      let selectedAccoms;
      let disableUpdated;

      $$self.$$.update = () => {
        if ($$self.$$.dirty[1] &
        /*dateIssued*/
        2) {
           dateIssuedNext = new extDate(dateIssued).addDays(1);
        }

        if ($$self.$$.dirty[0] &
        /*accoms*/
        1024) {
           $$invalidate(18, selectedAccoms = accoms.length ? accoms.filter(accom => {
            return accom.selected === true;
          }) : []);
        }

        if ($$self.$$.dirty[1] &
        /*dateIssued*/
        2) {
           disableUpdated = dateIssued.getMonth() == new Date(Date.now()).getMonth() && dateIssued.getDate() == new Date(Date.now()).getDate() && dateIssued.getFullYear() == new Date(Date.now()).getFullYear();
        }
      };

      return [LOAnew, showSearchModal, showSearchListModal, showOverwriteModal, showSavedModal, showFormErrorModal, showAccomsModal, searchResults, student, searchStud, accoms, studentNotes, dateUpdated, studentNotesHighlighted, studentNotesTextarea, accomCreatorOpen, accomContentHighlighted, newAccom, selectedAccoms, $settings, sortAccoms, months, style, writeNewLOA, searchForStudent, save, endSave, loadStudent, search, clear, addCustomAccom, setCustomAccom, dateIssued, dateIssuedNext, disableUpdated, dispatch, extDate, abs1, abs2, datepicker_selected_binding, input0_input_handler, input1_input_handler, input2_input_handler, click_handler, click_handler_1, click_handler_2, textarea_binding, focus_handler, blur_handler, textarea_input_handler, click_handler_3, click_handler_4, input0_input_handler_1, input1_input_handler_1, input2_input_handler_1, forceClose_handler, click_handler_5, click_handler_6, forceClose_handler_1, click_handler_7, click_handler_8, forceClose_handler_2, click_handler_9, forceClose_handler_3, click_handler_10, forceClose_handler_4, click_handler_11, click_handler_12, forceClose_handler_5, input_input_handler, textarea_input_handler_1, focus_handler_1, blur_handler_1, click_handler_13, forceClose_handler_6];
    }

    class Write extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$7, create_fragment$7, safe_not_equal, {}, [-1, -1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Write",
          options,
          id: create_fragment$7.name
        });
      }

    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var fuse = createCommonjsModule(function (module, exports) {
    /*!
     * Fuse.js v3.4.6 - Lightweight fuzzy-search (http://fusejs.io)
     * 
     * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
     * All Rights Reserved. Apache Software License 2.0
     * 
     * http://www.apache.org/licenses/LICENSE-2.0
     */
    !function (e, t) {
       module.exports = t() ;
    }(commonjsGlobal, function () {
      return function (e) {
        var t = {};

        function n(r) {
          if (t[r]) return t[r].exports;
          var o = t[r] = {
            i: r,
            l: !1,
            exports: {}
          };
          return e[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports;
        }

        return n.m = e, n.c = t, n.d = function (e, t, r) {
          n.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: r
          });
        }, n.r = function (e) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
          }), Object.defineProperty(e, "__esModule", {
            value: !0
          });
        }, n.t = function (e, t) {
          if (1 & t && (e = n(e)), 8 & t) return e;
          if (4 & t && "object" == typeof e && e && e.__esModule) return e;
          var r = Object.create(null);
          if (n.r(r), Object.defineProperty(r, "default", {
            enumerable: !0,
            value: e
          }), 2 & t && "string" != typeof e) for (var o in e) n.d(r, o, function (t) {
            return e[t];
          }.bind(null, o));
          return r;
        }, n.n = function (e) {
          var t = e && e.__esModule ? function () {
            return e.default;
          } : function () {
            return e;
          };
          return n.d(t, "a", t), t;
        }, n.o = function (e, t) {
          return Object.prototype.hasOwnProperty.call(e, t);
        }, n.p = "", n(n.s = 1);
      }([function (e, t) {
        e.exports = function (e) {
          return Array.isArray ? Array.isArray(e) : "[object Array]" === Object.prototype.toString.call(e);
        };
      }, function (e, t, n) {
        function r(e) {
          return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
            return typeof e;
          } : function (e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
          })(e);
        }

        function o(e, t) {
          for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
          }
        }

        var i = n(2),
            a = n(8),
            s = n(0),
            c = function () {
          function e(t, n) {
            var r = n.location,
                o = void 0 === r ? 0 : r,
                i = n.distance,
                s = void 0 === i ? 100 : i,
                c = n.threshold,
                h = void 0 === c ? .6 : c,
                l = n.maxPatternLength,
                u = void 0 === l ? 32 : l,
                f = n.caseSensitive,
                d = void 0 !== f && f,
                v = n.tokenSeparator,
                p = void 0 === v ? / +/g : v,
                g = n.findAllMatches,
                y = void 0 !== g && g,
                m = n.minMatchCharLength,
                k = void 0 === m ? 1 : m,
                S = n.id,
                x = void 0 === S ? null : S,
                b = n.keys,
                M = void 0 === b ? [] : b,
                _ = n.shouldSort,
                L = void 0 === _ || _,
                w = n.getFn,
                A = void 0 === w ? a : w,
                C = n.sortFn,
                I = void 0 === C ? function (e, t) {
              return e.score - t.score;
            } : C,
                O = n.tokenize,
                j = void 0 !== O && O,
                P = n.matchAllTokens,
                F = void 0 !== P && P,
                T = n.includeMatches,
                z = void 0 !== T && T,
                E = n.includeScore,
                K = void 0 !== E && E,
                $ = n.verbose,
                J = void 0 !== $ && $;
            !function (e, t) {
              if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
            }(this, e), this.options = {
              location: o,
              distance: s,
              threshold: h,
              maxPatternLength: u,
              isCaseSensitive: d,
              tokenSeparator: p,
              findAllMatches: y,
              minMatchCharLength: k,
              id: x,
              keys: M,
              includeMatches: z,
              includeScore: K,
              shouldSort: L,
              getFn: A,
              sortFn: I,
              verbose: J,
              tokenize: j,
              matchAllTokens: F
            }, this.setCollection(t);
          }

          var t, n;
          return t = e, (n = [{
            key: "setCollection",
            value: function (e) {
              return this.list = e, e;
            }
          }, {
            key: "search",
            value: function (e) {
              var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                limit: !1
              };

              this._log('---------\nSearch pattern: "'.concat(e, '"'));

              var n = this._prepareSearchers(e),
                  r = n.tokenSearchers,
                  o = n.fullSearcher,
                  i = this._search(r, o),
                  a = i.weights,
                  s = i.results;

              return this._computeScore(a, s), this.options.shouldSort && this._sort(s), t.limit && "number" == typeof t.limit && (s = s.slice(0, t.limit)), this._format(s);
            }
          }, {
            key: "_prepareSearchers",
            value: function () {
              var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                  t = [];
              if (this.options.tokenize) for (var n = e.split(this.options.tokenSeparator), r = 0, o = n.length; r < o; r += 1) t.push(new i(n[r], this.options));
              return {
                tokenSearchers: t,
                fullSearcher: new i(e, this.options)
              };
            }
          }, {
            key: "_search",
            value: function () {
              var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                  t = arguments.length > 1 ? arguments[1] : void 0,
                  n = this.list,
                  r = {},
                  o = [];

              if ("string" == typeof n[0]) {
                for (var i = 0, a = n.length; i < a; i += 1) this._analyze({
                  key: "",
                  value: n[i],
                  record: i,
                  index: i
                }, {
                  resultMap: r,
                  results: o,
                  tokenSearchers: e,
                  fullSearcher: t
                });

                return {
                  weights: null,
                  results: o
                };
              }

              for (var s = {}, c = 0, h = n.length; c < h; c += 1) for (var l = n[c], u = 0, f = this.options.keys.length; u < f; u += 1) {
                var d = this.options.keys[u];

                if ("string" != typeof d) {
                  if (s[d.name] = {
                    weight: 1 - d.weight || 1
                  }, d.weight <= 0 || d.weight > 1) throw new Error("Key weight has to be > 0 and <= 1");
                  d = d.name;
                } else s[d] = {
                  weight: 1
                };

                this._analyze({
                  key: d,
                  value: this.options.getFn(l, d),
                  record: l,
                  index: c
                }, {
                  resultMap: r,
                  results: o,
                  tokenSearchers: e,
                  fullSearcher: t
                });
              }

              return {
                weights: s,
                results: o
              };
            }
          }, {
            key: "_analyze",
            value: function (e, t) {
              var n = e.key,
                  r = e.arrayIndex,
                  o = void 0 === r ? -1 : r,
                  i = e.value,
                  a = e.record,
                  c = e.index,
                  h = t.tokenSearchers,
                  l = void 0 === h ? [] : h,
                  u = t.fullSearcher,
                  f = void 0 === u ? [] : u,
                  d = t.resultMap,
                  v = void 0 === d ? {} : d,
                  p = t.results,
                  g = void 0 === p ? [] : p;

              if (null != i) {
                var y = !1,
                    m = -1,
                    k = 0;

                if ("string" == typeof i) {
                  this._log("\nKey: ".concat("" === n ? "-" : n));

                  var S = f.search(i);

                  if (this._log('Full text: "'.concat(i, '", score: ').concat(S.score)), this.options.tokenize) {
                    for (var x = i.split(this.options.tokenSeparator), b = [], M = 0; M < l.length; M += 1) {
                      var _ = l[M];

                      this._log('\nPattern: "'.concat(_.pattern, '"'));

                      for (var L = !1, w = 0; w < x.length; w += 1) {
                        var A = x[w],
                            C = _.search(A),
                            I = {};

                        C.isMatch ? (I[A] = C.score, y = !0, L = !0, b.push(C.score)) : (I[A] = 1, this.options.matchAllTokens || b.push(1)), this._log('Token: "'.concat(A, '", score: ').concat(I[A]));
                      }

                      L && (k += 1);
                    }

                    m = b[0];

                    for (var O = b.length, j = 1; j < O; j += 1) m += b[j];

                    m /= O, this._log("Token score average:", m);
                  }

                  var P = S.score;
                  m > -1 && (P = (P + m) / 2), this._log("Score average:", P);
                  var F = !this.options.tokenize || !this.options.matchAllTokens || k >= l.length;

                  if (this._log("\nCheck Matches: ".concat(F)), (y || S.isMatch) && F) {
                    var T = v[c];
                    T ? T.output.push({
                      key: n,
                      arrayIndex: o,
                      value: i,
                      score: P,
                      matchedIndices: S.matchedIndices
                    }) : (v[c] = {
                      item: a,
                      output: [{
                        key: n,
                        arrayIndex: o,
                        value: i,
                        score: P,
                        matchedIndices: S.matchedIndices
                      }]
                    }, g.push(v[c]));
                  }
                } else if (s(i)) for (var z = 0, E = i.length; z < E; z += 1) this._analyze({
                  key: n,
                  arrayIndex: z,
                  value: i[z],
                  record: a,
                  index: c
                }, {
                  resultMap: v,
                  results: g,
                  tokenSearchers: l,
                  fullSearcher: f
                });
              }
            }
          }, {
            key: "_computeScore",
            value: function (e, t) {
              this._log("\n\nComputing score:\n");

              for (var n = 0, r = t.length; n < r; n += 1) {
                for (var o = t[n].output, i = o.length, a = 1, s = 1, c = 0; c < i; c += 1) {
                  var h = e ? e[o[c].key].weight : 1,
                      l = (1 === h ? o[c].score : o[c].score || .001) * h;
                  1 !== h ? s = Math.min(s, l) : (o[c].nScore = l, a *= l);
                }

                t[n].score = 1 === s ? a : s, this._log(t[n]);
              }
            }
          }, {
            key: "_sort",
            value: function (e) {
              this._log("\n\nSorting...."), e.sort(this.options.sortFn);
            }
          }, {
            key: "_format",
            value: function (e) {
              var t = [];

              if (this.options.verbose) {
                var n = [];
                this._log("\n\nOutput:\n\n", JSON.stringify(e, function (e, t) {
                  if ("object" === r(t) && null !== t) {
                    if (-1 !== n.indexOf(t)) return;
                    n.push(t);
                  }

                  return t;
                })), n = null;
              }

              var o = [];
              this.options.includeMatches && o.push(function (e, t) {
                var n = e.output;
                t.matches = [];

                for (var r = 0, o = n.length; r < o; r += 1) {
                  var i = n[r];

                  if (0 !== i.matchedIndices.length) {
                    var a = {
                      indices: i.matchedIndices,
                      value: i.value
                    };
                    i.key && (a.key = i.key), i.hasOwnProperty("arrayIndex") && i.arrayIndex > -1 && (a.arrayIndex = i.arrayIndex), t.matches.push(a);
                  }
                }
              }), this.options.includeScore && o.push(function (e, t) {
                t.score = e.score;
              });

              for (var i = 0, a = e.length; i < a; i += 1) {
                var s = e[i];

                if (this.options.id && (s.item = this.options.getFn(s.item, this.options.id)[0]), o.length) {
                  for (var c = {
                    item: s.item
                  }, h = 0, l = o.length; h < l; h += 1) o[h](s, c);

                  t.push(c);
                } else t.push(s.item);
              }

              return t;
            }
          }, {
            key: "_log",
            value: function () {
              var e;
              this.options.verbose && (e = console).log.apply(e, arguments);
            }
          }]) && o(t.prototype, n), e;
        }();

        e.exports = c;
      }, function (e, t, n) {
        function r(e, t) {
          for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
          }
        }

        var o = n(3),
            i = n(4),
            a = n(7),
            s = function () {
          function e(t, n) {
            var r = n.location,
                o = void 0 === r ? 0 : r,
                i = n.distance,
                s = void 0 === i ? 100 : i,
                c = n.threshold,
                h = void 0 === c ? .6 : c,
                l = n.maxPatternLength,
                u = void 0 === l ? 32 : l,
                f = n.isCaseSensitive,
                d = void 0 !== f && f,
                v = n.tokenSeparator,
                p = void 0 === v ? / +/g : v,
                g = n.findAllMatches,
                y = void 0 !== g && g,
                m = n.minMatchCharLength,
                k = void 0 === m ? 1 : m;
            !function (e, t) {
              if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
            }(this, e), this.options = {
              location: o,
              distance: s,
              threshold: h,
              maxPatternLength: u,
              isCaseSensitive: d,
              tokenSeparator: p,
              findAllMatches: y,
              minMatchCharLength: k
            }, this.pattern = this.options.isCaseSensitive ? t : t.toLowerCase(), this.pattern.length <= u && (this.patternAlphabet = a(this.pattern));
          }

          var t, n;
          return t = e, (n = [{
            key: "search",
            value: function (e) {
              if (this.options.isCaseSensitive || (e = e.toLowerCase()), this.pattern === e) return {
                isMatch: !0,
                score: 0,
                matchedIndices: [[0, e.length - 1]]
              };
              var t = this.options,
                  n = t.maxPatternLength,
                  r = t.tokenSeparator;
              if (this.pattern.length > n) return o(e, this.pattern, r);
              var a = this.options,
                  s = a.location,
                  c = a.distance,
                  h = a.threshold,
                  l = a.findAllMatches,
                  u = a.minMatchCharLength;
              return i(e, this.pattern, this.patternAlphabet, {
                location: s,
                distance: c,
                threshold: h,
                findAllMatches: l,
                minMatchCharLength: u
              });
            }
          }]) && r(t.prototype, n), e;
        }();

        e.exports = s;
      }, function (e, t) {
        var n = /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;

        e.exports = function (e, t) {
          var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : / +/g,
              o = new RegExp(t.replace(n, "\\$&").replace(r, "|")),
              i = e.match(o),
              a = !!i,
              s = [];
          if (a) for (var c = 0, h = i.length; c < h; c += 1) {
            var l = i[c];
            s.push([e.indexOf(l), l.length - 1]);
          }
          return {
            score: a ? .5 : 1,
            isMatch: a,
            matchedIndices: s
          };
        };
      }, function (e, t, n) {
        var r = n(5),
            o = n(6);

        e.exports = function (e, t, n, i) {
          for (var a = i.location, s = void 0 === a ? 0 : a, c = i.distance, h = void 0 === c ? 100 : c, l = i.threshold, u = void 0 === l ? .6 : l, f = i.findAllMatches, d = void 0 !== f && f, v = i.minMatchCharLength, p = void 0 === v ? 1 : v, g = s, y = e.length, m = u, k = e.indexOf(t, g), S = t.length, x = [], b = 0; b < y; b += 1) x[b] = 0;

          if (-1 !== k) {
            var M = r(t, {
              errors: 0,
              currentLocation: k,
              expectedLocation: g,
              distance: h
            });

            if (m = Math.min(M, m), -1 !== (k = e.lastIndexOf(t, g + S))) {
              var _ = r(t, {
                errors: 0,
                currentLocation: k,
                expectedLocation: g,
                distance: h
              });

              m = Math.min(_, m);
            }
          }

          k = -1;

          for (var L = [], w = 1, A = S + y, C = 1 << (S <= 31 ? S - 1 : 30), I = 0; I < S; I += 1) {
            for (var O = 0, j = A; O < j;) {
              r(t, {
                errors: I,
                currentLocation: g + j,
                expectedLocation: g,
                distance: h
              }) <= m ? O = j : A = j, j = Math.floor((A - O) / 2 + O);
            }

            A = j;
            var P = Math.max(1, g - j + 1),
                F = d ? y : Math.min(g + j, y) + S,
                T = Array(F + 2);
            T[F + 1] = (1 << I) - 1;

            for (var z = F; z >= P; z -= 1) {
              var E = z - 1,
                  K = n[e.charAt(E)];

              if (K && (x[E] = 1), T[z] = (T[z + 1] << 1 | 1) & K, 0 !== I && (T[z] |= (L[z + 1] | L[z]) << 1 | 1 | L[z + 1]), T[z] & C && (w = r(t, {
                errors: I,
                currentLocation: E,
                expectedLocation: g,
                distance: h
              })) <= m) {
                if (m = w, (k = E) <= g) break;
                P = Math.max(1, 2 * g - k);
              }
            }

            if (r(t, {
              errors: I + 1,
              currentLocation: g,
              expectedLocation: g,
              distance: h
            }) > m) break;
            L = T;
          }

          return {
            isMatch: k >= 0,
            score: 0 === w ? .001 : w,
            matchedIndices: o(x, p)
          };
        };
      }, function (e, t) {
        e.exports = function (e, t) {
          var n = t.errors,
              r = void 0 === n ? 0 : n,
              o = t.currentLocation,
              i = void 0 === o ? 0 : o,
              a = t.expectedLocation,
              s = void 0 === a ? 0 : a,
              c = t.distance,
              h = void 0 === c ? 100 : c,
              l = r / e.length,
              u = Math.abs(s - i);
          return h ? l + u / h : u ? 1 : l;
        };
      }, function (e, t) {
        e.exports = function () {
          for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = [], r = -1, o = -1, i = 0, a = e.length; i < a; i += 1) {
            var s = e[i];
            s && -1 === r ? r = i : s || -1 === r || ((o = i - 1) - r + 1 >= t && n.push([r, o]), r = -1);
          }

          return e[i - 1] && i - r >= t && n.push([r, i - 1]), n;
        };
      }, function (e, t) {
        e.exports = function (e) {
          for (var t = {}, n = e.length, r = 0; r < n; r += 1) t[e.charAt(r)] = 0;

          for (var o = 0; o < n; o += 1) t[e.charAt(o)] |= 1 << n - o - 1;

          return t;
        };
      }, function (e, t, n) {
        var r = n(0);

        e.exports = function (e, t) {
          return function e(t, n, o) {
            if (n) {
              var i = n.indexOf("."),
                  a = n,
                  s = null;
              -1 !== i && (a = n.slice(0, i), s = n.slice(i + 1));
              var c = t[a];
              if (null != c) if (s || "string" != typeof c && "number" != typeof c) {
                if (r(c)) for (var h = 0, l = c.length; h < l; h += 1) e(c[h], s, o);else s && e(c, s, o);
              } else o.push(c.toString());
            } else o.push(t);

            return o;
          }(e, t, []);
        };
      }]);
    });
    });

    var Fuse = unwrapExports(fuse);
    var fuse_1 = fuse.Fuse;

    /* src\Students.svelte generated by Svelte v3.17.1 */
    const file$8 = "src\\Students.svelte";

    function get_each_context$6(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[38] = list[i];
      return child_ctx;
    } // (1:0) <script>      import { onMount }


    function create_catch_block(ctx) {
      const block = {
        c: noop,
        m: noop,
        p: noop,
        i: noop,
        o: noop,
        d: noop
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_catch_block.name,
        type: "catch",
        source: "(1:0) <script>      import { onMount }",
        ctx
      });
      return block;
    } // (117:0) {:then}


    function create_then_block(ctx) {
      let div8;
      let div0;
      let h2;
      let t0_value = formatText(
      /*$settings*/
      ctx[9].students, true, true) + "";
      let t0;
      let t1;
      let div1;
      let label;
      let t3;
      let input;
      let t4;
      let div2;
      let t6;
      let div3;
      let a0;
      let t7;
      let t8_value = formatText(
      /*$settings*/
      ctx[9].students, false, false) + "";
      let t8;
      let t9;
      let div7;
      let div4;
      let a1;
      let t11;
      let a2;
      let t13;
      let div5;
      let t14;
      let t15_value =
      /*resultsPerPage*/
      ctx[10] *
      /*page*/
      ctx[5] + 1 + "";
      let t15;
      let t16;
      let t17_value = (
      /*resultsPerPage*/
      ctx[10] *
      /*page*/
      ctx[5] +
      /*resultsPerPage*/
      ctx[10] <
      /*studentCount*/
      ctx[6] ?
      /*studentCount*/
      ctx[6] *
      /*page*/
      ctx[5] +
      /*resultsPerPage*/
      ctx[10] :
      /*studentCount*/
      ctx[6]) + "";
      let t17;
      let t18;
      let div6;
      let a3;
      let t20;
      let a4;
      let t22;
      let div8_intro;
      let div8_outro;
      let current;
      let dispose;

      function select_block_type(ctx, dirty) {
        if (
        /*searchResults*/
        ctx[0].length) return create_if_block_3$1;
        return create_else_block$1;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          div8 = element("div");
          div0 = element("div");
          h2 = element("h2");
          t0 = text(t0_value);
          t1 = space();
          div1 = element("div");
          label = element("label");
          label.textContent = "Find:";
          t3 = space();
          input = element("input");
          t4 = space();
          div2 = element("div");
          div2.textContent = "Search by name or ID.";
          t6 = space();
          div3 = element("div");
          a0 = element("a");
          t7 = text("New ");
          t8 = text(t8_value);
          t9 = space();
          div7 = element("div");
          div4 = element("div");
          a1 = element("a");
          a1.textContent = "«";
          t11 = space();
          a2 = element("a");
          a2.textContent = "‹";
          t13 = space();
          div5 = element("div");
          t14 = text("Results ");
          t15 = text(t15_value);
          t16 = text(" - ");
          t17 = text(t17_value);
          t18 = space();
          div6 = element("div");
          a3 = element("a");
          a3.textContent = "›";
          t20 = space();
          a4 = element("a");
          a4.textContent = "»";
          t22 = space();
          if_block.c();
          add_location(h2, file$8, 119, 12, 4346);
          attr_dev(div0, "class", "switchable");
          add_location(div0, file$8, 118, 8, 4308);
          attr_dev(label, "for", "search");
          add_location(label, file$8, 122, 12, 4464);
          attr_dev(input, "type", "text");
          attr_dev(input, "id", "search");
          add_location(input, file$8, 123, 12, 4512);
          attr_dev(div1, "class", "form-halves");
          add_location(div1, file$8, 121, 8, 4425);
          add_location(div2, file$8, 125, 8, 4636);
          attr_dev(a0, "href", "newStud");
          add_location(a0, file$8, 127, 12, 4715);
          attr_dev(div3, "class", "mt-2 mb-1");
          add_location(div3, file$8, 126, 8, 4678);
          attr_dev(a1, "href", "firstpage");
          attr_dev(a1, "class", "svelte-1adafpz");
          add_location(a1, file$8, 132, 16, 4948);
          attr_dev(a2, "href", "prevpage");
          attr_dev(a2, "class", "svelte-1adafpz");
          add_location(a2, file$8, 133, 16, 5072);
          attr_dev(div4, "class", "controls svelte-1adafpz");
          add_location(div4, file$8, 131, 12, 4908);
          add_location(div5, file$8, 135, 12, 5235);
          attr_dev(a3, "href", "nextpage");
          attr_dev(a3, "class", "svelte-1adafpz");
          add_location(a3, file$8, 137, 16, 5451);
          attr_dev(a4, "href", "lastpage");
          attr_dev(a4, "class", "svelte-1adafpz");
          add_location(a4, file$8, 138, 16, 5678);
          attr_dev(div6, "class", "controls svelte-1adafpz");
          add_location(div6, file$8, 136, 12, 5411);
          attr_dev(div7, "class", "pagination svelte-1adafpz");
          add_location(div7, file$8, 130, 8, 4870);
          set_style(div8, "position", "relative");
          add_location(div8, file$8, 117, 4, 4216);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div8, anchor);
          append_dev(div8, div0);
          append_dev(div0, h2);
          append_dev(h2, t0);
          append_dev(div8, t1);
          append_dev(div8, div1);
          append_dev(div1, label);
          append_dev(div1, t3);
          append_dev(div1, input);
          /*input_binding*/

          ctx[19](input);
          append_dev(div8, t4);
          append_dev(div8, div2);
          append_dev(div8, t6);
          append_dev(div8, div3);
          append_dev(div3, a0);
          append_dev(a0, t7);
          append_dev(a0, t8);
          append_dev(div8, t9);
          append_dev(div8, div7);
          append_dev(div7, div4);
          append_dev(div4, a1);
          append_dev(div4, t11);
          append_dev(div4, a2);
          append_dev(div7, t13);
          append_dev(div7, div5);
          append_dev(div5, t14);
          append_dev(div5, t15);
          append_dev(div5, t16);
          append_dev(div5, t17);
          append_dev(div7, t18);
          append_dev(div7, div6);
          append_dev(div6, a3);
          append_dev(div6, t20);
          append_dev(div6, a4);
          append_dev(div8, t22);
          if_block.m(div8, null);
          current = true;
          dispose = [listen_dev(input, "keyup",
          /*keyup_handler*/
          ctx[20], false, false, false), listen_dev(a0, "click", prevent_default(
          /*click_handler*/
          ctx[21]), false, true, false), listen_dev(a1, "click", prevent_default(
          /*click_handler_1*/
          ctx[22]), false, true, false), listen_dev(a2, "click", prevent_default(
          /*click_handler_2*/
          ctx[23]), false, true, false), listen_dev(a3, "click", prevent_default(
          /*click_handler_3*/
          ctx[24]), false, true, false), listen_dev(a4, "click", prevent_default(
          /*click_handler_4*/
          ctx[25]), false, true, false)];
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*$settings*/
          512) && t0_value !== (t0_value = formatText(
          /*$settings*/
          ctx[9].students, true, true) + "")) set_data_dev(t0, t0_value);
          if ((!current || dirty[0] &
          /*$settings*/
          512) && t8_value !== (t8_value = formatText(
          /*$settings*/
          ctx[9].students, false, false) + "")) set_data_dev(t8, t8_value);
          if ((!current || dirty[0] &
          /*page*/
          32) && t15_value !== (t15_value =
          /*resultsPerPage*/
          ctx[10] *
          /*page*/
          ctx[5] + 1 + "")) set_data_dev(t15, t15_value);
          if ((!current || dirty[0] &
          /*page, studentCount*/
          96) && t17_value !== (t17_value = (
          /*resultsPerPage*/
          ctx[10] *
          /*page*/
          ctx[5] +
          /*resultsPerPage*/
          ctx[10] <
          /*studentCount*/
          ctx[6] ?
          /*studentCount*/
          ctx[6] *
          /*page*/
          ctx[5] +
          /*resultsPerPage*/
          ctx[10] :
          /*studentCount*/
          ctx[6]) + "")) set_data_dev(t17, t17_value);

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(div8, null);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (div8_outro) div8_outro.end(1);
            if (!div8_intro) div8_intro = create_in_transition(div8, fly, {
              x: 100,
              delay: 500
            });
            div8_intro.start();
          });
          current = true;
        },
        o: function outro(local) {
          if (div8_intro) div8_intro.invalidate();
          div8_outro = create_out_transition(div8, fly, {
            x: 100
          });
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div8);
          /*input_binding*/

          ctx[19](null);
          if_block.d();
          if (detaching && div8_outro) div8_outro.end();
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_then_block.name,
        type: "then",
        source: "(117:0) {:then}",
        ctx
      });
      return block;
    } // (153:8) {:else}


    function create_else_block$1(ctx) {
      let p;
      let t0;
      let t1_value = formatText(
      /*$settings*/
      ctx[9].students, true, false) + "";
      let t1;
      let t2;
      const block = {
        c: function create() {
          p = element("p");
          t0 = text("No ");
          t1 = text(t1_value);
          t2 = text(" found. :-(");
          add_location(p, file$8, 153, 12, 6643);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
          append_dev(p, t0);
          append_dev(p, t1);
          append_dev(p, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$settings*/
          512 && t1_value !== (t1_value = formatText(
          /*$settings*/
          ctx[9].students, true, false) + "")) set_data_dev(t1, t1_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$1.name,
        type: "else",
        source: "(153:8) {:else}",
        ctx
      });
      return block;
    } // (143:8) {#if searchResults.length}


    function create_if_block_3$1(ctx) {
      let each_1_anchor;
      let each_value =
      /*searchResults*/
      ctx[0];
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*newStud, searchResults, studCreatorOpen, removeStud*/
          8323) {
            each_value =
            /*searchResults*/
            ctx[0];
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$6(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$6(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$1.name,
        type: "if",
        source: "(143:8) {#if searchResults.length}",
        ctx
      });
      return block;
    } // (144:12) {#each searchResults as loa}


    function create_each_block$6(ctx) {
      let div2;
      let h4;
      let t0_value =
      /*loa*/
      ctx[38].student.lname + ", " +
      /*loa*/
      ctx[38].student.fname + " (" +
      /*loa*/
      ctx[38].student._id + ")" + "";
      let t0;
      let t1;
      let p;
      let t2_value = abbreviate("Current accommodations: " + (
      /*loa*/
      ctx[38].accomsList &&
      /*loa*/
      ctx[38].accomsList.length ?
      /*loa*/
      ctx[38].accomsList.join(", ") : "none listed"), 200) + "";
      let t2;
      let t3;
      let a;
      let t4;
      let a_href_value;
      let t5;
      let div0;
      let t7;
      let div1;
      let t9;
      let dispose;

      function click_handler_5(...args) {
        return (
          /*click_handler_5*/
          ctx[26](
          /*loa*/
          ctx[38], ...args)
        );
      }

      function click_handler_6(...args) {
        return (
          /*click_handler_6*/
          ctx[27](
          /*loa*/
          ctx[38], ...args)
        );
      }

      const block = {
        c: function create() {
          div2 = element("div");
          h4 = element("h4");
          t0 = text(t0_value);
          t1 = space();
          p = element("p");
          t2 = text(t2_value);
          t3 = space();
          a = element("a");
          t4 = text("See record");
          t5 = space();
          div0 = element("div");
          div0.textContent = "×";
          t7 = space();
          div1 = element("div");
          div1.textContent = "✎";
          t9 = space();
          add_location(h4, file$8, 145, 20, 6017);
          add_location(p, file$8, 146, 20, 6125);
          attr_dev(a, "href", a_href_value = "#record/" +
          /*loa*/
          ctx[38].student._id);
          attr_dev(a, "class", "svelte-1adafpz");
          add_location(a, file$8, 147, 20, 6289);
          attr_dev(div0, "class", "close");
          add_location(div0, file$8, 148, 20, 6364);
          attr_dev(div1, "class", "close edit");
          add_location(div1, file$8, 149, 20, 6465);
          attr_dev(div2, "class", "student whitebox svelte-1adafpz");
          add_location(div2, file$8, 144, 16, 5965);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div2, anchor);
          append_dev(div2, h4);
          append_dev(h4, t0);
          append_dev(div2, t1);
          append_dev(div2, p);
          append_dev(p, t2);
          append_dev(div2, t3);
          append_dev(div2, a);
          append_dev(a, t4);
          append_dev(div2, t5);
          append_dev(div2, div0);
          append_dev(div2, t7);
          append_dev(div2, div1);
          append_dev(div2, t9);
          dispose = [listen_dev(div0, "click", click_handler_5, false, false, false), listen_dev(div1, "click", click_handler_6, false, false, false)];
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] &
          /*searchResults*/
          1 && t0_value !== (t0_value =
          /*loa*/
          ctx[38].student.lname + ", " +
          /*loa*/
          ctx[38].student.fname + " (" +
          /*loa*/
          ctx[38].student._id + ")" + "")) set_data_dev(t0, t0_value);
          if (dirty[0] &
          /*searchResults*/
          1 && t2_value !== (t2_value = abbreviate("Current accommodations: " + (
          /*loa*/
          ctx[38].accomsList &&
          /*loa*/
          ctx[38].accomsList.length ?
          /*loa*/
          ctx[38].accomsList.join(", ") : "none listed"), 200) + "")) set_data_dev(t2, t2_value);

          if (dirty[0] &
          /*searchResults*/
          1 && a_href_value !== (a_href_value = "#record/" +
          /*loa*/
          ctx[38].student._id)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div2);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$6.name,
        type: "each",
        source: "(144:12) {#each searchResults as loa}",
        ctx
      });
      return block;
    } // (115:26)       <div class='loading'>Loading...</div>  {:then}


    function create_pending_block(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = "Loading...";
          attr_dev(div, "class", "loading");
          add_location(div, file$8, 115, 4, 4164);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_pending_block.name,
        type: "pending",
        source: "(115:26)       <div class='loading'>Loading...</div>  {:then}",
        ctx
      });
      return block;
    } // (159:0) {#if studCreatorOpen}


    function create_if_block_2$1(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_2$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler*/
      ctx[32]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty[0] &
          /*studCreatorOpen, newStud, $settings*/
          642 | dirty[1] &
          /*$$scope*/
          1024) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$1.name,
        type: "if",
        source: "(159:0) {#if studCreatorOpen}",
        ctx
      });
      return block;
    } // (160:4) <Modal on:forceClose={()=>{ studCreatorOpen = false; newStud = { fname: "", lname: "", _id: "" } }}>


    function create_default_slot_2$1(ctx) {
      let h3;
      let t0_value = formatText(
      /*$settings*/
      ctx[9].students, false, true) + "";
      let t0;
      let t1;
      let t2;
      let form;
      let div0;
      let label0;
      let t4;
      let input0;
      let t5;
      let div1;
      let label1;
      let t7;
      let input1;
      let t8;
      let div2;
      let label2;
      let t9_value = formatText(
      /*$settings*/
      ctx[9].students, false, true) + "";
      let t9;
      let t10;
      let t11;
      let input2;
      let t12;
      let button;
      let dispose;
      const block = {
        c: function create() {
          h3 = element("h3");
          t0 = text(t0_value);
          t1 = text(" Details");
          t2 = space();
          form = element("form");
          div0 = element("div");
          label0 = element("label");
          label0.textContent = "First name";
          t4 = space();
          input0 = element("input");
          t5 = space();
          div1 = element("div");
          label1 = element("label");
          label1.textContent = "Last name";
          t7 = space();
          input1 = element("input");
          t8 = space();
          div2 = element("div");
          label2 = element("label");
          t9 = text(t9_value);
          t10 = text(" ID");
          t11 = space();
          input2 = element("input");
          t12 = space();
          button = element("button");
          button.textContent = "OK";
          add_location(h3, file$8, 160, 8, 6887);
          attr_dev(label0, "for", "fname");
          add_location(label0, file$8, 163, 16, 7041);
          attr_dev(input0, "type", "text");
          attr_dev(input0, "id", "fname");
          add_location(input0, file$8, 164, 16, 7096);
          attr_dev(div0, "class", "form-halves");
          add_location(div0, file$8, 162, 12, 6998);
          attr_dev(label1, "for", "fname");
          add_location(label1, file$8, 167, 16, 7230);
          attr_dev(input1, "type", "text");
          attr_dev(input1, "id", "fname");
          add_location(input1, file$8, 168, 16, 7284);
          attr_dev(div1, "class", "form-halves");
          add_location(div1, file$8, 166, 12, 7187);
          attr_dev(label2, "for", "id");
          add_location(label2, file$8, 171, 16, 7418);
          attr_dev(input2, "type", "text");
          attr_dev(input2, "id", "id");
          add_location(input2, file$8, 172, 16, 7508);
          attr_dev(div2, "class", "form-halves");
          add_location(div2, file$8, 170, 12, 7375);
          attr_dev(button, "class", "centered blue");
          attr_dev(button, "type", "submit");
          add_location(button, file$8, 175, 12, 7596);
          attr_dev(form, "id", "new-stud-form");
          add_location(form, file$8, 161, 8, 6959);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          append_dev(h3, t0);
          append_dev(h3, t1);
          insert_dev(target, t2, anchor);
          insert_dev(target, form, anchor);
          append_dev(form, div0);
          append_dev(div0, label0);
          append_dev(div0, t4);
          append_dev(div0, input0);
          set_input_value(input0,
          /*newStud*/
          ctx[7].fname);
          append_dev(form, t5);
          append_dev(form, div1);
          append_dev(div1, label1);
          append_dev(div1, t7);
          append_dev(div1, input1);
          set_input_value(input1,
          /*newStud*/
          ctx[7].lname);
          append_dev(form, t8);
          append_dev(form, div2);
          append_dev(div2, label2);
          append_dev(label2, t9);
          append_dev(label2, t10);
          append_dev(div2, t11);
          append_dev(div2, input2);
          set_input_value(input2,
          /*newStud*/
          ctx[7]._id);
          append_dev(form, t12);
          append_dev(form, button);
          dispose = [listen_dev(input0, "input",
          /*input0_input_handler*/
          ctx[28]), listen_dev(input1, "input",
          /*input1_input_handler*/
          ctx[29]), listen_dev(input2, "input",
          /*input2_input_handler*/
          ctx[30]), listen_dev(button, "click", prevent_default(
          /*click_handler_7*/
          ctx[31]), false, true, false)];
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$settings*/
          512 && t0_value !== (t0_value = formatText(
          /*$settings*/
          ctx[9].students, false, true) + "")) set_data_dev(t0, t0_value);

          if (dirty[0] &
          /*newStud*/
          128 && input0.value !==
          /*newStud*/
          ctx[7].fname) {
            set_input_value(input0,
            /*newStud*/
            ctx[7].fname);
          }

          if (dirty[0] &
          /*newStud*/
          128 && input1.value !==
          /*newStud*/
          ctx[7].lname) {
            set_input_value(input1,
            /*newStud*/
            ctx[7].lname);
          }

          if (dirty[0] &
          /*$settings*/
          512 && t9_value !== (t9_value = formatText(
          /*$settings*/
          ctx[9].students, false, true) + "")) set_data_dev(t9, t9_value);

          if (dirty[0] &
          /*newStud*/
          128 && input2.value !==
          /*newStud*/
          ctx[7]._id) {
            set_input_value(input2,
            /*newStud*/
            ctx[7]._id);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(form);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$1.name,
        type: "slot",
        source: "(160:4) <Modal on:forceClose={()=>{ studCreatorOpen = false; newStud = { fname: \\\"\\\", lname: \\\"\\\", _id: \\\"\\\" } }}>",
        ctx
      });
      return block;
    } // (181:0) {#if showConfirmModal}


    function create_if_block_1$1(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_1$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_1*/
      ctx[35]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty[0] &
          /*showConfirmModal, toDelete, $settings*/
          772 | dirty[1] &
          /*$$scope*/
          1024) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$1.name,
        type: "if",
        source: "(181:0) {#if showConfirmModal}",
        ctx
      });
      return block;
    } // (182:4) <Modal on:forceClose={()=>{ showConfirmModal = false; toDelete = "" }}>


    function create_default_slot_1$1(ctx) {
      let h3;
      let t1;
      let p;
      let t2;
      let t3_value = formatText(
      /*$settings*/
      ctx[9].students, false, false) + "";
      let t3;
      let t4;
      let t5_value = formatText(
      /*$settings*/
      ctx[9].students, false, false) + "";
      let t5;
      let t6;
      let t7_value = formatText(
      /*$settings*/
      ctx[9].services, false, false) + "";
      let t7;
      let t8;
      let t9;
      let div;
      let button0;
      let t11;
      let button1;
      let dispose;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "Are you sure?";
          t1 = space();
          p = element("p");
          t2 = text("If you delete this ");
          t3 = text(t3_value);
          t4 = text(", it will not be recoverable. This will not affect ");
          t5 = text(t5_value);
          t6 = text("'s committed ");
          t7 = text(t7_value);
          t8 = text(" history.");
          t9 = space();
          div = element("div");
          button0 = element("button");
          button0.textContent = "Delete it";
          t11 = space();
          button1 = element("button");
          button1.textContent = "Never mind";
          add_location(h3, file$8, 182, 8, 7868);
          add_location(p, file$8, 183, 8, 7900);
          attr_dev(button0, "class", "centered");
          attr_dev(button0, "type", "submit");
          add_location(button0, file$8, 185, 12, 8185);
          attr_dev(button1, "class", "centered blue");
          attr_dev(button1, "type", "submit");
          add_location(button1, file$8, 186, 12, 8315);
          attr_dev(div, "class", "align-ends");
          add_location(div, file$8, 184, 8, 8147);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, p, anchor);
          append_dev(p, t2);
          append_dev(p, t3);
          append_dev(p, t4);
          append_dev(p, t5);
          append_dev(p, t6);
          append_dev(p, t7);
          append_dev(p, t8);
          insert_dev(target, t9, anchor);
          insert_dev(target, div, anchor);
          append_dev(div, button0);
          append_dev(div, t11);
          append_dev(div, button1);
          dispose = [listen_dev(button0, "click", prevent_default(
          /*click_handler_8*/
          ctx[33]), false, true, false), listen_dev(button1, "click", prevent_default(
          /*click_handler_9*/
          ctx[34]), false, true, false)];
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$settings*/
          512 && t3_value !== (t3_value = formatText(
          /*$settings*/
          ctx[9].students, false, false) + "")) set_data_dev(t3, t3_value);
          if (dirty[0] &
          /*$settings*/
          512 && t5_value !== (t5_value = formatText(
          /*$settings*/
          ctx[9].students, false, false) + "")) set_data_dev(t5, t5_value);
          if (dirty[0] &
          /*$settings*/
          512 && t7_value !== (t7_value = formatText(
          /*$settings*/
          ctx[9].services, false, false) + "")) set_data_dev(t7, t7_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(p);
          if (detaching) detach_dev(t9);
          if (detaching) detach_dev(div);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$1.name,
        type: "slot",
        source: "(182:4) <Modal on:forceClose={()=>{ showConfirmModal = false; toDelete = \\\"\\\" }}>",
        ctx
      });
      return block;
    } // (192:0) {#if showDeleteConfirmModal}


    function create_if_block$3(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_2*/
      ctx[37]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty[0] &
          /*showDeleteConfirmModal*/
          8 | dirty[1] &
          /*$$scope*/
          1024) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$3.name,
        type: "if",
        source: "(192:0) {#if showDeleteConfirmModal}",
        ctx
      });
      return block;
    } // (193:4) <Modal on:forceClose={()=>{ showDeleteConfirmModal = false }}>


    function create_default_slot$2(ctx) {
      let h3;
      let t1;
      let p;
      let t3;
      let button;
      let dispose;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "All done!";
          t1 = space();
          p = element("p");
          p.textContent = "The indicated student has been removed from the list.";
          t3 = space();
          button = element("button");
          button.textContent = "OK";
          add_location(h3, file$8, 193, 8, 8602);
          add_location(p, file$8, 194, 8, 8630);
          attr_dev(button, "class", "centered blue");
          attr_dev(button, "type", "submit");
          add_location(button, file$8, 195, 8, 8700);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, p, anchor);
          insert_dev(target, t3, anchor);
          insert_dev(target, button, anchor);
          dispose = listen_dev(button, "click", prevent_default(
          /*click_handler_10*/
          ctx[36]), false, true, false);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(p);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(button);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$2.name,
        type: "slot",
        source: "(193:4) <Modal on:forceClose={()=>{ showDeleteConfirmModal = false }}>",
        ctx
      });
      return block;
    }

    function create_fragment$8(ctx) {
      let promise;
      let t0;
      let t1;
      let t2;
      let if_block2_anchor;
      let current;
      let info = {
        ctx,
        current: null,
        token: null,
        pending: create_pending_block,
        then: create_then_block,
        catch: create_catch_block,
        blocks: [,,,]
      };
      handle_promise(promise =
      /*searchTime*/
      ctx[12]("", 0), info);
      let if_block0 =
      /*studCreatorOpen*/
      ctx[1] && create_if_block_2$1(ctx);
      let if_block1 =
      /*showConfirmModal*/
      ctx[2] && create_if_block_1$1(ctx);
      let if_block2 =
      /*showDeleteConfirmModal*/
      ctx[3] && create_if_block$3(ctx);
      const block = {
        c: function create() {
          info.block.c();
          t0 = space();
          if (if_block0) if_block0.c();
          t1 = space();
          if (if_block1) if_block1.c();
          t2 = space();
          if (if_block2) if_block2.c();
          if_block2_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          info.block.m(target, info.anchor = anchor);

          info.mount = () => t0.parentNode;

          info.anchor = t0;
          insert_dev(target, t0, anchor);
          if (if_block0) if_block0.m(target, anchor);
          insert_dev(target, t1, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert_dev(target, t2, anchor);
          if (if_block2) if_block2.m(target, anchor);
          insert_dev(target, if_block2_anchor, anchor);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          {
            const child_ctx = ctx.slice();
            info.block.p(child_ctx, dirty);
          }

          if (
          /*studCreatorOpen*/
          ctx[1]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
              transition_in(if_block0, 1);
            } else {
              if_block0 = create_if_block_2$1(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(t1.parentNode, t1);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*showConfirmModal*/
          ctx[2]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
              transition_in(if_block1, 1);
            } else {
              if_block1 = create_if_block_1$1(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(t2.parentNode, t2);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (
          /*showDeleteConfirmModal*/
          ctx[3]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);
              transition_in(if_block2, 1);
            } else {
              if_block2 = create_if_block$3(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(info.block);
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(if_block2);
          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < 3; i += 1) {
            const block = info.blocks[i];
            transition_out(block);
          }

          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(if_block2);
          current = false;
        },
        d: function destroy(detaching) {
          info.block.d(detaching);
          info.token = null;
          info = null;
          if (detaching) detach_dev(t0);
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach_dev(t1);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach_dev(t2);
          if (if_block2) if_block2.d(detaching);
          if (detaching) detach_dev(if_block2_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$8.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
      let $settings;
      validate_store(settings, "settings");
      component_subscribe($$self, settings, $$value => $$invalidate(9, $settings = $$value));
      let studs = [];
      let searchResults = [];
      let studCreatorOpen = false;
      let showConfirmModal = false;
      let showDeleteConfirmModal = false;
      let searchTimeout = null;
      let searchBox = null;
      let studContentHighlighted = false;
      let resultsPerPage = 10;
      let page = 0;
      let studentCount = 0;
      let newStud = {
        fname: "",
        lname: "",
        _id: ""
      };
      let toDelete = "";
      let fuse = null;

      let save = () => {
        saveStudent(newStud, $settings.databasedir).then(() => {
          searchTime(searchBox.value, 0);
        });
      };

      let searchTime = (search, timeout = 600) => {
        return new Promise(resolve => {
          if (searchTimeout) clearTimeout(searchTimeout);
          searchTimeout = setTimeout(() => {
            loadStudents(resultsPerPage * page, resultsPerPage, search, $settings.databasedir).then(studsLoaded => {
              countStudents($settings.databasedir).then(count => {
                $$invalidate(6, studentCount = count);
              });
              studs = studsLoaded;
              $$invalidate(1, studCreatorOpen = false);
              $$invalidate(7, newStud = {
                fname: "",
                lname: "",
                _id: ""
              });
              fuse = new Fuse(studs, {
                keys: ["student.fname", "student.lname", "student._id"]
              });
              if (search == "") $$invalidate(0, searchResults = studs);else $$invalidate(0, searchResults = fuse.search(search));
              resolve(true);
            });
          }, timeout);
        });
      };

      let removeStud = id => {
        $$invalidate(8, toDelete = id);
        $$invalidate(2, showConfirmModal = true);
      };

      let deleteConfirm = id => {
        removeStudent(id, $settings.databasedir).then(() => {
          $$invalidate(8, toDelete = "");
          $$invalidate(3, showDeleteConfirmModal = true);
          $$invalidate(2, showConfirmModal = false);
          searchTime(searchBox.value, 0);
        });
      };

      function input_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(4, searchBox = $$value);
        });
      }

      const keyup_handler = () => {
        searchTime(searchBox.value);
      };

      const click_handler = () => {
        $$invalidate(1, studCreatorOpen = true);
      };

      const click_handler_1 = () => {
        $$invalidate(5, page = 0);
        searchTime(searchBox.value, 0);
      };

      const click_handler_2 = () => {
        page > 0 ? $$invalidate(5, page -= 1) : $$invalidate(5, page = 0);
        searchTime(searchBox.value, 0);
      };

      const click_handler_3 = () => {
        page < Math.floor(studentCount / resultsPerPage) ? $$invalidate(5, page += 1) : $$invalidate(5, page = Math.floor(studentCount / resultsPerPage));
        searchTime(searchBox.value, 0);
      };

      const click_handler_4 = () => {
        $$invalidate(5, page = Math.floor(studentCount / resultsPerPage));
        searchTime(searchBox.value, 0);
      };

      const click_handler_5 = loa => {
        removeStud(loa.student._id);
      };

      const click_handler_6 = loa => {
        $$invalidate(7, newStud = loa.student);
        $$invalidate(1, studCreatorOpen = true);
      };

      function input0_input_handler() {
        newStud.fname = this.value;
        $$invalidate(7, newStud);
      }

      function input1_input_handler() {
        newStud.lname = this.value;
        $$invalidate(7, newStud);
      }

      function input2_input_handler() {
        newStud._id = this.value;
        $$invalidate(7, newStud);
      }

      const click_handler_7 = () => {
        save();
        $$invalidate(1, studCreatorOpen = false);
      };

      const forceClose_handler = () => {
        $$invalidate(1, studCreatorOpen = false);
        $$invalidate(7, newStud = {
          fname: "",
          lname: "",
          _id: ""
        });
      };

      const click_handler_8 = () => {
        deleteConfirm(toDelete);
      };

      const click_handler_9 = () => {
        $$invalidate(2, showConfirmModal = false);
        $$invalidate(8, toDelete = "");
      };

      const forceClose_handler_1 = () => {
        $$invalidate(2, showConfirmModal = false);
        $$invalidate(8, toDelete = "");
      };

      const click_handler_10 = () => {
        $$invalidate(3, showDeleteConfirmModal = false);
      };

      const forceClose_handler_2 = () => {
        $$invalidate(3, showDeleteConfirmModal = false);
      };

      $$self.$capture_state = () => {
        return {};
      };

      $$self.$inject_state = $$props => {
        if ("studs" in $$props) studs = $$props.studs;
        if ("searchResults" in $$props) $$invalidate(0, searchResults = $$props.searchResults);
        if ("studCreatorOpen" in $$props) $$invalidate(1, studCreatorOpen = $$props.studCreatorOpen);
        if ("showConfirmModal" in $$props) $$invalidate(2, showConfirmModal = $$props.showConfirmModal);
        if ("showDeleteConfirmModal" in $$props) $$invalidate(3, showDeleteConfirmModal = $$props.showDeleteConfirmModal);
        if ("searchTimeout" in $$props) searchTimeout = $$props.searchTimeout;
        if ("searchBox" in $$props) $$invalidate(4, searchBox = $$props.searchBox);
        if ("studContentHighlighted" in $$props) studContentHighlighted = $$props.studContentHighlighted;
        if ("resultsPerPage" in $$props) $$invalidate(10, resultsPerPage = $$props.resultsPerPage);
        if ("page" in $$props) $$invalidate(5, page = $$props.page);
        if ("studentCount" in $$props) $$invalidate(6, studentCount = $$props.studentCount);
        if ("newStud" in $$props) $$invalidate(7, newStud = $$props.newStud);
        if ("toDelete" in $$props) $$invalidate(8, toDelete = $$props.toDelete);
        if ("fuse" in $$props) fuse = $$props.fuse;
        if ("save" in $$props) $$invalidate(11, save = $$props.save);
        if ("searchTime" in $$props) $$invalidate(12, searchTime = $$props.searchTime);
        if ("removeStud" in $$props) $$invalidate(13, removeStud = $$props.removeStud);
        if ("deleteConfirm" in $$props) $$invalidate(14, deleteConfirm = $$props.deleteConfirm);
        if ("$settings" in $$props) settings.set($settings = $$props.$settings);
      };

      return [searchResults, studCreatorOpen, showConfirmModal, showDeleteConfirmModal, searchBox, page, studentCount, newStud, toDelete, $settings, resultsPerPage, save, searchTime, removeStud, deleteConfirm, studs, searchTimeout, fuse, studContentHighlighted, input_binding, keyup_handler, click_handler, click_handler_1, click_handler_2, click_handler_3, click_handler_4, click_handler_5, click_handler_6, input0_input_handler, input1_input_handler, input2_input_handler, click_handler_7, forceClose_handler, click_handler_8, click_handler_9, forceClose_handler_1, click_handler_10, forceClose_handler_2];
    }

    class Students extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$8, create_fragment$8, safe_not_equal, {}, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Students",
          options,
          id: create_fragment$8.name
        });
      }

    }

    /* src\Accommodations.svelte generated by Svelte v3.17.1 */
    const file$9 = "src\\Accommodations.svelte";

    function get_each_context$7(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[32] = list[i];
      return child_ctx;
    } // (142:4) {:else}


    function create_else_block$2(ctx) {
      let p;
      let t0;
      let t1_value = formatText(
      /*$settings*/
      ctx[8].services, true, false) + "";
      let t1;
      let t2;
      const block = {
        c: function create() {
          p = element("p");
          t0 = text("No ");
          t1 = text(t1_value);
          t2 = text(" found. :-(");
          add_location(p, file$9, 142, 8, 5740);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
          append_dev(p, t0);
          append_dev(p, t1);
          append_dev(p, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$settings*/
          256 && t1_value !== (t1_value = formatText(
          /*$settings*/
          ctx[8].services, true, false) + "")) set_data_dev(t1, t1_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$2.name,
        type: "else",
        source: "(142:4) {:else}",
        ctx
      });
      return block;
    } // (133:4) {#if searchResults.length}


    function create_if_block_4$1(ctx) {
      let each_1_anchor;
      let each_value =
      /*searchResults*/
      ctx[0];
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*newAccom, searchResults, accomCreatorOpen, removeAccom*/
          2115) {
            each_value =
            /*searchResults*/
            ctx[0];
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$7(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$7(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$1.name,
        type: "if",
        source: "(133:4) {#if searchResults.length}",
        ctx
      });
      return block;
    } // (134:8) {#each searchResults as accom}


    function create_each_block$7(ctx) {
      let div2;
      let h4;
      let t0_value =
      /*accom*/
      ctx[32].name + "";
      let t0;
      let t1;
      let p;
      let t2_value = abbreviate(
      /*accom*/
      ctx[32].content, 200) + "";
      let t2;
      let t3;
      let div0;
      let t5;
      let div1;
      let t7;
      let dispose;

      function click_handler_1(...args) {
        return (
          /*click_handler_1*/
          ctx[19](
          /*accom*/
          ctx[32], ...args)
        );
      }

      function click_handler_2(...args) {
        return (
          /*click_handler_2*/
          ctx[20](
          /*accom*/
          ctx[32], ...args)
        );
      }

      const block = {
        c: function create() {
          div2 = element("div");
          h4 = element("h4");
          t0 = text(t0_value);
          t1 = space();
          p = element("p");
          t2 = text(t2_value);
          t3 = space();
          div0 = element("div");
          div0.textContent = "×";
          t5 = space();
          div1 = element("div");
          div1.textContent = "✎";
          t7 = space();
          add_location(h4, file$9, 135, 16, 5394);
          add_location(p, file$9, 136, 16, 5433);
          attr_dev(div0, "class", "close");
          add_location(div0, file$9, 137, 16, 5490);
          attr_dev(div1, "class", "close edit");
          add_location(div1, file$9, 138, 16, 5582);
          attr_dev(div2, "class", "accommodation whitebox");
          add_location(div2, file$9, 134, 12, 5340);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div2, anchor);
          append_dev(div2, h4);
          append_dev(h4, t0);
          append_dev(div2, t1);
          append_dev(div2, p);
          append_dev(p, t2);
          append_dev(div2, t3);
          append_dev(div2, div0);
          append_dev(div2, t5);
          append_dev(div2, div1);
          append_dev(div2, t7);
          dispose = [listen_dev(div0, "click", click_handler_1, false, false, false), listen_dev(div1, "click", click_handler_2, false, false, false)];
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] &
          /*searchResults*/
          1 && t0_value !== (t0_value =
          /*accom*/
          ctx[32].name + "")) set_data_dev(t0, t0_value);
          if (dirty[0] &
          /*searchResults*/
          1 && t2_value !== (t2_value = abbreviate(
          /*accom*/
          ctx[32].content, 200) + "")) set_data_dev(t2, t2_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div2);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$7.name,
        type: "each",
        source: "(134:8) {#each searchResults as accom}",
        ctx
      });
      return block;
    } // (147:0) {#if accomCreatorOpen}


    function create_if_block_2$2(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_2$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler*/
      ctx[26]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty[0] &
          /*accomCreatorOpen, newAccom, accomContentHighlighted, $settings*/
          354 | dirty[1] &
          /*$$scope*/
          16) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$2.name,
        type: "if",
        source: "(147:0) {#if accomCreatorOpen}",
        ctx
      });
      return block;
    } // (158:20) {#if accomContentHighlighted}


    function create_if_block_3$2(ctx) {
      let div;
      let t_value = (
      /*newAccom*/
      ctx[6].content.length ? 1200 -
      /*newAccom*/
      ctx[6].content.length : 1200) + "";
      let t;
      let div_transition;
      let current;
      const block = {
        c: function create() {
          div = element("div");
          t = text(t_value);
          attr_dev(div, "class", "remaining-characters");
          add_location(div, file$9, 158, 24, 6475);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t);
          current = true;
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*newAccom*/
          64) && t_value !== (t_value = (
          /*newAccom*/
          ctx[6].content.length ? 1200 -
          /*newAccom*/
          ctx[6].content.length : 1200) + "")) set_data_dev(t, t_value);
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (!div_transition) div_transition = create_bidirectional_transition(div, scale, {}, true);
            div_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          if (!div_transition) div_transition = create_bidirectional_transition(div, scale, {}, false);
          div_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching && div_transition) div_transition.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$2.name,
        type: "if",
        source: "(158:20) {#if accomContentHighlighted}",
        ctx
      });
      return block;
    } // (148:4) <Modal on:forceClose={()=>{ accomCreatorOpen = false; newAccom = { name: "", content: "" } }}>


    function create_default_slot_2$2(ctx) {
      let h3;
      let t0_value = formatText(
      /*$settings*/
      ctx[8].services, false, true) + "";
      let t0;
      let t1;
      let t2;
      let form;
      let div0;
      let label0;
      let t4;
      let input;
      let t5;
      let div2;
      let label1;
      let br;
      let t7;
      let div1;
      let t8;
      let textarea;
      let t9;
      let button;
      let current;
      let dispose;
      let if_block =
      /*accomContentHighlighted*/
      ctx[5] && create_if_block_3$2(ctx);
      const block = {
        c: function create() {
          h3 = element("h3");
          t0 = text(t0_value);
          t1 = text(" Details");
          t2 = space();
          form = element("form");
          div0 = element("div");
          label0 = element("label");
          label0.textContent = "Name";
          t4 = space();
          input = element("input");
          t5 = space();
          div2 = element("div");
          label1 = element("label");
          label1.textContent = "Content";
          br = element("br");
          t7 = space();
          div1 = element("div");
          if (if_block) if_block.c();
          t8 = space();
          textarea = element("textarea");
          t9 = space();
          button = element("button");
          button.textContent = "OK";
          attr_dev(h3, "class", "extend svelte-k0z4cv");
          add_location(h3, file$9, 148, 8, 5961);
          attr_dev(label0, "for", "name");
          attr_dev(label0, "class", "svelte-k0z4cv");
          add_location(label0, file$9, 151, 16, 6132);
          attr_dev(input, "type", "text");
          attr_dev(input, "id", "name");
          attr_dev(input, "class", "svelte-k0z4cv");
          add_location(input, file$9, 152, 16, 6180);
          attr_dev(div0, "class", "form-halves2 svelte-k0z4cv");
          add_location(div0, file$9, 150, 12, 6088);
          attr_dev(label1, "for", "content");
          add_location(label1, file$9, 155, 16, 6304);
          add_location(br, file$9, 155, 52, 6340);
          attr_dev(textarea, "type", "text");
          attr_dev(textarea, "id", "content");
          attr_dev(textarea, "rows", "5");
          attr_dev(textarea, "maxlength", "1200");
          attr_dev(textarea, "class", "svelte-k0z4cv");
          add_location(textarea, file$9, 162, 20, 6703);
          attr_dev(div1, "class", "accom-content-wrapper svelte-k0z4cv");
          add_location(div1, file$9, 156, 16, 6363);
          attr_dev(div2, "class", "in svelte-k0z4cv");
          add_location(div2, file$9, 154, 12, 6270);
          attr_dev(button, "class", "centered blue");
          attr_dev(button, "type", "submit");
          add_location(button, file$9, 166, 12, 6961);
          attr_dev(form, "id", "new-accom-form");
          attr_dev(form, "class", "svelte-k0z4cv");
          add_location(form, file$9, 149, 8, 6048);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          append_dev(h3, t0);
          append_dev(h3, t1);
          insert_dev(target, t2, anchor);
          insert_dev(target, form, anchor);
          append_dev(form, div0);
          append_dev(div0, label0);
          append_dev(div0, t4);
          append_dev(div0, input);
          set_input_value(input,
          /*newAccom*/
          ctx[6].name);
          append_dev(form, t5);
          append_dev(form, div2);
          append_dev(div2, label1);
          append_dev(div2, br);
          append_dev(div2, t7);
          append_dev(div2, div1);
          if (if_block) if_block.m(div1, null);
          append_dev(div1, t8);
          append_dev(div1, textarea);
          set_input_value(textarea,
          /*newAccom*/
          ctx[6].content);
          append_dev(form, t9);
          append_dev(form, button);
          current = true;
          dispose = [listen_dev(input, "input",
          /*input_input_handler*/
          ctx[21]), listen_dev(textarea, "input",
          /*textarea_input_handler*/
          ctx[22]), listen_dev(textarea, "focus",
          /*focus_handler*/
          ctx[23], false, false, false), listen_dev(textarea, "blur",
          /*blur_handler*/
          ctx[24], false, false, false), listen_dev(button, "click", prevent_default(
          /*click_handler_3*/
          ctx[25]), false, true, false)];
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*$settings*/
          256) && t0_value !== (t0_value = formatText(
          /*$settings*/
          ctx[8].services, false, true) + "")) set_data_dev(t0, t0_value);

          if (dirty[0] &
          /*newAccom*/
          64 && input.value !==
          /*newAccom*/
          ctx[6].name) {
            set_input_value(input,
            /*newAccom*/
            ctx[6].name);
          }

          if (
          /*accomContentHighlighted*/
          ctx[5]) {
            if (if_block) {
              if_block.p(ctx, dirty);
              transition_in(if_block, 1);
            } else {
              if_block = create_if_block_3$2(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div1, t8);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }

          if (dirty[0] &
          /*newAccom*/
          64) {
            set_input_value(textarea,
            /*newAccom*/
            ctx[6].content);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(form);
          if (if_block) if_block.d();
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$2.name,
        type: "slot",
        source: "(148:4) <Modal on:forceClose={()=>{ accomCreatorOpen = false; newAccom = { name: \\\"\\\", content: \\\"\\\" } }}>",
        ctx
      });
      return block;
    } // (172:0) {#if showConfirmModal}


    function create_if_block_1$2(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_1$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_1*/
      ctx[29]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty[0] &
          /*showConfirmModal, toDelete, $settings*/
          388 | dirty[1] &
          /*$$scope*/
          16) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$2.name,
        type: "if",
        source: "(172:0) {#if showConfirmModal}",
        ctx
      });
      return block;
    } // (173:4) <Modal on:forceClose={()=>{ showConfirmModal = false; toDelete = "" }}>


    function create_default_slot_1$2(ctx) {
      let h3;
      let t1;
      let p;
      let t2;
      let t3_value = formatText(
      /*$settings*/
      ctx[8].services, false, false) + "";
      let t3;
      let t4;
      let t5_value = formatText(
      /*$settings*/
      ctx[8].students, false, false) + "";
      let t5;
      let t6;
      let t7_value = formatText(
      /*$settings*/
      ctx[8].services, false, false) + "";
      let t7;
      let t8;
      let t9;
      let div;
      let button0;
      let t11;
      let button1;
      let dispose;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "Are you sure?";
          t1 = space();
          p = element("p");
          t2 = text("If you delete this ");
          t3 = text(t3_value);
          t4 = text(", it will not be recoverable. This will not affect ");
          t5 = text(t5_value);
          t6 = text("'s committed ");
          t7 = text(t7_value);
          t8 = text(" history.");
          t9 = space();
          div = element("div");
          button0 = element("button");
          button0.textContent = "Delete it";
          t11 = space();
          button1 = element("button");
          button1.textContent = "Never mind";
          add_location(h3, file$9, 173, 8, 7234);
          add_location(p, file$9, 174, 8, 7266);
          attr_dev(button0, "class", "centered");
          attr_dev(button0, "type", "submit");
          add_location(button0, file$9, 176, 12, 7551);
          attr_dev(button1, "class", "centered blue");
          attr_dev(button1, "type", "submit");
          add_location(button1, file$9, 177, 12, 7681);
          attr_dev(div, "class", "align-ends");
          add_location(div, file$9, 175, 8, 7513);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, p, anchor);
          append_dev(p, t2);
          append_dev(p, t3);
          append_dev(p, t4);
          append_dev(p, t5);
          append_dev(p, t6);
          append_dev(p, t7);
          append_dev(p, t8);
          insert_dev(target, t9, anchor);
          insert_dev(target, div, anchor);
          append_dev(div, button0);
          append_dev(div, t11);
          append_dev(div, button1);
          dispose = [listen_dev(button0, "click", prevent_default(
          /*click_handler_4*/
          ctx[27]), false, true, false), listen_dev(button1, "click", prevent_default(
          /*click_handler_5*/
          ctx[28]), false, true, false)];
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$settings*/
          256 && t3_value !== (t3_value = formatText(
          /*$settings*/
          ctx[8].services, false, false) + "")) set_data_dev(t3, t3_value);
          if (dirty[0] &
          /*$settings*/
          256 && t5_value !== (t5_value = formatText(
          /*$settings*/
          ctx[8].students, false, false) + "")) set_data_dev(t5, t5_value);
          if (dirty[0] &
          /*$settings*/
          256 && t7_value !== (t7_value = formatText(
          /*$settings*/
          ctx[8].services, false, false) + "")) set_data_dev(t7, t7_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(p);
          if (detaching) detach_dev(t9);
          if (detaching) detach_dev(div);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$2.name,
        type: "slot",
        source: "(173:4) <Modal on:forceClose={()=>{ showConfirmModal = false; toDelete = \\\"\\\" }}>",
        ctx
      });
      return block;
    } // (183:0) {#if showDeleteConfirmModal}


    function create_if_block$4(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_2*/
      ctx[31]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty[0] &
          /*showDeleteConfirmModal, $settings*/
          264 | dirty[1] &
          /*$$scope*/
          16) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$4.name,
        type: "if",
        source: "(183:0) {#if showDeleteConfirmModal}",
        ctx
      });
      return block;
    } // (184:4) <Modal on:forceClose={()=>{ showDeleteConfirmModal = false }}>


    function create_default_slot$3(ctx) {
      let h3;
      let t1;
      let p;
      let t2;
      let t3_value = formatText(
      /*$settings*/
      ctx[8].services, false, false) + "";
      let t3;
      let t4;
      let t5;
      let button;
      let dispose;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "All done!";
          t1 = space();
          p = element("p");
          t2 = text("The indicated ");
          t3 = text(t3_value);
          t4 = text(" has been removed from the list.");
          t5 = space();
          button = element("button");
          button.textContent = "OK";
          add_location(h3, file$9, 184, 8, 7968);
          add_location(p, file$9, 185, 8, 7996);
          attr_dev(button, "class", "centered blue");
          attr_dev(button, "type", "submit");
          add_location(button, file$9, 186, 8, 8105);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, p, anchor);
          append_dev(p, t2);
          append_dev(p, t3);
          append_dev(p, t4);
          insert_dev(target, t5, anchor);
          insert_dev(target, button, anchor);
          dispose = listen_dev(button, "click", prevent_default(
          /*click_handler_6*/
          ctx[30]), false, true, false);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$settings*/
          256 && t3_value !== (t3_value = formatText(
          /*$settings*/
          ctx[8].services, false, false) + "")) set_data_dev(t3, t3_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(p);
          if (detaching) detach_dev(t5);
          if (detaching) detach_dev(button);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$3.name,
        type: "slot",
        source: "(184:4) <Modal on:forceClose={()=>{ showDeleteConfirmModal = false }}>",
        ctx
      });
      return block;
    }

    function create_fragment$9(ctx) {
      let div4;
      let div0;
      let h2;
      let t0_value = formatText(
      /*$settings*/
      ctx[8].services, true, true) + "";
      let t0;
      let t1;
      let div1;
      let label;
      let t3;
      let input;
      let t4;
      let div2;
      let t5;
      let t6_value = formatText(
      /*$settings*/
      ctx[8].services, false, false) + "";
      let t6;
      let t7;
      let t8;
      let div3;
      let a;
      let t9;
      let t10_value = formatText(
      /*$settings*/
      ctx[8].services, false, false) + "";
      let t10;
      let t11;
      let div4_intro;
      let div4_outro;
      let t12;
      let t13;
      let t14;
      let if_block3_anchor;
      let current;
      let dispose;

      function select_block_type(ctx, dirty) {
        if (
        /*searchResults*/
        ctx[0].length) return create_if_block_4$1;
        return create_else_block$2;
      }

      let current_block_type = select_block_type(ctx);
      let if_block0 = current_block_type(ctx);
      let if_block1 =
      /*accomCreatorOpen*/
      ctx[1] && create_if_block_2$2(ctx);
      let if_block2 =
      /*showConfirmModal*/
      ctx[2] && create_if_block_1$2(ctx);
      let if_block3 =
      /*showDeleteConfirmModal*/
      ctx[3] && create_if_block$4(ctx);
      const block = {
        c: function create() {
          div4 = element("div");
          div0 = element("div");
          h2 = element("h2");
          t0 = text(t0_value);
          t1 = space();
          div1 = element("div");
          label = element("label");
          label.textContent = "Find:";
          t3 = space();
          input = element("input");
          t4 = space();
          div2 = element("div");
          t5 = text("Search by ");
          t6 = text(t6_value);
          t7 = text(" title or description.");
          t8 = space();
          div3 = element("div");
          a = element("a");
          t9 = text("New ");
          t10 = text(t10_value);
          t11 = space();
          if_block0.c();
          t12 = space();
          if (if_block1) if_block1.c();
          t13 = space();
          if (if_block2) if_block2.c();
          t14 = space();
          if (if_block3) if_block3.c();
          if_block3_anchor = empty();
          add_location(h2, file$9, 120, 8, 4711);
          attr_dev(div0, "class", "switchable");
          add_location(div0, file$9, 119, 4, 4677);
          attr_dev(label, "for", "search");
          add_location(label, file$9, 123, 8, 4817);
          attr_dev(input, "type", "text");
          attr_dev(input, "id", "search");
          add_location(input, file$9, 124, 8, 4861);
          attr_dev(div1, "class", "form-halves");
          add_location(div1, file$9, 122, 4, 4782);
          add_location(div2, file$9, 126, 4, 4977);
          attr_dev(a, "href", "newAccom");
          add_location(a, file$9, 129, 8, 5107);
          attr_dev(div3, "class", "mt-2 mb-1");
          add_location(div3, file$9, 128, 4, 5074);
          set_style(div4, "position", "relative");
          add_location(div4, file$9, 118, 0, 4589);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div4, anchor);
          append_dev(div4, div0);
          append_dev(div0, h2);
          append_dev(h2, t0);
          append_dev(div4, t1);
          append_dev(div4, div1);
          append_dev(div1, label);
          append_dev(div1, t3);
          append_dev(div1, input);
          /*input_binding*/

          ctx[16](input);
          append_dev(div4, t4);
          append_dev(div4, div2);
          append_dev(div2, t5);
          append_dev(div2, t6);
          append_dev(div2, t7);
          append_dev(div4, t8);
          append_dev(div4, div3);
          append_dev(div3, a);
          append_dev(a, t9);
          append_dev(a, t10);
          append_dev(div4, t11);
          if_block0.m(div4, null);
          insert_dev(target, t12, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert_dev(target, t13, anchor);
          if (if_block2) if_block2.m(target, anchor);
          insert_dev(target, t14, anchor);
          if (if_block3) if_block3.m(target, anchor);
          insert_dev(target, if_block3_anchor, anchor);
          current = true;
          dispose = [listen_dev(input, "keyup",
          /*keyup_handler*/
          ctx[17], false, false, false), listen_dev(a, "click", prevent_default(
          /*click_handler*/
          ctx[18]), false, true, false)];
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*$settings*/
          256) && t0_value !== (t0_value = formatText(
          /*$settings*/
          ctx[8].services, true, true) + "")) set_data_dev(t0, t0_value);
          if ((!current || dirty[0] &
          /*$settings*/
          256) && t6_value !== (t6_value = formatText(
          /*$settings*/
          ctx[8].services, false, false) + "")) set_data_dev(t6, t6_value);
          if ((!current || dirty[0] &
          /*$settings*/
          256) && t10_value !== (t10_value = formatText(
          /*$settings*/
          ctx[8].services, false, false) + "")) set_data_dev(t10, t10_value);

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0.d(1);
            if_block0 = current_block_type(ctx);

            if (if_block0) {
              if_block0.c();
              if_block0.m(div4, null);
            }
          }

          if (
          /*accomCreatorOpen*/
          ctx[1]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
              transition_in(if_block1, 1);
            } else {
              if_block1 = create_if_block_2$2(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(t13.parentNode, t13);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (
          /*showConfirmModal*/
          ctx[2]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);
              transition_in(if_block2, 1);
            } else {
              if_block2 = create_if_block_1$2(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(t14.parentNode, t14);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          if (
          /*showDeleteConfirmModal*/
          ctx[3]) {
            if (if_block3) {
              if_block3.p(ctx, dirty);
              transition_in(if_block3, 1);
            } else {
              if_block3 = create_if_block$4(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (div4_outro) div4_outro.end(1);
            if (!div4_intro) div4_intro = create_in_transition(div4, fly, {
              x: 100,
              delay: 500
            });
            div4_intro.start();
          });
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(if_block3);
          current = true;
        },
        o: function outro(local) {
          if (div4_intro) div4_intro.invalidate();
          div4_outro = create_out_transition(div4, fly, {
            x: 100
          });
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(if_block3);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div4);
          /*input_binding*/

          ctx[16](null);
          if_block0.d();
          if (detaching && div4_outro) div4_outro.end();
          if (detaching) detach_dev(t12);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach_dev(t13);
          if (if_block2) if_block2.d(detaching);
          if (detaching) detach_dev(t14);
          if (if_block3) if_block3.d(detaching);
          if (detaching) detach_dev(if_block3_anchor);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$9.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
      let $settings;
      validate_store(settings, "settings");
      component_subscribe($$self, settings, $$value => $$invalidate(8, $settings = $$value));
      let accoms = [];
      let searchResults = [];
      let accomCreatorOpen = false;
      let showConfirmModal = false;
      let showDeleteConfirmModal = false;
      let searchTimeout = null;
      let searchBox = null;
      let accomContentHighlighted = false;
      let newAccom = {
        name: "",
        content: ""
      };
      let toDelete = "";
      let fuse = null;

      let save = () => {
        saveAccommodation(newAccom, $settings.databasedir).then(() => {
          loadAccommodations($settings.databasedir).then(accomsLoaded => {
            accoms = accomsLoaded;
            $$invalidate(1, accomCreatorOpen = false);
            $$invalidate(6, newAccom = {
              name: "",
              content: ""
            });
            fuse = new Fuse(accoms, {
              keys: ["name", "content"]
            });
            searchTime(searchBox.value);
          });
        });
      };

      let searchTime = search => {
        if (searchTimeout) clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          if (search == "") $$invalidate(0, searchResults = accoms);else $$invalidate(0, searchResults = fuse.search(search));
        }, 600);
      };

      let removeAccom = id => {
        $$invalidate(7, toDelete = id);
        $$invalidate(2, showConfirmModal = true);
      };

      let deleteConfirm = id => {
        removeAccommodation(id, $settings.databasedir).then(() => {
          $$invalidate(7, toDelete = "");
          $$invalidate(3, showDeleteConfirmModal = true);
          $$invalidate(2, showConfirmModal = false);
          loadAccommodations($settings.databasedir).then(accomsLoaded => {
            accoms = accomsLoaded;
            $$invalidate(1, accomCreatorOpen = false);
            $$invalidate(6, newAccom = {
              name: "",
              content: ""
            });
            fuse = new Fuse(accoms, {
              keys: ["name", "content"]
            });
            searchTime(searchBox.value);
          });
        });
      };

      onMount(() => {
        loadAccommodations($settings.databasedir).then(accomsLoaded => {
          accoms = accomsLoaded;
          $$invalidate(0, searchResults = accoms);
          fuse = new Fuse(accoms, {
            keys: ["name", "content"]
          });
        });
      });

      function input_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(4, searchBox = $$value);
        });
      }

      const keyup_handler = () => {
        searchTime(searchBox.value);
      };

      const click_handler = () => {
        $$invalidate(1, accomCreatorOpen = true);
      };

      const click_handler_1 = accom => {
        removeAccom(accom._id);
      };

      const click_handler_2 = accom => {
        $$invalidate(6, newAccom = accom);
        $$invalidate(1, accomCreatorOpen = true);
      };

      function input_input_handler() {
        newAccom.name = this.value;
        $$invalidate(6, newAccom);
      }

      function textarea_input_handler() {
        newAccom.content = this.value;
        $$invalidate(6, newAccom);
      }

      const focus_handler = () => {
        $$invalidate(5, accomContentHighlighted = true);
      };

      const blur_handler = () => {
        $$invalidate(5, accomContentHighlighted = false);
      };

      const click_handler_3 = () => {
        save();
        $$invalidate(1, accomCreatorOpen = false);
      };

      const forceClose_handler = () => {
        $$invalidate(1, accomCreatorOpen = false);
        $$invalidate(6, newAccom = {
          name: "",
          content: ""
        });
      };

      const click_handler_4 = () => {
        deleteConfirm(toDelete);
      };

      const click_handler_5 = () => {
        $$invalidate(2, showConfirmModal = false);
        $$invalidate(7, toDelete = "");
      };

      const forceClose_handler_1 = () => {
        $$invalidate(2, showConfirmModal = false);
        $$invalidate(7, toDelete = "");
      };

      const click_handler_6 = () => {
        $$invalidate(3, showDeleteConfirmModal = false);
      };

      const forceClose_handler_2 = () => {
        $$invalidate(3, showDeleteConfirmModal = false);
      };

      $$self.$capture_state = () => {
        return {};
      };

      $$self.$inject_state = $$props => {
        if ("accoms" in $$props) accoms = $$props.accoms;
        if ("searchResults" in $$props) $$invalidate(0, searchResults = $$props.searchResults);
        if ("accomCreatorOpen" in $$props) $$invalidate(1, accomCreatorOpen = $$props.accomCreatorOpen);
        if ("showConfirmModal" in $$props) $$invalidate(2, showConfirmModal = $$props.showConfirmModal);
        if ("showDeleteConfirmModal" in $$props) $$invalidate(3, showDeleteConfirmModal = $$props.showDeleteConfirmModal);
        if ("searchTimeout" in $$props) searchTimeout = $$props.searchTimeout;
        if ("searchBox" in $$props) $$invalidate(4, searchBox = $$props.searchBox);
        if ("accomContentHighlighted" in $$props) $$invalidate(5, accomContentHighlighted = $$props.accomContentHighlighted);
        if ("newAccom" in $$props) $$invalidate(6, newAccom = $$props.newAccom);
        if ("toDelete" in $$props) $$invalidate(7, toDelete = $$props.toDelete);
        if ("fuse" in $$props) fuse = $$props.fuse;
        if ("save" in $$props) $$invalidate(9, save = $$props.save);
        if ("searchTime" in $$props) $$invalidate(10, searchTime = $$props.searchTime);
        if ("removeAccom" in $$props) $$invalidate(11, removeAccom = $$props.removeAccom);
        if ("deleteConfirm" in $$props) $$invalidate(12, deleteConfirm = $$props.deleteConfirm);
        if ("$settings" in $$props) settings.set($settings = $$props.$settings);
      };

      return [searchResults, accomCreatorOpen, showConfirmModal, showDeleteConfirmModal, searchBox, accomContentHighlighted, newAccom, toDelete, $settings, save, searchTime, removeAccom, deleteConfirm, accoms, searchTimeout, fuse, input_binding, keyup_handler, click_handler, click_handler_1, click_handler_2, input_input_handler, textarea_input_handler, focus_handler, blur_handler, click_handler_3, forceClose_handler, click_handler_4, click_handler_5, forceClose_handler_1, click_handler_6, forceClose_handler_2];
    }

    class Accommodations extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$9, create_fragment$9, safe_not_equal, {}, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Accommodations",
          options,
          id: create_fragment$9.name
        });
      }

    }

    var valueTypes = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var NewLine = '\n';
    exports.NewLine = NewLine;
    var ListType;

    (function (ListType) {
      ListType["Ordered"] = "ordered";
      ListType["Bullet"] = "bullet";
      ListType["Checked"] = "checked";
      ListType["Unchecked"] = "unchecked";
    })(ListType || (ListType = {}));

    exports.ListType = ListType;
    var ScriptType;

    (function (ScriptType) {
      ScriptType["Sub"] = "sub";
      ScriptType["Super"] = "super";
    })(ScriptType || (ScriptType = {}));

    exports.ScriptType = ScriptType;
    var DirectionType;

    (function (DirectionType) {
      DirectionType["Rtl"] = "rtl";
    })(DirectionType || (DirectionType = {}));

    exports.DirectionType = DirectionType;
    var AlignType;

    (function (AlignType) {
      AlignType["Left"] = "left";
      AlignType["Center"] = "center";
      AlignType["Right"] = "right";
      AlignType["Justify"] = "justify";
    })(AlignType || (AlignType = {}));

    exports.AlignType = AlignType;
    var DataType;

    (function (DataType) {
      DataType["Image"] = "image";
      DataType["Video"] = "video";
      DataType["Formula"] = "formula";
      DataType["Text"] = "text";
    })(DataType || (DataType = {}));

    exports.DataType = DataType;
    var GroupType;

    (function (GroupType) {
      GroupType["Block"] = "block";
      GroupType["InlineGroup"] = "inline-group";
      GroupType["List"] = "list";
      GroupType["Video"] = "video";
      GroupType["Table"] = "table";
    })(GroupType || (GroupType = {}));

    exports.GroupType = GroupType;
    });

    unwrapExports(valueTypes);
    var valueTypes_1 = valueTypes.NewLine;
    var valueTypes_2 = valueTypes.ListType;
    var valueTypes_3 = valueTypes.ScriptType;
    var valueTypes_4 = valueTypes.DirectionType;
    var valueTypes_5 = valueTypes.AlignType;
    var valueTypes_6 = valueTypes.DataType;
    var valueTypes_7 = valueTypes.GroupType;

    var InsertData = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var InsertDataQuill = function () {
      function InsertDataQuill(type, value) {
        this.type = type;
        this.value = value;
      }

      return InsertDataQuill;
    }();

    exports.InsertDataQuill = InsertDataQuill;

    var InsertDataCustom = function () {
      function InsertDataCustom(type, value) {
        this.type = type;
        this.value = value;
      }

      return InsertDataCustom;
    }();

    exports.InsertDataCustom = InsertDataCustom;
    });

    unwrapExports(InsertData);
    var InsertData_1 = InsertData.InsertDataQuill;
    var InsertData_2 = InsertData.InsertDataCustom;

    var DeltaInsertOp_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });





    var DeltaInsertOp = function () {
      function DeltaInsertOp(insertVal, attrs) {
        if (typeof insertVal === 'string') {
          insertVal = new InsertData.InsertDataQuill(valueTypes.DataType.Text, insertVal + '');
        }

        this.insert = insertVal;
        this.attributes = attrs || {};
      }

      DeltaInsertOp.createNewLineOp = function () {
        return new DeltaInsertOp(valueTypes.NewLine);
      };

      DeltaInsertOp.prototype.isContainerBlock = function () {
        var attrs = this.attributes;
        return !!(attrs.blockquote || attrs.list || attrs.table || attrs['code-block'] || attrs.header || attrs.align || attrs.direction || attrs.indent);
      };

      DeltaInsertOp.prototype.isBlockquote = function () {
        return !!this.attributes.blockquote;
      };

      DeltaInsertOp.prototype.isHeader = function () {
        return !!this.attributes.header;
      };

      DeltaInsertOp.prototype.isTable = function () {
        return !!this.attributes.table;
      };

      DeltaInsertOp.prototype.isSameHeaderAs = function (op) {
        return op.attributes.header === this.attributes.header && this.isHeader();
      };

      DeltaInsertOp.prototype.hasSameAdiAs = function (op) {
        return this.attributes.align === op.attributes.align && this.attributes.direction === op.attributes.direction && this.attributes.indent === op.attributes.indent;
      };

      DeltaInsertOp.prototype.hasSameIndentationAs = function (op) {
        return this.attributes.indent === op.attributes.indent;
      };

      DeltaInsertOp.prototype.hasHigherIndentThan = function (op) {
        return (Number(this.attributes.indent) || 0) > (Number(op.attributes.indent) || 0);
      };

      DeltaInsertOp.prototype.isInline = function () {
        return !(this.isContainerBlock() || this.isVideo() || this.isCustomBlock());
      };

      DeltaInsertOp.prototype.isCodeBlock = function () {
        return !!this.attributes['code-block'];
      };

      DeltaInsertOp.prototype.hasSameLangAs = function (op) {
        return this.attributes['code-block'] === op.attributes['code-block'];
      };

      DeltaInsertOp.prototype.isJustNewline = function () {
        return this.insert.value === valueTypes.NewLine;
      };

      DeltaInsertOp.prototype.isList = function () {
        return this.isOrderedList() || this.isBulletList() || this.isCheckedList() || this.isUncheckedList();
      };

      DeltaInsertOp.prototype.isOrderedList = function () {
        return this.attributes.list === valueTypes.ListType.Ordered;
      };

      DeltaInsertOp.prototype.isBulletList = function () {
        return this.attributes.list === valueTypes.ListType.Bullet;
      };

      DeltaInsertOp.prototype.isCheckedList = function () {
        return this.attributes.list === valueTypes.ListType.Checked;
      };

      DeltaInsertOp.prototype.isUncheckedList = function () {
        return this.attributes.list === valueTypes.ListType.Unchecked;
      };

      DeltaInsertOp.prototype.isACheckList = function () {
        return this.attributes.list == valueTypes.ListType.Unchecked || this.attributes.list === valueTypes.ListType.Checked;
      };

      DeltaInsertOp.prototype.isSameListAs = function (op) {
        return !!op.attributes.list && (this.attributes.list === op.attributes.list || op.isACheckList() && this.isACheckList());
      };

      DeltaInsertOp.prototype.isSameTableRowAs = function (op) {
        return !!op.isTable() && this.isTable() && this.attributes.table === op.attributes.table;
      };

      DeltaInsertOp.prototype.isText = function () {
        return this.insert.type === valueTypes.DataType.Text;
      };

      DeltaInsertOp.prototype.isImage = function () {
        return this.insert.type === valueTypes.DataType.Image;
      };

      DeltaInsertOp.prototype.isFormula = function () {
        return this.insert.type === valueTypes.DataType.Formula;
      };

      DeltaInsertOp.prototype.isVideo = function () {
        return this.insert.type === valueTypes.DataType.Video;
      };

      DeltaInsertOp.prototype.isLink = function () {
        return this.isText() && !!this.attributes.link;
      };

      DeltaInsertOp.prototype.isCustom = function () {
        return this.insert instanceof InsertData.InsertDataCustom;
      };

      DeltaInsertOp.prototype.isCustomBlock = function () {
        return this.isCustom() && !!this.attributes.renderAsBlock;
      };

      DeltaInsertOp.prototype.isMentions = function () {
        return this.isText() && !!this.attributes.mentions;
      };

      return DeltaInsertOp;
    }();

    exports.DeltaInsertOp = DeltaInsertOp;
    });

    unwrapExports(DeltaInsertOp_1);
    var DeltaInsertOp_2 = DeltaInsertOp_1.DeltaInsertOp;

    var MentionSanitizer_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });



    var MentionSanitizer = function () {
      function MentionSanitizer() {}

      MentionSanitizer.sanitize = function (dirtyObj, sanitizeOptions) {
        var cleanObj = {};

        if (!dirtyObj || typeof dirtyObj !== 'object') {
          return cleanObj;
        }

        if (dirtyObj.class && MentionSanitizer.IsValidClass(dirtyObj.class)) {
          cleanObj.class = dirtyObj.class;
        }

        if (dirtyObj.id && MentionSanitizer.IsValidId(dirtyObj.id)) {
          cleanObj.id = dirtyObj.id;
        }

        if (MentionSanitizer.IsValidTarget(dirtyObj.target + '')) {
          cleanObj.target = dirtyObj.target;
        }

        if (dirtyObj.avatar) {
          cleanObj.avatar = OpAttributeSanitizer_1.OpAttributeSanitizer.sanitizeLinkUsingOptions(dirtyObj.avatar + '', sanitizeOptions);
        }

        if (dirtyObj['end-point']) {
          cleanObj['end-point'] = OpAttributeSanitizer_1.OpAttributeSanitizer.sanitizeLinkUsingOptions(dirtyObj['end-point'] + '', sanitizeOptions);
        }

        if (dirtyObj.slug) {
          cleanObj.slug = dirtyObj.slug + '';
        }

        return cleanObj;
      };

      MentionSanitizer.IsValidClass = function (classAttr) {
        return !!classAttr.match(/^[a-zA-Z0-9_\-]{1,500}$/i);
      };

      MentionSanitizer.IsValidId = function (idAttr) {
        return !!idAttr.match(/^[a-zA-Z0-9_\-\:\.]{1,500}$/i);
      };

      MentionSanitizer.IsValidTarget = function (target) {
        return ['_self', '_blank', '_parent', '_top'].indexOf(target) > -1;
      };

      return MentionSanitizer;
    }();

    exports.MentionSanitizer = MentionSanitizer;
    });

    unwrapExports(MentionSanitizer_1);
    var MentionSanitizer_2 = MentionSanitizer_1.MentionSanitizer;

    var url = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function sanitize(str) {
      var val = str;
      val = val.replace(/^\s*/gm, '');
      var whiteList = /^((https?|s?ftp|file|blob|mailto|tel):|#|\/|data:image\/)/;

      if (whiteList.test(val)) {
        return val;
      }

      return 'unsafe:' + val;
    }

    exports.sanitize = sanitize;
    });

    unwrapExports(url);
    var url_1 = url.sanitize;

    var funcsHtml = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var EncodeTarget;

    (function (EncodeTarget) {
      EncodeTarget[EncodeTarget["Html"] = 0] = "Html";
      EncodeTarget[EncodeTarget["Url"] = 1] = "Url";
    })(EncodeTarget || (EncodeTarget = {}));

    function makeStartTag(tag, attrs) {
      if (attrs === void 0) {
        attrs = undefined;
      }

      if (!tag) {
        return '';
      }

      var attrsStr = '';

      if (attrs) {
        var arrAttrs = [].concat(attrs);
        attrsStr = arrAttrs.map(function (attr) {
          return attr.key + (attr.value ? '="' + attr.value + '"' : '');
        }).join(' ');
      }

      var closing = '>';

      if (tag === 'img' || tag === 'br') {
        closing = '/>';
      }

      return attrsStr ? "<" + tag + " " + attrsStr + closing : "<" + tag + closing;
    }

    exports.makeStartTag = makeStartTag;

    function makeEndTag(tag) {
      if (tag === void 0) {
        tag = '';
      }

      return tag && "</" + tag + ">" || '';
    }

    exports.makeEndTag = makeEndTag;

    function decodeHtml(str) {
      return encodeMappings(EncodeTarget.Html).reduce(decodeMapping, str);
    }

    exports.decodeHtml = decodeHtml;

    function encodeHtml(str, preventDoubleEncoding) {
      if (preventDoubleEncoding === void 0) {
        preventDoubleEncoding = true;
      }

      if (preventDoubleEncoding) {
        str = decodeHtml(str);
      }

      return encodeMappings(EncodeTarget.Html).reduce(encodeMapping, str);
    }

    exports.encodeHtml = encodeHtml;

    function encodeLink(str) {
      var linkMaps = encodeMappings(EncodeTarget.Url);
      var decoded = linkMaps.reduce(decodeMapping, str);
      return linkMaps.reduce(encodeMapping, decoded);
    }

    exports.encodeLink = encodeLink;

    function encodeMappings(mtype) {
      var maps = [['&', '&amp;'], ['<', '&lt;'], ['>', '&gt;'], ['"', '&quot;'], ["'", '&#x27;'], ['\\/', '&#x2F;'], ['\\(', '&#40;'], ['\\)', '&#41;']];

      if (mtype === EncodeTarget.Html) {
        return maps.filter(function (_a) {
          var v = _a[0],
              _ = _a[1];
          return v.indexOf('(') === -1 && v.indexOf(')') === -1;
        });
      } else {
        return maps.filter(function (_a) {
          var v = _a[0],
              _ = _a[1];
          return v.indexOf('/') === -1;
        });
      }
    }

    function encodeMapping(str, mapping) {
      return str.replace(new RegExp(mapping[0], 'g'), mapping[1]);
    }

    function decodeMapping(str, mapping) {
      return str.replace(new RegExp(mapping[1], 'g'), mapping[0].replace('\\', ''));
    }
    });

    unwrapExports(funcsHtml);
    var funcsHtml_1 = funcsHtml.makeStartTag;
    var funcsHtml_2 = funcsHtml.makeEndTag;
    var funcsHtml_3 = funcsHtml.decodeHtml;
    var funcsHtml_4 = funcsHtml.encodeHtml;
    var funcsHtml_5 = funcsHtml.encodeLink;

    var array = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function preferSecond(arr) {
      if (arr.length === 0) {
        return null;
      }

      return arr.length >= 2 ? arr[1] : arr[0];
    }

    exports.preferSecond = preferSecond;

    function flatten(arr) {
      return arr.reduce(function (pv, v) {
        return pv.concat(Array.isArray(v) ? flatten(v) : v);
      }, []);
    }

    exports.flatten = flatten;

    function find(arr, predicate) {
      if (Array.prototype.find) {
        return Array.prototype.find.call(arr, predicate);
      }

      for (var i = 0; i < arr.length; i++) {
        if (predicate(arr[i])) return arr[i];
      }

      return undefined;
    }

    exports.find = find;

    function groupConsecutiveElementsWhile(arr, predicate) {
      var groups = [];
      var currElm, currGroup;

      for (var i = 0; i < arr.length; i++) {
        currElm = arr[i];

        if (i > 0 && predicate(currElm, arr[i - 1])) {
          currGroup = groups[groups.length - 1];
          currGroup.push(currElm);
        } else {
          groups.push([currElm]);
        }
      }

      return groups.map(function (g) {
        return g.length === 1 ? g[0] : g;
      });
    }

    exports.groupConsecutiveElementsWhile = groupConsecutiveElementsWhile;

    function sliceFromReverseWhile(arr, startIndex, predicate) {
      var result = {
        elements: [],
        sliceStartsAt: -1
      };

      for (var i = startIndex; i >= 0; i--) {
        if (!predicate(arr[i])) {
          break;
        }

        result.sliceStartsAt = i;
        result.elements.unshift(arr[i]);
      }

      return result;
    }

    exports.sliceFromReverseWhile = sliceFromReverseWhile;

    function intersperse(arr, item) {
      return arr.reduce(function (pv, v, index) {
        pv.push(v);

        if (index < arr.length - 1) {
          pv.push(item);
        }

        return pv;
      }, []);
    }

    exports.intersperse = intersperse;
    });

    unwrapExports(array);
    var array_1 = array.preferSecond;
    var array_2 = array.flatten;
    var array_3 = array.find;
    var array_4 = array.groupConsecutiveElementsWhile;
    var array_5 = array.sliceFromReverseWhile;
    var array_6 = array.intersperse;

    var OpAttributeSanitizer_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });











    var OpAttributeSanitizer = function () {
      function OpAttributeSanitizer() {}

      OpAttributeSanitizer.sanitize = function (dirtyAttrs, sanitizeOptions) {
        var cleanAttrs = {};

        if (!dirtyAttrs || typeof dirtyAttrs !== 'object') {
          return cleanAttrs;
        }

        var booleanAttrs = ['bold', 'italic', 'underline', 'strike', 'code', 'blockquote', 'code-block', 'renderAsBlock'];
        var colorAttrs = ['background', 'color'];
        var font = dirtyAttrs.font,
            size = dirtyAttrs.size,
            link = dirtyAttrs.link,
            script = dirtyAttrs.script,
            list = dirtyAttrs.list,
            header = dirtyAttrs.header,
            align = dirtyAttrs.align,
            direction = dirtyAttrs.direction,
            indent = dirtyAttrs.indent,
            mentions = dirtyAttrs.mentions,
            mention = dirtyAttrs.mention,
            width = dirtyAttrs.width,
            target = dirtyAttrs.target,
            rel = dirtyAttrs.rel;
        var codeBlock = dirtyAttrs['code-block'];
        var sanitizedAttrs = booleanAttrs.concat(colorAttrs, ['font', 'size', 'link', 'script', 'list', 'header', 'align', 'direction', 'indent', 'mentions', 'mention', 'width', 'target', 'rel', 'code-block']);
        booleanAttrs.forEach(function (prop) {
          var v = dirtyAttrs[prop];

          if (v) {
            cleanAttrs[prop] = !!v;
          }
        });
        colorAttrs.forEach(function (prop) {
          var val = dirtyAttrs[prop];

          if (val && (OpAttributeSanitizer.IsValidHexColor(val + '') || OpAttributeSanitizer.IsValidColorLiteral(val + '') || OpAttributeSanitizer.IsValidRGBColor(val + ''))) {
            cleanAttrs[prop] = val;
          }
        });

        if (font && OpAttributeSanitizer.IsValidFontName(font + '')) {
          cleanAttrs.font = font;
        }

        if (size && OpAttributeSanitizer.IsValidSize(size + '')) {
          cleanAttrs.size = size;
        }

        if (width && OpAttributeSanitizer.IsValidWidth(width + '')) {
          cleanAttrs.width = width;
        }

        if (link) {
          cleanAttrs.link = OpAttributeSanitizer.sanitizeLinkUsingOptions(link + '', sanitizeOptions);
        }

        if (target && OpAttributeSanitizer.isValidTarget(target)) {
          cleanAttrs.target = target;
        }

        if (rel && OpAttributeSanitizer.IsValidRel(rel)) {
          cleanAttrs.rel = rel;
        }

        if (codeBlock) {
          if (OpAttributeSanitizer.IsValidLang(codeBlock)) {
            cleanAttrs['code-block'] = codeBlock;
          } else {
            cleanAttrs['code-block'] = !!codeBlock;
          }
        }

        if (script === valueTypes.ScriptType.Sub || valueTypes.ScriptType.Super === script) {
          cleanAttrs.script = script;
        }

        if (list === valueTypes.ListType.Bullet || list === valueTypes.ListType.Ordered || list === valueTypes.ListType.Checked || list === valueTypes.ListType.Unchecked) {
          cleanAttrs.list = list;
        }

        if (Number(header)) {
          cleanAttrs.header = Math.min(Number(header), 6);
        }

        if (array.find([valueTypes.AlignType.Center, valueTypes.AlignType.Right, valueTypes.AlignType.Justify, valueTypes.AlignType.Left], function (a) {
          return a === align;
        })) {
          cleanAttrs.align = align;
        }

        if (direction === valueTypes.DirectionType.Rtl) {
          cleanAttrs.direction = direction;
        }

        if (indent && Number(indent)) {
          cleanAttrs.indent = Math.min(Number(indent), 30);
        }

        if (mentions && mention) {
          var sanitizedMention = MentionSanitizer_1.MentionSanitizer.sanitize(mention, sanitizeOptions);

          if (Object.keys(sanitizedMention).length > 0) {
            cleanAttrs.mentions = !!mentions;
            cleanAttrs.mention = mention;
          }
        }

        return Object.keys(dirtyAttrs).reduce(function (cleaned, k) {
          if (sanitizedAttrs.indexOf(k) === -1) {
            cleaned[k] = dirtyAttrs[k];
          }

          return cleaned;
        }, cleanAttrs);
      };

      OpAttributeSanitizer.sanitizeLinkUsingOptions = function (link, options) {
        var sanitizerFn = function () {
          return undefined;
        };

        if (options && typeof options.urlSanitizer === 'function') {
          sanitizerFn = options.urlSanitizer;
        }

        var result = sanitizerFn(link);
        return typeof result === 'string' ? result : funcsHtml.encodeLink(url.sanitize(link));
      };

      OpAttributeSanitizer.IsValidHexColor = function (colorStr) {
        return !!colorStr.match(/^#([0-9A-F]{6}|[0-9A-F]{3})$/i);
      };

      OpAttributeSanitizer.IsValidColorLiteral = function (colorStr) {
        return !!colorStr.match(/^[a-z]{1,50}$/i);
      };

      OpAttributeSanitizer.IsValidRGBColor = function (colorStr) {
        var re = /^rgb\(((0|25[0-5]|2[0-4]\d|1\d\d|0?\d?\d),\s*){2}(0|25[0-5]|2[0-4]\d|1\d\d|0?\d?\d)\)$/i;
        return !!colorStr.match(re);
      };

      OpAttributeSanitizer.IsValidFontName = function (fontName) {
        return !!fontName.match(/^[a-z\s0-9\- ]{1,30}$/i);
      };

      OpAttributeSanitizer.IsValidSize = function (size) {
        return !!size.match(/^[a-z0-9\-]{1,20}$/i);
      };

      OpAttributeSanitizer.IsValidWidth = function (width) {
        return !!width.match(/^[0-9]*(px|em|%)?$/);
      };

      OpAttributeSanitizer.isValidTarget = function (target) {
        return !!target.match(/^[_a-zA-Z0-9\-]{1,50}$/);
      };

      OpAttributeSanitizer.IsValidRel = function (relStr) {
        return !!relStr.match(/^[a-zA-Z\s\-]{1,250}$/i);
      };

      OpAttributeSanitizer.IsValidLang = function (lang) {
        if (typeof lang === 'boolean') {
          return true;
        }

        return !!lang.match(/^[a-zA-Z\s\-\\\/\+]{1,50}$/i);
      };

      return OpAttributeSanitizer;
    }();

    exports.OpAttributeSanitizer = OpAttributeSanitizer;
    });

    unwrapExports(OpAttributeSanitizer_1);
    var OpAttributeSanitizer_2 = OpAttributeSanitizer_1.OpAttributeSanitizer;

    var string = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function tokenizeWithNewLines(str) {
      var NewLine = '\n';

      if (str === NewLine) {
        return [str];
      }

      var lines = str.split(NewLine);

      if (lines.length === 1) {
        return lines;
      }

      var lastIndex = lines.length - 1;
      return lines.reduce(function (pv, line, ind) {
        if (ind !== lastIndex) {
          if (line !== '') {
            pv = pv.concat(line, NewLine);
          } else {
            pv.push(NewLine);
          }
        } else if (line !== '') {
          pv.push(line);
        }

        return pv;
      }, []);
    }

    exports.tokenizeWithNewLines = tokenizeWithNewLines;
    });

    unwrapExports(string);
    var string_1 = string.tokenizeWithNewLines;

    var object = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function assign(target) {
      var sources = [];

      for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
      }

      if (target == null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var to = Object(target);

      for (var index = 0; index < sources.length; index++) {
        var nextSource = sources[index];

        if (nextSource != null) {
          for (var nextKey in nextSource) {
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }

      return to;
    }

    exports.assign = assign;
    });

    unwrapExports(object);
    var object_1 = object.assign;

    var InsertOpDenormalizer_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });







    var InsertOpDenormalizer = function () {
      function InsertOpDenormalizer() {}

      InsertOpDenormalizer.denormalize = function (op) {
        if (!op || typeof op !== 'object') {
          return [];
        }

        if (typeof op.insert === 'object' || op.insert === valueTypes.NewLine) {
          return [op];
        }

        var newlinedArray = string.tokenizeWithNewLines(op.insert + '');

        if (newlinedArray.length === 1) {
          return [op];
        }

        var nlObj = object.assign({}, op, {
          insert: valueTypes.NewLine
        });
        return newlinedArray.map(function (line) {
          if (line === valueTypes.NewLine) {
            return nlObj;
          }

          return object.assign({}, op, {
            insert: line
          });
        });
      };

      return InsertOpDenormalizer;
    }();

    exports.InsertOpDenormalizer = InsertOpDenormalizer;
    });

    unwrapExports(InsertOpDenormalizer_1);
    var InsertOpDenormalizer_2 = InsertOpDenormalizer_1.InsertOpDenormalizer;

    var InsertOpsConverter_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });











    var InsertOpsConverter = function () {
      function InsertOpsConverter() {}

      InsertOpsConverter.convert = function (deltaOps, options) {
        if (!Array.isArray(deltaOps)) {
          return [];
        }

        var denormalizedOps = [].concat.apply([], deltaOps.map(InsertOpDenormalizer_1.InsertOpDenormalizer.denormalize));
        var results = [];
        var insertVal, attributes;

        for (var _i = 0, denormalizedOps_1 = denormalizedOps; _i < denormalizedOps_1.length; _i++) {
          var op = denormalizedOps_1[_i];

          if (!op.insert) {
            continue;
          }

          insertVal = InsertOpsConverter.convertInsertVal(op.insert, options);

          if (!insertVal) {
            continue;
          }

          attributes = OpAttributeSanitizer_1.OpAttributeSanitizer.sanitize(op.attributes, options);
          results.push(new DeltaInsertOp_1.DeltaInsertOp(insertVal, attributes));
        }

        return results;
      };

      InsertOpsConverter.convertInsertVal = function (insertPropVal, sanitizeOptions) {
        if (typeof insertPropVal === 'string') {
          return new InsertData.InsertDataQuill(valueTypes.DataType.Text, insertPropVal);
        }

        if (!insertPropVal || typeof insertPropVal !== 'object') {
          return null;
        }

        var keys = Object.keys(insertPropVal);

        if (!keys.length) {
          return null;
        }

        return valueTypes.DataType.Image in insertPropVal ? new InsertData.InsertDataQuill(valueTypes.DataType.Image, OpAttributeSanitizer_1.OpAttributeSanitizer.sanitizeLinkUsingOptions(insertPropVal[valueTypes.DataType.Image] + '', sanitizeOptions)) : valueTypes.DataType.Video in insertPropVal ? new InsertData.InsertDataQuill(valueTypes.DataType.Video, OpAttributeSanitizer_1.OpAttributeSanitizer.sanitizeLinkUsingOptions(insertPropVal[valueTypes.DataType.Video] + '', sanitizeOptions)) : valueTypes.DataType.Formula in insertPropVal ? new InsertData.InsertDataQuill(valueTypes.DataType.Formula, insertPropVal[valueTypes.DataType.Formula]) : new InsertData.InsertDataCustom(keys[0], insertPropVal[keys[0]]);
      };

      return InsertOpsConverter;
    }();

    exports.InsertOpsConverter = InsertOpsConverter;
    });

    unwrapExports(InsertOpsConverter_1);
    var InsertOpsConverter_2 = InsertOpsConverter_1.InsertOpsConverter;

    var OpToHtmlConverter_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });











    var DEFAULT_INLINE_FONTS = {
      serif: 'font-family: Georgia, Times New Roman, serif',
      monospace: 'font-family: Monaco, Courier New, monospace'
    };
    exports.DEFAULT_INLINE_STYLES = {
      font: function (value) {
        return DEFAULT_INLINE_FONTS[value] || 'font-family:' + value;
      },
      size: {
        small: 'font-size: 0.75em',
        large: 'font-size: 1.5em',
        huge: 'font-size: 2.5em'
      },
      indent: function (value, op) {
        var indentSize = parseInt(value, 10) * 3;
        var side = op.attributes['direction'] === 'rtl' ? 'right' : 'left';
        return 'padding-' + side + ':' + indentSize + 'em';
      },
      direction: function (value, op) {
        if (value === 'rtl') {
          return 'direction:rtl' + (op.attributes['align'] ? '' : '; text-align:inherit');
        } else {
          return undefined;
        }
      }
    };

    var OpToHtmlConverter = function () {
      function OpToHtmlConverter(op, options) {
        this.op = op;
        this.options = object.assign({}, {
          classPrefix: 'ql',
          inlineStyles: undefined,
          encodeHtml: true,
          listItemTag: 'li',
          paragraphTag: 'p'
        }, options);
      }

      OpToHtmlConverter.prototype.prefixClass = function (className) {
        if (!this.options.classPrefix) {
          return className + '';
        }

        return this.options.classPrefix + '-' + className;
      };

      OpToHtmlConverter.prototype.getHtml = function () {
        var parts = this.getHtmlParts();
        return parts.openingTag + parts.content + parts.closingTag;
      };

      OpToHtmlConverter.prototype.getHtmlParts = function () {
        var _this = this;

        if (this.op.isJustNewline() && !this.op.isContainerBlock()) {
          return {
            openingTag: '',
            closingTag: '',
            content: valueTypes.NewLine
          };
        }

        var tags = this.getTags(),
            attrs = this.getTagAttributes();

        if (!tags.length && attrs.length) {
          tags.push('span');
        }

        var beginTags = [],
            endTags = [];
        var imgTag = 'img';

        var isImageLink = function (tag) {
          return tag === imgTag && !!_this.op.attributes.link;
        };

        for (var _i = 0, tags_1 = tags; _i < tags_1.length; _i++) {
          var tag = tags_1[_i];

          if (isImageLink(tag)) {
            beginTags.push(funcsHtml.makeStartTag('a', this.getLinkAttrs()));
          }

          beginTags.push(funcsHtml.makeStartTag(tag, attrs));
          endTags.push(tag === 'img' ? '' : funcsHtml.makeEndTag(tag));

          if (isImageLink(tag)) {
            endTags.push(funcsHtml.makeEndTag('a'));
          }

          attrs = [];
        }

        endTags.reverse();
        return {
          openingTag: beginTags.join(''),
          content: this.getContent(),
          closingTag: endTags.join('')
        };
      };

      OpToHtmlConverter.prototype.getContent = function () {
        if (this.op.isContainerBlock()) {
          return '';
        }

        if (this.op.isMentions()) {
          return this.op.insert.value;
        }

        var content = this.op.isFormula() || this.op.isText() ? this.op.insert.value : '';
        return this.options.encodeHtml && funcsHtml.encodeHtml(content) || content;
      };

      OpToHtmlConverter.prototype.getCssClasses = function () {
        var attrs = this.op.attributes;

        if (this.options.inlineStyles) {
          return [];
        }

        var propsArr = ['indent', 'align', 'direction', 'font', 'size'];

        if (this.options.allowBackgroundClasses) {
          propsArr.push('background');
        }

        return propsArr.filter(function (prop) {
          return !!attrs[prop];
        }).filter(function (prop) {
          return prop === 'background' ? OpAttributeSanitizer_1.OpAttributeSanitizer.IsValidColorLiteral(attrs[prop]) : true;
        }).map(function (prop) {
          return prop + '-' + attrs[prop];
        }).concat(this.op.isFormula() ? 'formula' : []).concat(this.op.isVideo() ? 'video' : []).concat(this.op.isImage() ? 'image' : []).map(this.prefixClass.bind(this));
      };

      OpToHtmlConverter.prototype.getCssStyles = function () {
        var _this = this;

        var attrs = this.op.attributes;
        var propsArr = [['color']];

        if (!!this.options.inlineStyles || !this.options.allowBackgroundClasses) {
          propsArr.push(['background', 'background-color']);
        }

        if (this.options.inlineStyles) {
          propsArr = propsArr.concat([['indent'], ['align', 'text-align'], ['direction'], ['font', 'font-family'], ['size']]);
        }

        return propsArr.filter(function (item) {
          return !!attrs[item[0]];
        }).map(function (item) {
          var attribute = item[0];
          var attrValue = attrs[attribute];
          var attributeConverter = _this.options.inlineStyles && _this.options.inlineStyles[attribute] || exports.DEFAULT_INLINE_STYLES[attribute];

          if (typeof attributeConverter === 'object') {
            return attributeConverter[attrValue];
          } else if (typeof attributeConverter === 'function') {
            var converterFn = attributeConverter;
            return converterFn(attrValue, _this.op);
          } else {
            return array.preferSecond(item) + ':' + attrValue;
          }
        }).filter(function (item) {
          return item !== undefined;
        });
      };

      OpToHtmlConverter.prototype.getTagAttributes = function () {
        if (this.op.attributes.code && !this.op.isLink()) {
          return [];
        }

        var makeAttr = this.makeAttr.bind(this);
        var classes = this.getCssClasses();
        var tagAttrs = classes.length ? [makeAttr('class', classes.join(' '))] : [];

        if (this.op.isImage()) {
          this.op.attributes.width && (tagAttrs = tagAttrs.concat(makeAttr('width', this.op.attributes.width)));
          return tagAttrs.concat(makeAttr('src', this.op.insert.value));
        }

        if (this.op.isACheckList()) {
          return tagAttrs.concat(makeAttr('data-checked', this.op.isCheckedList() ? 'true' : 'false'));
        }

        if (this.op.isFormula()) {
          return tagAttrs;
        }

        if (this.op.isVideo()) {
          return tagAttrs.concat(makeAttr('frameborder', '0'), makeAttr('allowfullscreen', 'true'), makeAttr('src', this.op.insert.value));
        }

        if (this.op.isMentions()) {
          var mention = this.op.attributes.mention;

          if (mention.class) {
            tagAttrs = tagAttrs.concat(makeAttr('class', mention.class));
          }

          if (mention['end-point'] && mention.slug) {
            tagAttrs = tagAttrs.concat(makeAttr('href', mention['end-point'] + '/' + mention.slug));
          } else {
            tagAttrs = tagAttrs.concat(makeAttr('href', 'about:blank'));
          }

          if (mention.target) {
            tagAttrs = tagAttrs.concat(makeAttr('target', mention.target));
          }

          return tagAttrs;
        }

        var styles = this.getCssStyles();

        if (styles.length) {
          tagAttrs.push(makeAttr('style', styles.join(';')));
        }

        if (this.op.isCodeBlock() && typeof this.op.attributes['code-block'] === 'string') {
          return tagAttrs.concat(makeAttr('data-language', this.op.attributes['code-block']));
        }

        if (this.op.isContainerBlock()) {
          return tagAttrs;
        }

        if (this.op.isLink()) {
          tagAttrs = tagAttrs.concat(this.getLinkAttrs());
        }

        return tagAttrs;
      };

      OpToHtmlConverter.prototype.makeAttr = function (k, v) {
        return {
          key: k,
          value: v
        };
      };

      OpToHtmlConverter.prototype.getLinkAttrs = function () {
        var tagAttrs = [];
        var targetForAll = OpAttributeSanitizer_1.OpAttributeSanitizer.isValidTarget(this.options.linkTarget || '') ? this.options.linkTarget : undefined;
        var relForAll = OpAttributeSanitizer_1.OpAttributeSanitizer.IsValidRel(this.options.linkRel || '') ? this.options.linkRel : undefined;
        var target = this.op.attributes.target || targetForAll;
        var rel = this.op.attributes.rel || relForAll;
        return tagAttrs.concat(this.makeAttr('href', this.op.attributes.link)).concat(target ? this.makeAttr('target', target) : []).concat(rel ? this.makeAttr('rel', rel) : []);
      };

      OpToHtmlConverter.prototype.getTags = function () {
        var attrs = this.op.attributes;

        if (!this.op.isText()) {
          return [this.op.isVideo() ? 'iframe' : this.op.isImage() ? 'img' : 'span'];
        }

        var positionTag = this.options.paragraphTag || 'p';
        var blocks = [['blockquote'], ['code-block', 'pre'], ['list', this.options.listItemTag], ['header'], ['align', positionTag], ['direction', positionTag], ['indent', positionTag]];

        for (var _i = 0, blocks_1 = blocks; _i < blocks_1.length; _i++) {
          var item = blocks_1[_i];
          var firstItem = item[0];

          if (attrs[firstItem]) {
            return firstItem === 'header' ? ['h' + attrs[firstItem]] : [array.preferSecond(item)];
          }
        }

        return [['link', 'a'], ['mentions', 'a'], ['script'], ['bold', 'strong'], ['italic', 'em'], ['strike', 's'], ['underline', 'u'], ['code']].filter(function (item) {
          return !!attrs[item[0]];
        }).map(function (item) {
          return item[0] === 'script' ? attrs[item[0]] === valueTypes.ScriptType.Sub ? 'sub' : 'sup' : array.preferSecond(item);
        });
      };

      return OpToHtmlConverter;
    }();

    exports.OpToHtmlConverter = OpToHtmlConverter;
    });

    unwrapExports(OpToHtmlConverter_1);
    var OpToHtmlConverter_2 = OpToHtmlConverter_1.DEFAULT_INLINE_STYLES;
    var OpToHtmlConverter_3 = OpToHtmlConverter_1.OpToHtmlConverter;

    var groupTypes = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var InlineGroup = function () {
      function InlineGroup(ops) {
        this.ops = ops;
      }

      return InlineGroup;
    }();

    exports.InlineGroup = InlineGroup;

    var SingleItem = function () {
      function SingleItem(op) {
        this.op = op;
      }

      return SingleItem;
    }();

    var VideoItem = function (_super) {
      __extends(VideoItem, _super);

      function VideoItem() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      return VideoItem;
    }(SingleItem);

    exports.VideoItem = VideoItem;

    var BlotBlock = function (_super) {
      __extends(BlotBlock, _super);

      function BlotBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      return BlotBlock;
    }(SingleItem);

    exports.BlotBlock = BlotBlock;

    var BlockGroup = function () {
      function BlockGroup(op, ops) {
        this.op = op;
        this.ops = ops;
      }

      return BlockGroup;
    }();

    exports.BlockGroup = BlockGroup;

    var ListGroup = function () {
      function ListGroup(items) {
        this.items = items;
      }

      return ListGroup;
    }();

    exports.ListGroup = ListGroup;

    var ListItem = function () {
      function ListItem(item, innerList) {
        if (innerList === void 0) {
          innerList = null;
        }

        this.item = item;
        this.innerList = innerList;
      }

      return ListItem;
    }();

    exports.ListItem = ListItem;

    var TableGroup = function () {
      function TableGroup(rows) {
        this.rows = rows;
      }

      return TableGroup;
    }();

    exports.TableGroup = TableGroup;

    var TableRow = function () {
      function TableRow(cells) {
        this.cells = cells;
      }

      return TableRow;
    }();

    exports.TableRow = TableRow;

    var TableCell = function () {
      function TableCell(item) {
        this.item = item;
      }

      return TableCell;
    }();

    exports.TableCell = TableCell;
    });

    unwrapExports(groupTypes);
    var groupTypes_1 = groupTypes.InlineGroup;
    var groupTypes_2 = groupTypes.VideoItem;
    var groupTypes_3 = groupTypes.BlotBlock;
    var groupTypes_4 = groupTypes.BlockGroup;
    var groupTypes_5 = groupTypes.ListGroup;
    var groupTypes_6 = groupTypes.ListItem;
    var groupTypes_7 = groupTypes.TableGroup;
    var groupTypes_8 = groupTypes.TableRow;
    var groupTypes_9 = groupTypes.TableCell;

    var Grouper_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });







    var Grouper = function () {
      function Grouper() {}

      Grouper.pairOpsWithTheirBlock = function (ops) {
        var result = [];

        var canBeInBlock = function (op) {
          return !(op.isJustNewline() || op.isCustomBlock() || op.isVideo() || op.isContainerBlock());
        };

        var isInlineData = function (op) {
          return op.isInline();
        };

        var lastInd = ops.length - 1;
        var opsSlice;

        for (var i = lastInd; i >= 0; i--) {
          var op = ops[i];

          if (op.isVideo()) {
            result.push(new groupTypes.VideoItem(op));
          } else if (op.isCustomBlock()) {
            result.push(new groupTypes.BlotBlock(op));
          } else if (op.isContainerBlock()) {
            opsSlice = array.sliceFromReverseWhile(ops, i - 1, canBeInBlock);
            result.push(new groupTypes.BlockGroup(op, opsSlice.elements));
            i = opsSlice.sliceStartsAt > -1 ? opsSlice.sliceStartsAt : i;
          } else {
            opsSlice = array.sliceFromReverseWhile(ops, i - 1, isInlineData);
            result.push(new groupTypes.InlineGroup(opsSlice.elements.concat(op)));
            i = opsSlice.sliceStartsAt > -1 ? opsSlice.sliceStartsAt : i;
          }
        }

        result.reverse();
        return result;
      };

      Grouper.groupConsecutiveSameStyleBlocks = function (groups, blocksOf) {
        if (blocksOf === void 0) {
          blocksOf = {
            header: true,
            codeBlocks: true,
            blockquotes: true
          };
        }

        return array.groupConsecutiveElementsWhile(groups, function (g, gPrev) {
          if (!(g instanceof groupTypes.BlockGroup) || !(gPrev instanceof groupTypes.BlockGroup)) {
            return false;
          }

          return blocksOf.codeBlocks && Grouper.areBothCodeblocksWithSameLang(g, gPrev) || blocksOf.blockquotes && Grouper.areBothBlockquotesWithSameAdi(g, gPrev) || blocksOf.header && Grouper.areBothSameHeadersWithSameAdi(g, gPrev);
        });
      };

      Grouper.reduceConsecutiveSameStyleBlocksToOne = function (groups) {
        var newLineOp = DeltaInsertOp_1.DeltaInsertOp.createNewLineOp();
        return groups.map(function (elm) {
          if (!Array.isArray(elm)) {
            if (elm instanceof groupTypes.BlockGroup && !elm.ops.length) {
              elm.ops.push(newLineOp);
            }

            return elm;
          }

          var groupsLastInd = elm.length - 1;
          elm[0].ops = array.flatten(elm.map(function (g, i) {
            if (!g.ops.length) {
              return [newLineOp];
            }

            return g.ops.concat(i < groupsLastInd ? [newLineOp] : []);
          }));
          return elm[0];
        });
      };

      Grouper.areBothCodeblocksWithSameLang = function (g1, gOther) {
        return g1.op.isCodeBlock() && gOther.op.isCodeBlock() && g1.op.hasSameLangAs(gOther.op);
      };

      Grouper.areBothSameHeadersWithSameAdi = function (g1, gOther) {
        return g1.op.isSameHeaderAs(gOther.op) && g1.op.hasSameAdiAs(gOther.op);
      };

      Grouper.areBothBlockquotesWithSameAdi = function (g, gOther) {
        return g.op.isBlockquote() && gOther.op.isBlockquote() && g.op.hasSameAdiAs(gOther.op);
      };

      return Grouper;
    }();

    exports.Grouper = Grouper;
    });

    unwrapExports(Grouper_1);
    var Grouper_2 = Grouper_1.Grouper;

    var ListNester_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });





    var ListNester = function () {
      function ListNester() {}

      ListNester.prototype.nest = function (groups) {
        var _this = this;

        var listBlocked = this.convertListBlocksToListGroups(groups);
        var groupedByListGroups = this.groupConsecutiveListGroups(listBlocked);
        var nested = array.flatten(groupedByListGroups.map(function (group) {
          if (!Array.isArray(group)) {
            return group;
          }

          return _this.nestListSection(group);
        }));
        var groupRootLists = array.groupConsecutiveElementsWhile(nested, function (curr, prev) {
          if (!(curr instanceof groupTypes.ListGroup && prev instanceof groupTypes.ListGroup)) {
            return false;
          }

          return curr.items[0].item.op.isSameListAs(prev.items[0].item.op);
        });
        return groupRootLists.map(function (v) {
          if (!Array.isArray(v)) {
            return v;
          }

          var litems = v.map(function (g) {
            return g.items;
          });
          return new groupTypes.ListGroup(array.flatten(litems));
        });
      };

      ListNester.prototype.convertListBlocksToListGroups = function (items) {
        var grouped = array.groupConsecutiveElementsWhile(items, function (g, gPrev) {
          return g instanceof groupTypes.BlockGroup && gPrev instanceof groupTypes.BlockGroup && g.op.isList() && gPrev.op.isList() && g.op.isSameListAs(gPrev.op) && g.op.hasSameIndentationAs(gPrev.op);
        });
        return grouped.map(function (item) {
          if (!Array.isArray(item)) {
            if (item instanceof groupTypes.BlockGroup && item.op.isList()) {
              return new groupTypes.ListGroup([new groupTypes.ListItem(item)]);
            }

            return item;
          }

          return new groupTypes.ListGroup(item.map(function (g) {
            return new groupTypes.ListItem(g);
          }));
        });
      };

      ListNester.prototype.groupConsecutiveListGroups = function (items) {
        return array.groupConsecutiveElementsWhile(items, function (curr, prev) {
          return curr instanceof groupTypes.ListGroup && prev instanceof groupTypes.ListGroup;
        });
      };

      ListNester.prototype.nestListSection = function (sectionItems) {
        var _this = this;

        var indentGroups = this.groupByIndent(sectionItems);
        Object.keys(indentGroups).map(Number).sort().reverse().forEach(function (indent) {
          indentGroups[indent].forEach(function (lg) {
            var idx = sectionItems.indexOf(lg);

            if (_this.placeUnderParent(lg, sectionItems.slice(0, idx))) {
              sectionItems.splice(idx, 1);
            }
          });
        });
        return sectionItems;
      };

      ListNester.prototype.groupByIndent = function (items) {
        return items.reduce(function (pv, cv) {
          var indent = cv.items[0].item.op.attributes.indent;

          if (indent) {
            pv[indent] = pv[indent] || [];
            pv[indent].push(cv);
          }

          return pv;
        }, {});
      };

      ListNester.prototype.placeUnderParent = function (target, items) {
        for (var i = items.length - 1; i >= 0; i--) {
          var elm = items[i];

          if (target.items[0].item.op.hasHigherIndentThan(elm.items[0].item.op)) {
            var parent = elm.items[elm.items.length - 1];

            if (parent.innerList) {
              parent.innerList.items = parent.innerList.items.concat(target.items);
            } else {
              parent.innerList = target;
            }

            return true;
          }
        }

        return false;
      };

      return ListNester;
    }();

    exports.ListNester = ListNester;
    });

    unwrapExports(ListNester_1);
    var ListNester_2 = ListNester_1.ListNester;

    var TableGrouper_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });





    var TableGrouper = function () {
      function TableGrouper() {}

      TableGrouper.prototype.group = function (groups) {
        var tableBlocked = this.convertTableBlocksToTableGroups(groups);
        return tableBlocked;
      };

      TableGrouper.prototype.convertTableBlocksToTableGroups = function (items) {
        var _this = this;

        var grouped = array.groupConsecutiveElementsWhile(items, function (g, gPrev) {
          return g instanceof groupTypes.BlockGroup && gPrev instanceof groupTypes.BlockGroup && g.op.isTable() && gPrev.op.isTable();
        });
        return grouped.map(function (item) {
          if (!Array.isArray(item)) {
            if (item instanceof groupTypes.BlockGroup && item.op.isTable()) {
              return new groupTypes.TableGroup([new groupTypes.TableRow([new groupTypes.TableCell(item)])]);
            }

            return item;
          }

          return new groupTypes.TableGroup(_this.convertTableBlocksToTableRows(item));
        });
      };

      TableGrouper.prototype.convertTableBlocksToTableRows = function (items) {
        var grouped = array.groupConsecutiveElementsWhile(items, function (g, gPrev) {
          return g instanceof groupTypes.BlockGroup && gPrev instanceof groupTypes.BlockGroup && g.op.isTable() && gPrev.op.isTable() && g.op.isSameTableRowAs(gPrev.op);
        });
        return grouped.map(function (item) {
          return new groupTypes.TableRow(Array.isArray(item) ? item.map(function (it) {
            return new groupTypes.TableCell(it);
          }) : [new groupTypes.TableCell(item)]);
        });
      };

      return TableGrouper;
    }();

    exports.TableGrouper = TableGrouper;
    });

    unwrapExports(TableGrouper_1);
    var TableGrouper_2 = TableGrouper_1.TableGrouper;

    var QuillDeltaToHtmlConverter_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });



















    var BrTag = '<br/>';

    var QuillDeltaToHtmlConverter = function () {
      function QuillDeltaToHtmlConverter(deltaOps, options) {
        this.rawDeltaOps = [];
        this.callbacks = {};
        this.options = object.assign({
          paragraphTag: 'p',
          encodeHtml: true,
          classPrefix: 'ql',
          inlineStyles: false,
          multiLineBlockquote: true,
          multiLineHeader: true,
          multiLineCodeblock: true,
          multiLineParagraph: true,
          allowBackgroundClasses: false,
          linkTarget: '_blank'
        }, options, {
          orderedListTag: 'ol',
          bulletListTag: 'ul',
          listItemTag: 'li'
        });
        var inlineStyles;

        if (!this.options.inlineStyles) {
          inlineStyles = undefined;
        } else if (typeof this.options.inlineStyles === 'object') {
          inlineStyles = this.options.inlineStyles;
        } else {
          inlineStyles = {};
        }

        this.converterOptions = {
          encodeHtml: this.options.encodeHtml,
          classPrefix: this.options.classPrefix,
          inlineStyles: inlineStyles,
          listItemTag: this.options.listItemTag,
          paragraphTag: this.options.paragraphTag,
          linkRel: this.options.linkRel,
          linkTarget: this.options.linkTarget,
          allowBackgroundClasses: this.options.allowBackgroundClasses
        };
        this.rawDeltaOps = deltaOps;
      }

      QuillDeltaToHtmlConverter.prototype._getListTag = function (op) {
        return op.isOrderedList() ? this.options.orderedListTag + '' : op.isBulletList() ? this.options.bulletListTag + '' : op.isCheckedList() ? this.options.bulletListTag + '' : op.isUncheckedList() ? this.options.bulletListTag + '' : '';
      };

      QuillDeltaToHtmlConverter.prototype.getGroupedOps = function () {
        var deltaOps = InsertOpsConverter_1.InsertOpsConverter.convert(this.rawDeltaOps, this.options);
        var pairedOps = Grouper_1.Grouper.pairOpsWithTheirBlock(deltaOps);
        var groupedSameStyleBlocks = Grouper_1.Grouper.groupConsecutiveSameStyleBlocks(pairedOps, {
          blockquotes: !!this.options.multiLineBlockquote,
          header: !!this.options.multiLineHeader,
          codeBlocks: !!this.options.multiLineCodeblock
        });
        var groupedOps = Grouper_1.Grouper.reduceConsecutiveSameStyleBlocksToOne(groupedSameStyleBlocks);
        var tableGrouper = new TableGrouper_1.TableGrouper();
        groupedOps = tableGrouper.group(groupedOps);
        var listNester = new ListNester_1.ListNester();
        return listNester.nest(groupedOps);
      };

      QuillDeltaToHtmlConverter.prototype.convert = function () {
        var _this = this;

        var groups = this.getGroupedOps();
        return groups.map(function (group) {
          if (group instanceof groupTypes.ListGroup) {
            return _this._renderWithCallbacks(valueTypes.GroupType.List, group, function () {
              return _this._renderList(group);
            });
          } else if (group instanceof groupTypes.TableGroup) {
            return _this._renderWithCallbacks(valueTypes.GroupType.Table, group, function () {
              return _this._renderTable(group);
            });
          } else if (group instanceof groupTypes.BlockGroup) {
            var g = group;
            return _this._renderWithCallbacks(valueTypes.GroupType.Block, group, function () {
              return _this._renderBlock(g.op, g.ops);
            });
          } else if (group instanceof groupTypes.BlotBlock) {
            return _this._renderCustom(group.op, null);
          } else if (group instanceof groupTypes.VideoItem) {
            return _this._renderWithCallbacks(valueTypes.GroupType.Video, group, function () {
              var g = group;
              var converter = new OpToHtmlConverter_1.OpToHtmlConverter(g.op, _this.converterOptions);
              return converter.getHtml();
            });
          } else {
            return _this._renderWithCallbacks(valueTypes.GroupType.InlineGroup, group, function () {
              return _this._renderInlines(group.ops, true);
            });
          }
        }).join('');
      };

      QuillDeltaToHtmlConverter.prototype._renderWithCallbacks = function (groupType, group, myRenderFn) {
        var html = '';
        var beforeCb = this.callbacks['beforeRender_cb'];
        html = typeof beforeCb === 'function' ? beforeCb.apply(null, [groupType, group]) : '';

        if (!html) {
          html = myRenderFn();
        }

        var afterCb = this.callbacks['afterRender_cb'];
        html = typeof afterCb === 'function' ? afterCb.apply(null, [groupType, html]) : html;
        return html;
      };

      QuillDeltaToHtmlConverter.prototype._renderList = function (list) {
        var _this = this;

        var firstItem = list.items[0];
        return funcsHtml.makeStartTag(this._getListTag(firstItem.item.op)) + list.items.map(function (li) {
          return _this._renderListItem(li);
        }).join('') + funcsHtml.makeEndTag(this._getListTag(firstItem.item.op));
      };

      QuillDeltaToHtmlConverter.prototype._renderListItem = function (li) {
        li.item.op.attributes.indent = 0;
        var converter = new OpToHtmlConverter_1.OpToHtmlConverter(li.item.op, this.converterOptions);
        var parts = converter.getHtmlParts();

        var liElementsHtml = this._renderInlines(li.item.ops, false);

        return parts.openingTag + liElementsHtml + (li.innerList ? this._renderList(li.innerList) : '') + parts.closingTag;
      };

      QuillDeltaToHtmlConverter.prototype._renderTable = function (table) {
        var _this = this;

        return funcsHtml.makeStartTag('table') + funcsHtml.makeStartTag('tbody') + table.rows.map(function (row) {
          return _this._renderTableRow(row);
        }).join('') + funcsHtml.makeEndTag('tbody') + funcsHtml.makeEndTag('table');
      };

      QuillDeltaToHtmlConverter.prototype._renderTableRow = function (row) {
        var _this = this;

        return funcsHtml.makeStartTag('tr') + row.cells.map(function (cell) {
          return _this._renderTableCell(cell);
        }).join('') + funcsHtml.makeEndTag('tr');
      };

      QuillDeltaToHtmlConverter.prototype._renderTableCell = function (cell) {
        var converter = new OpToHtmlConverter_1.OpToHtmlConverter(cell.item.op, this.converterOptions);
        var parts = converter.getHtmlParts();

        var cellElementsHtml = this._renderInlines(cell.item.ops, false);

        return funcsHtml.makeStartTag('td', {
          key: 'data-row',
          value: cell.item.op.attributes.table
        }) + parts.openingTag + cellElementsHtml + parts.closingTag + funcsHtml.makeEndTag('td');
      };

      QuillDeltaToHtmlConverter.prototype._renderBlock = function (bop, ops) {
        var _this = this;

        var converter = new OpToHtmlConverter_1.OpToHtmlConverter(bop, this.converterOptions);
        var htmlParts = converter.getHtmlParts();

        if (bop.isCodeBlock()) {
          return htmlParts.openingTag + funcsHtml.encodeHtml(ops.map(function (iop) {
            return iop.isCustom() ? _this._renderCustom(iop, bop) : iop.insert.value;
          }).join('')) + htmlParts.closingTag;
        }

        var inlines = ops.map(function (op) {
          return _this._renderInline(op, bop);
        }).join('');
        return htmlParts.openingTag + (inlines || BrTag) + htmlParts.closingTag;
      };

      QuillDeltaToHtmlConverter.prototype._renderInlines = function (ops, isInlineGroup) {
        var _this = this;

        if (isInlineGroup === void 0) {
          isInlineGroup = true;
        }

        var opsLen = ops.length - 1;
        var html = ops.map(function (op, i) {
          if (i > 0 && i === opsLen && op.isJustNewline()) {
            return '';
          }

          return _this._renderInline(op, null);
        }).join('');

        if (!isInlineGroup) {
          return html;
        }

        var startParaTag = funcsHtml.makeStartTag(this.options.paragraphTag);
        var endParaTag = funcsHtml.makeEndTag(this.options.paragraphTag);

        if (html === BrTag || this.options.multiLineParagraph) {
          return startParaTag + html + endParaTag;
        }

        return startParaTag + html.split(BrTag).map(function (v) {
          return v === '' ? BrTag : v;
        }).join(endParaTag + startParaTag) + endParaTag;
      };

      QuillDeltaToHtmlConverter.prototype._renderInline = function (op, contextOp) {
        if (op.isCustom()) {
          return this._renderCustom(op, contextOp);
        }

        var converter = new OpToHtmlConverter_1.OpToHtmlConverter(op, this.converterOptions);
        return converter.getHtml().replace(/\n/g, BrTag);
      };

      QuillDeltaToHtmlConverter.prototype._renderCustom = function (op, contextOp) {
        var renderCb = this.callbacks['renderCustomOp_cb'];

        if (typeof renderCb === 'function') {
          return renderCb.apply(null, [op, contextOp]);
        }

        return '';
      };

      QuillDeltaToHtmlConverter.prototype.beforeRender = function (cb) {
        if (typeof cb === 'function') {
          this.callbacks['beforeRender_cb'] = cb;
        }
      };

      QuillDeltaToHtmlConverter.prototype.afterRender = function (cb) {
        if (typeof cb === 'function') {
          this.callbacks['afterRender_cb'] = cb;
        }
      };

      QuillDeltaToHtmlConverter.prototype.renderCustomWith = function (cb) {
        this.callbacks['renderCustomOp_cb'] = cb;
      };

      return QuillDeltaToHtmlConverter;
    }();

    exports.QuillDeltaToHtmlConverter = QuillDeltaToHtmlConverter;
    });

    unwrapExports(QuillDeltaToHtmlConverter_1);
    var QuillDeltaToHtmlConverter_2 = QuillDeltaToHtmlConverter_1.QuillDeltaToHtmlConverter;

    var main = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });



    exports.QuillDeltaToHtmlConverter = QuillDeltaToHtmlConverter_1.QuillDeltaToHtmlConverter;



    exports.OpToHtmlConverter = OpToHtmlConverter_1.OpToHtmlConverter;



    exports.InlineGroup = groupTypes.InlineGroup;
    exports.VideoItem = groupTypes.VideoItem;
    exports.BlockGroup = groupTypes.BlockGroup;
    exports.ListGroup = groupTypes.ListGroup;
    exports.ListItem = groupTypes.ListItem;
    exports.BlotBlock = groupTypes.BlotBlock;



    exports.DeltaInsertOp = DeltaInsertOp_1.DeltaInsertOp;



    exports.InsertDataQuill = InsertData.InsertDataQuill;
    exports.InsertDataCustom = InsertData.InsertDataCustom;



    exports.NewLine = valueTypes.NewLine;
    exports.ListType = valueTypes.ListType;
    exports.ScriptType = valueTypes.ScriptType;
    exports.DirectionType = valueTypes.DirectionType;
    exports.AlignType = valueTypes.AlignType;
    exports.DataType = valueTypes.DataType;
    exports.GroupType = valueTypes.GroupType;
    });

    unwrapExports(main);
    var main_1 = main.QuillDeltaToHtmlConverter;
    var main_2 = main.OpToHtmlConverter;
    var main_3 = main.InlineGroup;
    var main_4 = main.VideoItem;
    var main_5 = main.BlockGroup;
    var main_6 = main.ListGroup;
    var main_7 = main.ListItem;
    var main_8 = main.BlotBlock;
    var main_9 = main.DeltaInsertOp;
    var main_10 = main.InsertDataQuill;
    var main_11 = main.InsertDataCustom;
    var main_12 = main.NewLine;
    var main_13 = main.ListType;
    var main_14 = main.ScriptType;
    var main_15 = main.DirectionType;
    var main_16 = main.AlignType;
    var main_17 = main.DataType;
    var main_18 = main.GroupType;

    const puppeteer = require('puppeteer');

    const app$2 = require('electron').remote.app;

    const fs$1 = require('fs');

    const root$2 = app$2.getAppPath();
    async function formatForAssembly(html, section) {
      html.replace(/“/g, '&quot;').replace(/”/g, '&quot;').replace(/'/g, '&quot;').replace(/'/g, '&apos;');
      let wrapper = document.createElement('div');
      wrapper.classList.add('sectionWrapper');
      wrapper.style.visibility = 'hidden';
      wrapper.style.position = 'fixed';
      wrapper.style.top = 0;
      wrapper.style.left = 0; //Remove any cursor object

      let cursors = document.querySelectorAll('span.ql-cursor');
      console.log(cursors);
      cursors.forEach(cursor => cursor.remove()); //Cut unnecessary starting/ending space

      let first11 = html.substring(0, 11);
      let mainBody = html.substring(11, html.length - 11);
      let last11 = html.substring(html.length - 11, html.length);
      first11 = first11.replace(/<p><br><\/p>/g, "");
      last11 = last11.replace(/<p><br><\/p>/g, "");
      if (section != 'body') wrapper.innerHTML = `<style>#header, #footer { padding: 0 !important; }</style> <div style='font-size: 12px; margin: 0 40px; padding: 40px 0;'>` + first11 + mainBody + last11 + "</div>";else wrapper.innerHTML = first11 + mainBody + last11; //Set table settings

      let tables = wrapper.querySelectorAll('table');

      if (tables) {
        tables.forEach(table => {
          let tableWidth = parseInt(table.style.width);
          table.style = "width: 100%;";
          let cols = table.querySelectorAll('col');
          let colPercents = [];
          cols.forEach(col => {
            let colWidth = parseInt(col.width);
            let newWidth = colWidth / tableWidth * 100 + "%";
            colPercents.push(newWidth);
          });
          table.removeChild(table.querySelector('colgroup'));
          let tds = table.querySelectorAll('td');
          tds.forEach((td, index) => {
            let commonStyle = 'border: none; overflow: hidden;';
            if (index < colPercents.length) td.style = commonStyle + " width: " + colPercents[index] + ";";else td.style = commonStyle;
            let tableImgs = td.querySelectorAll('img');
            tableImgs.forEach(im => im.style = 'width: 100%;');
          });
        });
      }

      let wrapperStyle = document.createElement('style');
      wrapperStyle.innerHTML = ".ql-align-right { text-align: right; } .ql-align-center { text-align: center; } .ql-align-justify { text-align: justified; }";
      wrapper.appendChild(wrapperStyle); //Get height for header/footer

      if (section != 'body') {
        document.body.appendChild(wrapper);
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            let innerDiv = wrapper.querySelector('div');
            let height = innerDiv.clientHeight + parseInt(innerDiv.style.marginTop) + parseInt(innerDiv.style.marginBottom);
            resolve({
              html: wrapper.innerHTML,
              height
            });
            wrapper.remove();
          }, 100);
        });
      } else return {
        html: wrapper.innerHTML
      };
    }
    async function printPDF(header, body, footer, data) {
      let formattedHeader = await formatForAssembly(header, 'header');
      let formattedBody = await formatForAssembly(body, 'body');
      let formattedFooter = await formatForAssembly(footer, 'footer');
      const browser = await puppeteer.launch({
        headless: true
      });
      const page = await browser.newPage();
      await page.goto('data:text/html,' + formattedBody.html, {
        waitUntil: 'networkidle0'
      });
      const pdf = await page.pdf({
        path: root$2 + '/appdata/newerpdf.pdf',
        displayHeaderFooter: true,
        format: "A4",
        headerTemplate: formattedHeader.html,
        footerTemplate: formattedFooter.html,
        margin: {
          top: formattedHeader.height > 40 ? formattedHeader.height + 'px' : "40px",
          bottom: formattedFooter.height > 40 ? formattedFooter.height + 'px' : "40px",
          left: "40px",
          right: "40px"
        },
        printBackground: true
      });
      await browser.close();
    }

    /* src\Settings.svelte generated by Svelte v3.17.1 */
    const file$a = "src\\Settings.svelte";

    function get_each_context$8(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[22] = list[i];
      return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[25] = list[i];
      child_ctx[26] = list;
      child_ctx[27] = i;
      return child_ctx;
    } // (130:4) {#if $settings.passwords}


    function create_if_block_1$3(ctx) {
      let each_1_anchor;
      let each_value_1 =
      /*$settings*/
      ctx[2].passwords;
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
      }

      const block = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*$settings, openPagesDialog*/
          36) {
            each_value_1 =
            /*$settings*/
            ctx[2].passwords;
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_1$1(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_1.length;
          }
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$3.name,
        type: "if",
        source: "(130:4) {#if $settings.passwords}",
        ctx
      });
      return block;
    } // (131:8) {#each $settings.passwords as password, i}


    function create_each_block_1$1(ctx) {
      let div1;
      let input0;
      let t0;
      let input1;
      let input1_value_value;
      let t1;
      let div0;
      let t3;
      let dispose;

      function input0_input_handler_1() {
        /*input0_input_handler_1*/
        ctx[14].call(input0,
        /*password*/
        ctx[25]);
      }

      function click_handler(...args) {
        return (
          /*click_handler*/
          ctx[16](
          /*password*/
          ctx[25],
          /*i*/
          ctx[27], ...args)
        );
      }

      function click_handler_1(...args) {
        return (
          /*click_handler_1*/
          ctx[17](
          /*i*/
          ctx[27], ...args)
        );
      }

      const block = {
        c: function create() {
          div1 = element("div");
          input0 = element("input");
          t0 = space();
          input1 = element("input");
          t1 = space();
          div0 = element("div");
          div0.textContent = "×";
          t3 = space();
          attr_dev(input0, "type", "text");
          attr_dev(input0, "placeholder", "Password");
          add_location(input0, file$a, 132, 16, 6259);
          attr_dev(input1, "type", "text");
          attr_dev(input1, "class", "select-pages svelte-1syws4z");
          attr_dev(input1, "placeholder", "Pages");
          input1.value = input1_value_value =
          /*password*/
          ctx[25].pages.map(func).join(", ");
          input1.readOnly = true;
          add_location(input1, file$a, 133, 16, 6390);
          attr_dev(div0, "class", "close");
          add_location(div0, file$a, 134, 16, 6576);
          attr_dev(div1, "class", "passwords whitebox");
          add_location(div1, file$a, 131, 12, 6209);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, input0);
          set_input_value(input0,
          /*password*/
          ctx[25].password);
          append_dev(div1, t0);
          append_dev(div1, input1);
          append_dev(div1, t1);
          append_dev(div1, div0);
          append_dev(div1, t3);
          dispose = [listen_dev(input0, "input", input0_input_handler_1), listen_dev(input0, "change",
          /*change_handler*/
          ctx[15], false, false, false), listen_dev(input1, "click", click_handler, false, false, false), listen_dev(div0, "click", click_handler_1, false, false, false)];
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;

          if (dirty &
          /*$settings*/
          4 && input0.value !==
          /*password*/
          ctx[25].password) {
            set_input_value(input0,
            /*password*/
            ctx[25].password);
          }

          if (dirty &
          /*$settings*/
          4 && input1_value_value !== (input1_value_value =
          /*password*/
          ctx[25].pages.map(func).join(", ")) && input1.value !== input1_value_value) {
            prop_dev(input1, "value", input1_value_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$1.name,
        type: "each",
        source: "(131:8) {#each $settings.passwords as password, i}",
        ctx
      });
      return block;
    } // (154:0) {#if showPagesModal}


    function create_if_block$5(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler*/
      ctx[21]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty &
          /*$$scope, pages, $settings*/
          268435462) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$5.name,
        type: "if",
        source: "(154:0) {#if showPagesModal}",
        ctx
      });
      return block;
    } // (158:12) {#each pages as page}


    function create_each_block$8(ctx) {
      let li;
      let t_value =
      /*page*/
      ctx[22].name + "";
      let t;
      let dispose;

      function click_handler_8(...args) {
        return (
          /*click_handler_8*/
          ctx[20](
          /*page*/
          ctx[22], ...args)
        );
      }

      const block = {
        c: function create() {
          li = element("li");
          t = text(t_value);
          attr_dev(li, "class", "svelte-1syws4z");
          toggle_class(li, "selected",
          /*page*/
          ctx[22].selected);
          add_location(li, file$a, 158, 16, 8156);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t);
          dispose = listen_dev(li, "click", click_handler_8, false, false, false);
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty &
          /*pages*/
          2 && t_value !== (t_value =
          /*page*/
          ctx[22].name + "")) set_data_dev(t, t_value);

          if (dirty &
          /*pages*/
          2) {
            toggle_class(li, "selected",
            /*page*/
            ctx[22].selected);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$8.name,
        type: "each",
        source: "(158:12) {#each pages as page}",
        ctx
      });
      return block;
    } // (155:4) <Modal on:forceClose={()=>{ showPagesModal = false }}>


    function create_default_slot$4(ctx) {
      let h3;
      let t0;
      let t1_value = formatText(
      /*$settings*/
      ctx[2].services, true, true) + "";
      let t1;
      let t2;
      let ul;
      let t3;
      let button;
      let dispose;
      let each_value =
      /*pages*/
      ctx[1];
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          h3 = element("h3");
          t0 = text("Select ");
          t1 = text(t1_value);
          t2 = space();
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t3 = space();
          button = element("button");
          button.textContent = "OK";
          add_location(h3, file$a, 155, 8, 8013);
          attr_dev(ul, "id", "pages-list");
          attr_dev(ul, "class", "svelte-1syws4z");
          add_location(ul, file$a, 156, 8, 8083);
          attr_dev(button, "class", "centered blue");
          attr_dev(button, "type", "submit");
          add_location(button, file$a, 161, 8, 8325);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          append_dev(h3, t0);
          append_dev(h3, t1);
          insert_dev(target, t2, anchor);
          insert_dev(target, ul, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          insert_dev(target, t3, anchor);
          insert_dev(target, button, anchor);
          dispose = listen_dev(button, "click", prevent_default(
          /*savePageSettings*/
          ctx[6]), false, true, false);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*$settings*/
          4 && t1_value !== (t1_value = formatText(
          /*$settings*/
          ctx[2].services, true, true) + "")) set_data_dev(t1, t1_value);

          if (dirty &
          /*pages, $settings*/
          6) {
            each_value =
            /*pages*/
            ctx[1];
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$8(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$8(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(ul, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(ul);
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(button);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$4.name,
        type: "slot",
        source: "(155:4) <Modal on:forceClose={()=>{ showPagesModal = false }}>",
        ctx
      });
      return block;
    }

    function create_fragment$a(ctx) {
      let div1;
      let h20;
      let t1;
      let h30;
      let t3;
      let p0;
      let t5;
      let input0;
      let t6;
      let p1;
      let t8;
      let input1;
      let t9;
      let p2;
      let t11;
      let input2;
      let t12;
      let h21;
      let t14;
      let p3;
      let t15;
      let strong;
      let t17;
      let t18;
      let t19;
      let button0;
      let t21;
      let h22;
      let t23;
      let h31;
      let t25;
      let p4;
      let t26;
      let a0;
      let t27_value =
      /*$settings*/
      ctx[2].databasedir + "";
      let t27;
      let t28;
      let p5;
      let t29;
      let a1;
      let t30_value =
      /*$settings*/
      ctx[2].backupdir + "";
      let t30;
      let t31;
      let h32;
      let t33;
      let p6;
      let button1;
      let t35;
      let em;
      let t37;
      let t38;
      let div0;
      let button2;
      let t40;
      let button3;
      let t42;
      let button4;
      let div1_intro;
      let div1_outro;
      let t44;
      let if_block1_anchor;
      let current;
      let dispose;
      let if_block0 =
      /*$settings*/
      ctx[2].passwords && create_if_block_1$3(ctx);
      let if_block1 =
      /*showPagesModal*/
      ctx[0] && create_if_block$5(ctx);
      const block = {
        c: function create() {
          div1 = element("div");
          h20 = element("h2");
          h20.textContent = "Settings";
          t1 = space();
          h30 = element("h3");
          h30.textContent = "Terminology";
          t3 = space();
          p0 = element("p");
          p0.textContent = "What do you call the document this app helps you to create? (Use an abbreviation or common name if possible; for example, \"LOA\" for \"Letter of Accommodation\")";
          t5 = space();
          input0 = element("input");
          t6 = space();
          p1 = element("p");
          p1.textContent = "What do you call the services you provide? (eg accommodations, services, supports)";
          t8 = space();
          input1 = element("input");
          t9 = space();
          p2 = element("p");
          p2.textContent = "What do you call the people you serve? (eg students, clients, customers)";
          t11 = space();
          input2 = element("input");
          t12 = space();
          h21 = element("h2");
          h21.textContent = "Security";
          t14 = space();
          p3 = element("p");
          t15 = text("You can set up passwords for the various pages of Accommodate to implement nominal security. ");
          strong = element("strong");
          strong.textContent = "This is not strong security, and will not prevent access to a determined attacker.";
          t17 = text(" All settings can be overridden easily by altering app files. It is expected that this app will be stored in a location with sufficient access restrictions. This password system is only meant to discourage accidental alteration to app settings and data by unauthorized (but non-malicious) users.");
          t18 = space();
          if (if_block0) if_block0.c();
          t19 = space();
          button0 = element("button");
          button0.textContent = "Add password";
          t21 = space();
          h22 = element("h2");
          h22.textContent = "Data";
          t23 = space();
          h31 = element("h3");
          h31.textContent = "Sources";
          t25 = space();
          p4 = element("p");
          t26 = text("The database files for this app are located here: ");
          a0 = element("a");
          t27 = text(t27_value);
          t28 = space();
          p5 = element("p");
          t29 = text("The database backups are located here: ");
          a1 = element("a");
          t30 = text(t30_value);
          t31 = space();
          h32 = element("h3");
          h32.textContent = "Manage Data";
          t33 = space();
          p6 = element("p");
          button1 = element("button");
          button1.textContent = "Import data";
          t35 = text("You can import data ");
          em = element("em");
          em.textContent = "en masse";
          t37 = text(" by loading a CSV file. Records with no specified ID will be assigned one; records with IDs that already exist will be replaced by the imported data. CSV files can be created in most spreadsheet programs, including Microsoft Excel.");
          t38 = space();
          div0 = element("div");
          button2 = element("button");
          button2.textContent = "Back up data";
          t40 = space();
          button3 = element("button");
          button3.textContent = "Restore backup";
          t42 = space();
          button4 = element("button");
          button4.textContent = "Clear data";
          t44 = space();
          if (if_block1) if_block1.c();
          if_block1_anchor = empty();
          add_location(h20, file$a, 116, 4, 5012);
          add_location(h30, file$a, 117, 4, 5035);
          add_location(p0, file$a, 118, 4, 5061);
          attr_dev(input0, "type", "text");
          add_location(input0, file$a, 119, 4, 5232);
          add_location(p1, file$a, 121, 4, 5293);
          attr_dev(input1, "type", "text");
          add_location(input1, file$a, 122, 4, 5388);
          add_location(p2, file$a, 124, 4, 5451);
          attr_dev(input2, "type", "text");
          add_location(input2, file$a, 125, 4, 5536);
          add_location(h21, file$a, 127, 4, 5595);
          add_location(strong, file$a, 128, 100, 5714);
          add_location(p3, file$a, 128, 4, 5618);
          attr_dev(button0, "type", "submit");
          attr_dev(button0, "class", "blue");
          add_location(button0, file$a, 138, 4, 6736);
          add_location(h22, file$a, 140, 4, 6838);
          add_location(h31, file$a, 141, 4, 6857);
          attr_dev(a0, "href", "changepath");
          add_location(a0, file$a, 142, 57, 6932);
          add_location(p4, file$a, 142, 4, 6879);
          attr_dev(a1, "href", "changepath");
          add_location(a1, file$a, 143, 46, 7089);
          add_location(p5, file$a, 143, 4, 7047);
          add_location(h32, file$a, 144, 4, 7200);
          attr_dev(button1, "type", "submit");
          attr_dev(button1, "class", "blue");
          add_location(button1, file$a, 145, 7, 7229);
          add_location(em, file$a, 145, 115, 7337);
          add_location(p6, file$a, 145, 4, 7226);
          attr_dev(button2, "type", "submit");
          attr_dev(button2, "class", "blue");
          add_location(button2, file$a, 147, 8, 7625);
          attr_dev(button3, "type", "submit");
          attr_dev(button3, "class", "blue");
          add_location(button3, file$a, 148, 8, 7724);
          attr_dev(button4, "type", "submit");
          add_location(button4, file$a, 149, 8, 7825);
          attr_dev(div0, "class", "inline");
          add_location(div0, file$a, 146, 4, 7595);
          set_style(div1, "position", "relative");
          add_location(div1, file$a, 115, 0, 4924);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, h20);
          append_dev(div1, t1);
          append_dev(div1, h30);
          append_dev(div1, t3);
          append_dev(div1, p0);
          append_dev(div1, t5);
          append_dev(div1, input0);
          set_input_value(input0,
          /*$settings*/
          ctx[2].abbrev);
          append_dev(div1, t6);
          append_dev(div1, p1);
          append_dev(div1, t8);
          append_dev(div1, input1);
          set_input_value(input1,
          /*$settings*/
          ctx[2].services);
          append_dev(div1, t9);
          append_dev(div1, p2);
          append_dev(div1, t11);
          append_dev(div1, input2);
          set_input_value(input2,
          /*$settings*/
          ctx[2].students);
          append_dev(div1, t12);
          append_dev(div1, h21);
          append_dev(div1, t14);
          append_dev(div1, p3);
          append_dev(p3, t15);
          append_dev(p3, strong);
          append_dev(p3, t17);
          append_dev(div1, t18);
          if (if_block0) if_block0.m(div1, null);
          append_dev(div1, t19);
          append_dev(div1, button0);
          append_dev(div1, t21);
          append_dev(div1, h22);
          append_dev(div1, t23);
          append_dev(div1, h31);
          append_dev(div1, t25);
          append_dev(div1, p4);
          append_dev(p4, t26);
          append_dev(p4, a0);
          append_dev(a0, t27);
          append_dev(div1, t28);
          append_dev(div1, p5);
          append_dev(p5, t29);
          append_dev(p5, a1);
          append_dev(a1, t30);
          append_dev(div1, t31);
          append_dev(div1, h32);
          append_dev(div1, t33);
          append_dev(div1, p6);
          append_dev(p6, button1);
          append_dev(p6, t35);
          append_dev(p6, em);
          append_dev(p6, t37);
          append_dev(div1, t38);
          append_dev(div1, div0);
          append_dev(div0, button2);
          append_dev(div0, t40);
          append_dev(div0, button3);
          append_dev(div0, t42);
          append_dev(div0, button4);
          insert_dev(target, t44, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
          current = true;
          dispose = [listen_dev(input0, "input",
          /*input0_input_handler*/
          ctx[11]), listen_dev(input1, "input",
          /*input1_input_handler*/
          ctx[12]), listen_dev(input2, "input",
          /*input2_input_handler*/
          ctx[13]), listen_dev(button0, "click", prevent_default(
          /*addPassword*/
          ctx[4]), false, true, false), listen_dev(a0, "click", prevent_default(
          /*click_handler_2*/
          ctx[18]), false, true, false), listen_dev(a1, "click", prevent_default(
          /*click_handler_3*/
          ctx[19]), false, true, false), listen_dev(button1, "click", prevent_default(click_handler_4), false, true, false), listen_dev(button2, "click", prevent_default(click_handler_5), false, true, false), listen_dev(button3, "click", prevent_default(click_handler_6), false, true, false), listen_dev(button4, "click", prevent_default(click_handler_7), false, true, false)];
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*$settings*/
          4 && input0.value !==
          /*$settings*/
          ctx[2].abbrev) {
            set_input_value(input0,
            /*$settings*/
            ctx[2].abbrev);
          }

          if (dirty &
          /*$settings*/
          4 && input1.value !==
          /*$settings*/
          ctx[2].services) {
            set_input_value(input1,
            /*$settings*/
            ctx[2].services);
          }

          if (dirty &
          /*$settings*/
          4 && input2.value !==
          /*$settings*/
          ctx[2].students) {
            set_input_value(input2,
            /*$settings*/
            ctx[2].students);
          }

          if (
          /*$settings*/
          ctx[2].passwords) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_1$3(ctx);
              if_block0.c();
              if_block0.m(div1, t19);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if ((!current || dirty &
          /*$settings*/
          4) && t27_value !== (t27_value =
          /*$settings*/
          ctx[2].databasedir + "")) set_data_dev(t27, t27_value);
          if ((!current || dirty &
          /*$settings*/
          4) && t30_value !== (t30_value =
          /*$settings*/
          ctx[2].backupdir + "")) set_data_dev(t30, t30_value);

          if (
          /*showPagesModal*/
          ctx[0]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
              transition_in(if_block1, 1);
            } else {
              if_block1 = create_if_block$5(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (div1_outro) div1_outro.end(1);
            if (!div1_intro) div1_intro = create_in_transition(div1, fly, {
              x: 100,
              delay: 500
            });
            div1_intro.start();
          });
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          if (div1_intro) div1_intro.invalidate();
          div1_outro = create_out_transition(div1, fly, {
            x: 100
          });
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          if (if_block0) if_block0.d();
          if (detaching && div1_outro) div1_outro.end();
          if (detaching) detach_dev(t44);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach_dev(if_block1_anchor);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$a.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    const func = el => el.name;

    const click_handler_4 = () => {};

    const click_handler_5 = () => {};

    const click_handler_6 = () => {};

    const click_handler_7 = () => {};

    function instance$a($$self, $$props, $$invalidate) {
      let $settings;
      validate_store(settings, "settings");
      component_subscribe($$self, settings, $$value => $$invalidate(2, $settings = $$value));

      const {
        dialog
      } = require("electron").remote;

      const getFolder = alter => {
        dialog.showOpenDialog({
          properties: ["openDirectory"]
        }).then(res => {
          if (res.filePaths[0] != undefined) set_store_value(settings, $settings[alter] = res.filePaths[0], $settings);
        });
      };

      let showPagesModal = false;
      let pages = [{
        name: "Write " + formatText($settings.abbrev, false, false, true),
        value: "#write",
        selected: false
      }, {
        name: formatText($settings.students, true, true),
        selected: false,
        value: "#students"
      }, {
        name: formatText($settings.services, true, true),
        selected: false,
        value: "#accommodations"
      }, {
        name: formatText($settings.abbrev, false, false, true) + " Template",
        selected: false,
        value: "#pdf"
      }, {
        name: "Settings",
        selected: false,
        value: "#settings"
      }, {
        name: "Reports",
        selected: false,
        value: "#reports"
      }];
      let saveTimeout = null;
      let curPassIndex = 0;

      let save = () => {
        if (saveTimeout) clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
          changeSettings($settings);
        }, 3000);
      };

      let addPassword = () => {
        if (!$settings.passwords) set_store_value(settings, $settings.passwords = [], $settings);
        $settings.passwords.push({
          password: "",
          pages: []
        });
        settings.set($settings);
      };

      let openPagesDialog = (password, index) => {
        pages.forEach(page => {
          page.selected = false;

          if (password.pages) {
            password.pages.forEach(pwordpage => {
              if (pwordpage.name == page.name) {
                page.selected = true;
              }
            });
          }
        });
        curPassIndex = index;
        $$invalidate(0, showPagesModal = true);
      };

      let savePageSettings = () => {
        set_store_value(settings, $settings.passwords[curPassIndex].pages = pages.filter(page => page.selected), $settings);
        $$invalidate(0, showPagesModal = false);
      };

      function input0_input_handler() {
        $settings.abbrev = this.value;
        settings.set($settings);
      }

      function input1_input_handler() {
        $settings.services = this.value;
        settings.set($settings);
      }

      function input2_input_handler() {
        $settings.students = this.value;
        settings.set($settings);
      }

      function input0_input_handler_1(password) {
        password.password = this.value;
      }

      const change_handler = () => {
        settings.set($settings);
      };

      const click_handler = (password, i) => {
        openPagesDialog(password, i);
      };

      const click_handler_1 = i => {
        $settings.passwords.splice(i, 1);
        settings.set($settings);
      };

      const click_handler_2 = () => {
        getFolder("databasedir");
      };

      const click_handler_3 = () => {
        getFolder("backupdir");
      };

      const click_handler_8 = page => {
        $$invalidate(1, page.selected = !page.selected, pages);
        settings.set($settings);
      };

      const forceClose_handler = () => {
        $$invalidate(0, showPagesModal = false);
      };

      $$self.$capture_state = () => {
        return {};
      };

      $$self.$inject_state = $$props => {
        if ("showPagesModal" in $$props) $$invalidate(0, showPagesModal = $$props.showPagesModal);
        if ("pages" in $$props) $$invalidate(1, pages = $$props.pages);
        if ("saveTimeout" in $$props) saveTimeout = $$props.saveTimeout;
        if ("curPassIndex" in $$props) curPassIndex = $$props.curPassIndex;
        if ("save" in $$props) $$invalidate(10, save = $$props.save);
        if ("addPassword" in $$props) $$invalidate(4, addPassword = $$props.addPassword);
        if ("openPagesDialog" in $$props) $$invalidate(5, openPagesDialog = $$props.openPagesDialog);
        if ("savePageSettings" in $$props) $$invalidate(6, savePageSettings = $$props.savePageSettings);
        if ("$settings" in $$props) settings.set($settings = $$props.$settings);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$settings*/
        4) {
           save();
        }
      };

      return [showPagesModal, pages, $settings, getFolder, addPassword, openPagesDialog, savePageSettings, saveTimeout, curPassIndex, dialog, save, input0_input_handler, input1_input_handler, input2_input_handler, input0_input_handler_1, change_handler, click_handler, click_handler_1, click_handler_2, click_handler_3, click_handler_8, forceClose_handler];
    }

    class Settings extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$a, create_fragment$a, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Settings",
          options,
          id: create_fragment$a.name
        });
      }

    }

    /* src\Record.svelte generated by Svelte v3.17.1 */
    const file$b = "src\\Record.svelte";

    function get_each_context$9(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[9] = list[i];
      return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[12] = list[i];
      return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[9] = list[i];
      return child_ctx;
    } // (30:0) {#if record}


    function create_if_block_2$3(ctx) {
      let div;
      let h2;
      let t0;
      let t1_value =
      /*record*/
      ctx[0].student.lname + ", " +
      /*record*/
      ctx[0].student.fname + " (" +
      /*record*/
      ctx[0].student._id + ")" + "";
      let t1;
      let t2;
      let a;
      let t3;
      let t4_value = formatText(
      /*$settings*/
      ctx[3].students, true, false) + "";
      let t4;
      let t5;
      let h30;
      let t6;
      let t7_value = formatText(
      /*$settings*/
      ctx[3].services, true, true) + "";
      let t7;
      let t8;
      let ul0;
      let t9;
      let h31;
      let t10_value = formatText(
      /*$settings*/
      ctx[3].abbrev, false, false, true) + "";
      let t10;
      let t11;
      let t12;
      let ul1;
      let div_intro;
      let div_outro;
      let current;

      function select_block_type(ctx, dirty) {
        if (
        /*record*/
        ctx[0].accoms &&
        /*record*/
        ctx[0].accoms.length) return create_if_block_4$2;
        return create_else_block_2$1;
      }

      let current_block_type = select_block_type(ctx);
      let if_block0 = current_block_type(ctx);

      function select_block_type_1(ctx, dirty) {
        if (
        /*record*/
        ctx[0].records &&
        /*record*/
        ctx[0].records.length) return create_if_block_3$3;
        return create_else_block_1$1;
      }

      let current_block_type_1 = select_block_type_1(ctx);
      let if_block1 = current_block_type_1(ctx);
      const block = {
        c: function create() {
          div = element("div");
          h2 = element("h2");
          t0 = text("Record for ");
          t1 = text(t1_value);
          t2 = space();
          a = element("a");
          t3 = text("Back to ");
          t4 = text(t4_value);
          t5 = space();
          h30 = element("h3");
          t6 = text("Current ");
          t7 = text(t7_value);
          t8 = space();
          ul0 = element("ul");
          if_block0.c();
          t9 = space();
          h31 = element("h3");
          t10 = text(t10_value);
          t11 = text(" Documents");
          t12 = space();
          ul1 = element("ul");
          if_block1.c();
          add_location(h2, file$b, 31, 8, 1061);
          attr_dev(a, "href", "#students");
          add_location(a, file$b, 32, 8, 1177);
          add_location(h30, file$b, 33, 8, 1264);
          add_location(ul0, file$b, 34, 8, 1335);
          add_location(h31, file$b, 44, 8, 1617);
          add_location(ul1, file$b, 45, 8, 1696);
          set_style(div, "position", "relative");
          add_location(div, file$b, 30, 4, 969);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, h2);
          append_dev(h2, t0);
          append_dev(h2, t1);
          append_dev(div, t2);
          append_dev(div, a);
          append_dev(a, t3);
          append_dev(a, t4);
          append_dev(div, t5);
          append_dev(div, h30);
          append_dev(h30, t6);
          append_dev(h30, t7);
          append_dev(div, t8);
          append_dev(div, ul0);
          if_block0.m(ul0, null);
          append_dev(div, t9);
          append_dev(div, h31);
          append_dev(h31, t10);
          append_dev(h31, t11);
          append_dev(div, t12);
          append_dev(div, ul1);
          if_block1.m(ul1, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty &
          /*record*/
          1) && t1_value !== (t1_value =
          /*record*/
          ctx[0].student.lname + ", " +
          /*record*/
          ctx[0].student.fname + " (" +
          /*record*/
          ctx[0].student._id + ")" + "")) set_data_dev(t1, t1_value);
          if ((!current || dirty &
          /*$settings*/
          8) && t4_value !== (t4_value = formatText(
          /*$settings*/
          ctx[3].students, true, false) + "")) set_data_dev(t4, t4_value);
          if ((!current || dirty &
          /*$settings*/
          8) && t7_value !== (t7_value = formatText(
          /*$settings*/
          ctx[3].services, true, true) + "")) set_data_dev(t7, t7_value);

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0.d(1);
            if_block0 = current_block_type(ctx);

            if (if_block0) {
              if_block0.c();
              if_block0.m(ul0, null);
            }
          }

          if ((!current || dirty &
          /*$settings*/
          8) && t10_value !== (t10_value = formatText(
          /*$settings*/
          ctx[3].abbrev, false, false, true) + "")) set_data_dev(t10, t10_value);

          if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if_block1.d(1);
            if_block1 = current_block_type_1(ctx);

            if (if_block1) {
              if_block1.c();
              if_block1.m(ul1, null);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (div_outro) div_outro.end(1);
            if (!div_intro) div_intro = create_in_transition(div, fly, {
              x: 100,
              delay: 500
            });
            div_intro.start();
          });
          current = true;
        },
        o: function outro(local) {
          if (div_intro) div_intro.invalidate();
          div_outro = create_out_transition(div, fly, {
            x: 100
          });
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if_block0.d();
          if_block1.d();
          if (detaching && div_outro) div_outro.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$3.name,
        type: "if",
        source: "(30:0) {#if record}",
        ctx
      });
      return block;
    } // (40:12) {:else}


    function create_else_block_2$1(ctx) {
      let li;
      const block = {
        c: function create() {
          li = element("li");
          li.textContent = "None listed";
          add_location(li, file$b, 40, 16, 1551);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_2$1.name,
        type: "else",
        source: "(40:12) {:else}",
        ctx
      });
      return block;
    } // (36:12) {#if record.accoms && record.accoms.length}


    function create_if_block_4$2(ctx) {
      let each_1_anchor;
      let each_value_2 =
      /*record*/
      ctx[0].accoms;
      let each_blocks = [];

      for (let i = 0; i < each_value_2.length; i += 1) {
        each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
      }

      const block = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*record*/
          1) {
            each_value_2 =
            /*record*/
            ctx[0].accoms;
            let i;

            for (i = 0; i < each_value_2.length; i += 1) {
              const child_ctx = get_each_context_2(ctx, each_value_2, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_2(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_2.length;
          }
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$2.name,
        type: "if",
        source: "(36:12) {#if record.accoms && record.accoms.length}",
        ctx
      });
      return block;
    } // (37:16) {#each record.accoms as accom}


    function create_each_block_2(ctx) {
      let li;
      let t_value =
      /*accom*/
      ctx[9].name + "";
      let t;
      const block = {
        c: function create() {
          li = element("li");
          t = text(t_value);
          add_location(li, file$b, 37, 20, 1466);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*record*/
          1 && t_value !== (t_value =
          /*accom*/
          ctx[9].name + "")) set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2.name,
        type: "each",
        source: "(37:16) {#each record.accoms as accom}",
        ctx
      });
      return block;
    } // (55:12) {:else}


    function create_else_block_1$1(ctx) {
      let li;
      const block = {
        c: function create() {
          li = element("li");
          li.textContent = "None listed";
          add_location(li, file$b, 55, 16, 2277);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_1$1.name,
        type: "else",
        source: "(55:12) {:else}",
        ctx
      });
      return block;
    } // (47:12) {#if record.records && record.records.length}


    function create_if_block_3$3(ctx) {
      let each_1_anchor;
      let each_value_1 =
      /*record*/
      ctx[0].records;
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
      }

      const block = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*record, currentRecord, recordModalOpen, Date*/
          7) {
            each_value_1 =
            /*record*/
            ctx[0].records;
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_1$2(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_1.length;
          }
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$3.name,
        type: "if",
        source: "(47:12) {#if record.records && record.records.length}",
        ctx
      });
      return block;
    } // (48:16) {#each record.records as doc}


    function create_each_block_1$2(ctx) {
      let li;
      let a;
      let t0_value = "Issued " + (new Date(
      /*doc*/
      ctx[12].dateUpdated).getMonth() + 1) + "/" + new Date(
      /*doc*/
      ctx[12].dateUpdated).getDate() + "/" + new Date(
      /*doc*/
      ctx[12].dateUpdated).getFullYear() + "";
      let t0;
      let a_href_value;
      let t1;
      let dispose;

      function click_handler(...args) {
        return (
          /*click_handler*/
          ctx[5](
          /*doc*/
          ctx[12], ...args)
        );
      }

      const block = {
        c: function create() {
          li = element("li");
          a = element("a");
          t0 = text(t0_value);
          t1 = space();
          attr_dev(a, "href", a_href_value = "#record/" +
          /*record*/
          ctx[0].records._id);
          add_location(a, file$b, 49, 24, 1858);
          add_location(li, file$b, 48, 20, 1828);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, a);
          append_dev(a, t0);
          append_dev(li, t1);
          dispose = listen_dev(a, "click", prevent_default(click_handler), false, true, false);
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty &
          /*record*/
          1 && t0_value !== (t0_value = "Issued " + (new Date(
          /*doc*/
          ctx[12].dateUpdated).getMonth() + 1) + "/" + new Date(
          /*doc*/
          ctx[12].dateUpdated).getDate() + "/" + new Date(
          /*doc*/
          ctx[12].dateUpdated).getFullYear() + "")) set_data_dev(t0, t0_value);

          if (dirty &
          /*record*/
          1 && a_href_value !== (a_href_value = "#record/" +
          /*record*/
          ctx[0].records._id)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$2.name,
        type: "each",
        source: "(48:16) {#each record.records as doc}",
        ctx
      });
      return block;
    } // (62:0) {#if recordModalOpen}


    function create_if_block$6(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot$5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler*/
      ctx[8]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty &
          /*$$scope, recordModalOpen, currentRecord, $settings*/
          131086) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$6.name,
        type: "if",
        source: "(62:0) {#if recordModalOpen}",
        ctx
      });
      return block;
    } // (86:12) {:else}


    function create_else_block$3(ctx) {
      let li;
      let t0;
      let t1_value = formatText(
      /*$settings*/
      ctx[3].services, true, false) + "";
      let t1;
      let t2;
      const block = {
        c: function create() {
          li = element("li");
          t0 = text("No ");
          t1 = text(t1_value);
          t2 = text(" listed");
          add_location(li, file$b, 86, 16, 3639);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, t1);
          append_dev(li, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*$settings*/
          8 && t1_value !== (t1_value = formatText(
          /*$settings*/
          ctx[3].services, true, false) + "")) set_data_dev(t1, t1_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$3.name,
        type: "else",
        source: "(86:12) {:else}",
        ctx
      });
      return block;
    } // (79:12) {#if currentRecord.accoms.length > 0}


    function create_if_block_1$4(ctx) {
      let each_1_anchor;
      let each_value =
      /*currentRecord*/
      ctx[1].accoms;
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*currentRecord*/
          2) {
            each_value =
            /*currentRecord*/
            ctx[1].accoms;
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$9(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$9(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$4.name,
        type: "if",
        source: "(79:12) {#if currentRecord.accoms.length > 0}",
        ctx
      });
      return block;
    } // (80:16) {#each currentRecord.accoms as accom}


    function create_each_block$9(ctx) {
      let li;
      let h4;
      let t0_value =
      /*accom*/
      ctx[9].name + "";
      let t0;
      let t1;
      let p;
      let t2_value =
      /*accom*/
      ctx[9].content + "";
      let t2;
      let t3;
      const block = {
        c: function create() {
          li = element("li");
          h4 = element("h4");
          t0 = text(t0_value);
          t1 = space();
          p = element("p");
          t2 = text(t2_value);
          t3 = space();
          add_location(h4, file$b, 81, 24, 3479);
          add_location(p, file$b, 82, 24, 3526);
          attr_dev(li, "class", "whitebox");
          add_location(li, file$b, 80, 20, 3432);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, h4);
          append_dev(h4, t0);
          append_dev(li, t1);
          append_dev(li, p);
          append_dev(p, t2);
          append_dev(li, t3);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*currentRecord*/
          2 && t0_value !== (t0_value =
          /*accom*/
          ctx[9].name + "")) set_data_dev(t0, t0_value);
          if (dirty &
          /*currentRecord*/
          2 && t2_value !== (t2_value =
          /*accom*/
          ctx[9].content + "")) set_data_dev(t2, t2_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$9.name,
        type: "each",
        source: "(80:16) {#each currentRecord.accoms as accom}",
        ctx
      });
      return block;
    } // (63:4) <Modal on:forceClose={()=>{ recordModalOpen = false; currentRecord = {} }}>


    function create_default_slot$5(ctx) {
      let h3;
      let t0_value = new Date(
      /*currentRecord*/
      ctx[1].dateUpdated).getMonth() + 1 + "/" + new Date(
      /*currentRecord*/
      ctx[1].dateUpdated).getDate() + "/" + new Date(
      /*currentRecord*/
      ctx[1].dateUpdated).getFullYear() + "";
      let t0;
      let t1;
      let p0;
      let strong0;
      let t3_value = new Date(
      /*currentRecord*/
      ctx[1].dateUpdated).getMonth() + 1 + "/" + new Date(
      /*currentRecord*/
      ctx[1].dateUpdated).getDate() + "/" + new Date(
      /*currentRecord*/
      ctx[1].dateUpdated).getFullYear() + "";
      let t3;
      let t4;
      let h40;
      let t5_value = formatText(
      /*$settings*/
      ctx[3].students, false, true) + "";
      let t5;
      let t6;
      let t7;
      let p1;
      let strong1;
      let t9_value =
      /*currentRecord*/
      ctx[1].student.lname + ", " +
      /*currentRecord*/
      ctx[1].student.fname + "";
      let t9;
      let t10;
      let br;
      let t11;
      let strong2;
      let t13_value =
      /*currentRecord*/
      ctx[1].student._id + "";
      let t13;
      let t14;
      let h41;
      let t15;
      let t16_value = formatText(
      /*$settings*/
      ctx[3].services, true, true) + "";
      let t16;
      let t17;
      let ul;
      let t18;
      let h42;
      let t19_value = formatText(
      /*$settings*/
      ctx[3].students, false, true) + "";
      let t19;
      let t20;
      let t21;
      let p2;
      let t22_value = (
      /*currentRecord*/
      ctx[1].studentNotes ?
      /*currentRecord*/
      ctx[1].studentNotes : "Nothing specified") + "";
      let t22;
      let t23;
      let div;
      let button0;
      let t25;
      let button1;
      let dispose;

      function select_block_type_2(ctx, dirty) {
        if (
        /*currentRecord*/
        ctx[1].accoms.length > 0) return create_if_block_1$4;
        return create_else_block$3;
      }

      let current_block_type = select_block_type_2(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          h3 = element("h3");
          t0 = text(t0_value);
          t1 = space();
          p0 = element("p");
          strong0 = element("strong");
          strong0.textContent = "Date updated: ";
          t3 = text(t3_value);
          t4 = space();
          h40 = element("h4");
          t5 = text(t5_value);
          t6 = text(" Information");
          t7 = space();
          p1 = element("p");
          strong1 = element("strong");
          strong1.textContent = "Name: ";
          t9 = text(t9_value);
          t10 = space();
          br = element("br");
          t11 = space();
          strong2 = element("strong");
          strong2.textContent = "ID: ";
          t13 = text(t13_value);
          t14 = space();
          h41 = element("h4");
          t15 = text("Approved ");
          t16 = text(t16_value);
          t17 = space();
          ul = element("ul");
          if_block.c();
          t18 = space();
          h42 = element("h4");
          t19 = text(t19_value);
          t20 = text(" Notes");
          t21 = space();
          p2 = element("p");
          t22 = text(t22_value);
          t23 = space();
          div = element("div");
          button0 = element("button");
          button0.textContent = "OK";
          t25 = space();
          button1 = element("button");
          button1.textContent = "Print";
          add_location(h3, file$b, 63, 8, 2466);
          add_location(strong0, file$b, 66, 12, 2687);
          attr_dev(p0, "class", "mt-0");
          add_location(p0, file$b, 65, 8, 2657);
          add_location(h40, file$b, 69, 8, 2906);
          add_location(strong1, file$b, 71, 12, 3012);
          add_location(br, file$b, 72, 12, 3115);
          add_location(strong2, file$b, 73, 12, 3133);
          attr_dev(p1, "class", "mt-0");
          add_location(p1, file$b, 70, 8, 2982);
          add_location(h41, file$b, 76, 8, 3211);
          attr_dev(ul, "id", "accoms-list");
          attr_dev(ul, "class", "svelte-1ft8w8f");
          add_location(ul, file$b, 77, 8, 3283);
          add_location(h42, file$b, 90, 8, 3753);
          attr_dev(p2, "class", "mt-0");
          add_location(p2, file$b, 91, 8, 3823);
          attr_dev(button0, "class", "centered blue");
          attr_dev(button0, "type", "submit");
          add_location(button0, file$b, 94, 12, 3972);
          attr_dev(button1, "class", "centered");
          attr_dev(button1, "type", "submit");
          add_location(button1, file$b, 95, 12, 4122);
          attr_dev(div, "class", "align-ends");
          add_location(div, file$b, 93, 8, 3934);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          append_dev(h3, t0);
          insert_dev(target, t1, anchor);
          insert_dev(target, p0, anchor);
          append_dev(p0, strong0);
          append_dev(p0, t3);
          insert_dev(target, t4, anchor);
          insert_dev(target, h40, anchor);
          append_dev(h40, t5);
          append_dev(h40, t6);
          insert_dev(target, t7, anchor);
          insert_dev(target, p1, anchor);
          append_dev(p1, strong1);
          append_dev(p1, t9);
          append_dev(p1, t10);
          append_dev(p1, br);
          append_dev(p1, t11);
          append_dev(p1, strong2);
          append_dev(p1, t13);
          insert_dev(target, t14, anchor);
          insert_dev(target, h41, anchor);
          append_dev(h41, t15);
          append_dev(h41, t16);
          insert_dev(target, t17, anchor);
          insert_dev(target, ul, anchor);
          if_block.m(ul, null);
          insert_dev(target, t18, anchor);
          insert_dev(target, h42, anchor);
          append_dev(h42, t19);
          append_dev(h42, t20);
          insert_dev(target, t21, anchor);
          insert_dev(target, p2, anchor);
          append_dev(p2, t22);
          insert_dev(target, t23, anchor);
          insert_dev(target, div, anchor);
          append_dev(div, button0);
          append_dev(div, t25);
          append_dev(div, button1);
          dispose = [listen_dev(button0, "click", prevent_default(
          /*click_handler_1*/
          ctx[6]), false, true, false), listen_dev(button1, "click", prevent_default(
          /*click_handler_2*/
          ctx[7]), false, true, false)];
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*currentRecord*/
          2 && t0_value !== (t0_value = new Date(
          /*currentRecord*/
          ctx[1].dateUpdated).getMonth() + 1 + "/" + new Date(
          /*currentRecord*/
          ctx[1].dateUpdated).getDate() + "/" + new Date(
          /*currentRecord*/
          ctx[1].dateUpdated).getFullYear() + "")) set_data_dev(t0, t0_value);
          if (dirty &
          /*currentRecord*/
          2 && t3_value !== (t3_value = new Date(
          /*currentRecord*/
          ctx[1].dateUpdated).getMonth() + 1 + "/" + new Date(
          /*currentRecord*/
          ctx[1].dateUpdated).getDate() + "/" + new Date(
          /*currentRecord*/
          ctx[1].dateUpdated).getFullYear() + "")) set_data_dev(t3, t3_value);
          if (dirty &
          /*$settings*/
          8 && t5_value !== (t5_value = formatText(
          /*$settings*/
          ctx[3].students, false, true) + "")) set_data_dev(t5, t5_value);
          if (dirty &
          /*currentRecord*/
          2 && t9_value !== (t9_value =
          /*currentRecord*/
          ctx[1].student.lname + ", " +
          /*currentRecord*/
          ctx[1].student.fname + "")) set_data_dev(t9, t9_value);
          if (dirty &
          /*currentRecord*/
          2 && t13_value !== (t13_value =
          /*currentRecord*/
          ctx[1].student._id + "")) set_data_dev(t13, t13_value);
          if (dirty &
          /*$settings*/
          8 && t16_value !== (t16_value = formatText(
          /*$settings*/
          ctx[3].services, true, true) + "")) set_data_dev(t16, t16_value);

          if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(ul, null);
            }
          }

          if (dirty &
          /*$settings*/
          8 && t19_value !== (t19_value = formatText(
          /*$settings*/
          ctx[3].students, false, true) + "")) set_data_dev(t19, t19_value);
          if (dirty &
          /*currentRecord*/
          2 && t22_value !== (t22_value = (
          /*currentRecord*/
          ctx[1].studentNotes ?
          /*currentRecord*/
          ctx[1].studentNotes : "Nothing specified") + "")) set_data_dev(t22, t22_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(p0);
          if (detaching) detach_dev(t4);
          if (detaching) detach_dev(h40);
          if (detaching) detach_dev(t7);
          if (detaching) detach_dev(p1);
          if (detaching) detach_dev(t14);
          if (detaching) detach_dev(h41);
          if (detaching) detach_dev(t17);
          if (detaching) detach_dev(ul);
          if_block.d();
          if (detaching) detach_dev(t18);
          if (detaching) detach_dev(h42);
          if (detaching) detach_dev(t21);
          if (detaching) detach_dev(p2);
          if (detaching) detach_dev(t23);
          if (detaching) detach_dev(div);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$5.name,
        type: "slot",
        source: "(63:4) <Modal on:forceClose={()=>{ recordModalOpen = false; currentRecord = {} }}>",
        ctx
      });
      return block;
    }

    function create_fragment$b(ctx) {
      let t;
      let if_block1_anchor;
      let current;
      let if_block0 =
      /*record*/
      ctx[0] && create_if_block_2$3(ctx);
      let if_block1 =
      /*recordModalOpen*/
      ctx[2] && create_if_block$6(ctx);
      const block = {
        c: function create() {
          if (if_block0) if_block0.c();
          t = space();
          if (if_block1) if_block1.c();
          if_block1_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block0) if_block0.m(target, anchor);
          insert_dev(target, t, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (
          /*record*/
          ctx[0]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
              transition_in(if_block0, 1);
            } else {
              if_block0 = create_if_block_2$3(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(t.parentNode, t);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*recordModalOpen*/
          ctx[2]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
              transition_in(if_block1, 1);
            } else {
              if_block1 = create_if_block$6(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach_dev(t);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach_dev(if_block1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$b.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
      let $settings;
      validate_store(settings, "settings");
      component_subscribe($$self, settings, $$value => $$invalidate(3, $settings = $$value));
      let sid = "";
      let record = null;
      let currentRecord = {};
      let recordModalOpen = false;
      onMount(() => {
        sid = window.location.hash.split("/")[1];
        loadRecords(sid, $settings.databasedir).then(result => {
          $$invalidate(0, record = result);
        });
      });

      const click_handler = doc => {
        $$invalidate(1, currentRecord = doc);
        $$invalidate(2, recordModalOpen = true);
      };

      const click_handler_1 = () => {
        $$invalidate(2, recordModalOpen = false);
        $$invalidate(1, currentRecord = {});
      };

      const click_handler_2 = () => {
        $$invalidate(2, recordModalOpen = false);
        $$invalidate(1, currentRecord = {});
      };

      const forceClose_handler = () => {
        $$invalidate(2, recordModalOpen = false);
        $$invalidate(1, currentRecord = {});
      };

      $$self.$capture_state = () => {
        return {};
      };

      $$self.$inject_state = $$props => {
        if ("sid" in $$props) sid = $$props.sid;
        if ("record" in $$props) $$invalidate(0, record = $$props.record);
        if ("currentRecord" in $$props) $$invalidate(1, currentRecord = $$props.currentRecord);
        if ("recordModalOpen" in $$props) $$invalidate(2, recordModalOpen = $$props.recordModalOpen);
        if ("$settings" in $$props) settings.set($settings = $$props.$settings);
      };

      return [record, currentRecord, recordModalOpen, $settings, sid, click_handler, click_handler_1, click_handler_2, forceClose_handler];
    }

    class Record extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$b, create_fragment$b, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Record",
          options,
          id: create_fragment$b.name
        });
      }

    }

    var quill = createCommonjsModule(function (module, exports) {
    /*!
     * Quill Editor v2.0.0-dev.3
     * https://quilljs.com/
     * Copyright (c) 2014, Jason Chen
     * Copyright (c) 2013, salesforce.com
     */
    (function webpackUniversalModuleDefinition(root, factory) {
      module.exports = factory();
    })(window, function () {
      return (
        /******/
        function (modules) {
          // webpackBootstrap

          /******/
          // The module cache

          /******/
          var installedModules = {};
          /******/

          /******/
          // The require function

          /******/

          function __webpack_require__(moduleId) {
            /******/

            /******/
            // Check if module is in cache

            /******/
            if (installedModules[moduleId]) {
              /******/
              return installedModules[moduleId].exports;
              /******/
            }
            /******/
            // Create a new module (and put it into the cache)

            /******/


            var module = installedModules[moduleId] = {
              /******/
              i: moduleId,

              /******/
              l: false,

              /******/
              exports: {}
              /******/

            };
            /******/

            /******/
            // Execute the module function

            /******/

            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /******/

            /******/
            // Flag the module as loaded

            /******/

            module.l = true;
            /******/

            /******/
            // Return the exports of the module

            /******/

            return module.exports;
            /******/
          }
          /******/

          /******/

          /******/
          // expose the modules object (__webpack_modules__)

          /******/


          __webpack_require__.m = modules;
          /******/

          /******/
          // expose the module cache

          /******/

          __webpack_require__.c = installedModules;
          /******/

          /******/
          // define getter function for harmony exports

          /******/

          __webpack_require__.d = function (exports, name, getter) {
            /******/
            if (!__webpack_require__.o(exports, name)) {
              /******/
              Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
              });
              /******/
            }
            /******/

          };
          /******/

          /******/
          // define __esModule on exports

          /******/


          __webpack_require__.r = function (exports) {
            /******/
            if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /******/
              Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
              });
              /******/
            }
            /******/


            Object.defineProperty(exports, '__esModule', {
              value: true
            });
            /******/
          };
          /******/

          /******/
          // create a fake namespace object

          /******/
          // mode & 1: value is a module id, require it

          /******/
          // mode & 2: merge all properties of value into the ns

          /******/
          // mode & 4: return value when already ns object

          /******/
          // mode & 8|1: behave like require

          /******/


          __webpack_require__.t = function (value, mode) {
            /******/
            if (mode & 1) value = __webpack_require__(value);
            /******/

            if (mode & 8) return value;
            /******/

            if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
            /******/

            var ns = Object.create(null);
            /******/

            __webpack_require__.r(ns);
            /******/


            Object.defineProperty(ns, 'default', {
              enumerable: true,
              value: value
            });
            /******/

            if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {
              return value[key];
            }.bind(null, key));
            /******/

            return ns;
            /******/
          };
          /******/

          /******/
          // getDefaultExport function for compatibility with non-harmony modules

          /******/


          __webpack_require__.n = function (module) {
            /******/
            var getter = module && module.__esModule ?
            /******/
            function getDefault() {
              return module['default'];
            } :
            /******/
            function getModuleExports() {
              return module;
            };
            /******/

            __webpack_require__.d(getter, 'a', getter);
            /******/


            return getter;
            /******/
          };
          /******/

          /******/
          // Object.prototype.hasOwnProperty.call

          /******/


          __webpack_require__.o = function (object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          /******/

          /******/
          // __webpack_public_path__

          /******/


          __webpack_require__.p = "";
          /******/

          /******/

          /******/
          // Load entry module and return exports

          /******/

          return __webpack_require__(__webpack_require__.s = 0);
          /******/
        }(
        /************************************************************************/

        /******/
        {
          /***/
          "./assets/icons/align-center.svg":
          /*!***************************************!*\
            !*** ./assets/icons/align-center.svg ***!
            \***************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/align-center.svg?");
            /***/
          },

          /***/
          "./assets/icons/align-justify.svg":
          /*!****************************************!*\
            !*** ./assets/icons/align-justify.svg ***!
            \****************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/align-justify.svg?");
            /***/
          },

          /***/
          "./assets/icons/align-left.svg":
          /*!*************************************!*\
            !*** ./assets/icons/align-left.svg ***!
            \*************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/align-left.svg?");
            /***/
          },

          /***/
          "./assets/icons/align-right.svg":
          /*!**************************************!*\
            !*** ./assets/icons/align-right.svg ***!
            \**************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/align-right.svg?");
            /***/
          },

          /***/
          "./assets/icons/background.svg":
          /*!*************************************!*\
            !*** ./assets/icons/background.svg ***!
            \*************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <g class=\\\"ql-fill ql-color-label\\\"> <polygon points=\\\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\\\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\\\"6.817 5 6 5 6 6 6.38 6 6.817 5\\\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\\\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\\\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\\\"4.63 10 4 10 4 11 4.192 11 4.63 10\\\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\\\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\\\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\\\"12 6.868 12 6 11.62 6 12 6.868\\\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\\\"12.933 9 13 9 13 8 12.495 8 12.933 9\\\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\\\"5.5 13 9 5 12.5 13\\\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/background.svg?");
            /***/
          },

          /***/
          "./assets/icons/blockquote.svg":
          /*!*************************************!*\
            !*** ./assets/icons/blockquote.svg ***!
            \*************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <rect class=\\\"ql-fill ql-stroke\\\" height=3 width=3 x=4 y=5></rect> <rect class=\\\"ql-fill ql-stroke\\\" height=3 width=3 x=11 y=5></rect> <path class=\\\"ql-even ql-fill ql-stroke\\\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\\\"ql-even ql-fill ql-stroke\\\" d=M14,8c0,4.031-3,5-3,5></path> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/blockquote.svg?");
            /***/
          },

          /***/
          "./assets/icons/bold.svg":
          /*!*******************************!*\
            !*** ./assets/icons/bold.svg ***!
            \*******************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/bold.svg?");
            /***/
          },

          /***/
          "./assets/icons/clean.svg":
          /*!********************************!*\
            !*** ./assets/icons/clean.svg ***!
            \********************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg class=\\\"\\\" viewbox=\\\"0 0 18 18\\\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/clean.svg?");
            /***/
          },

          /***/
          "./assets/icons/code.svg":
          /*!*******************************!*\
            !*** ./assets/icons/code.svg ***!
            \*******************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <polyline class=\\\"ql-even ql-stroke\\\" points=\\\"5 7 3 9 5 11\\\"></polyline> <polyline class=\\\"ql-even ql-stroke\\\" points=\\\"13 7 15 9 13 11\\\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/code.svg?");
            /***/
          },

          /***/
          "./assets/icons/color.svg":
          /*!********************************!*\
            !*** ./assets/icons/color.svg ***!
            \********************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <line class=\\\"ql-color-label ql-stroke ql-transparent\\\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\\\"5.5 11 9 3 12.5 11\\\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/color.svg?");
            /***/
          },

          /***/
          "./assets/icons/direction-ltr.svg":
          /*!****************************************!*\
            !*** ./assets/icons/direction-ltr.svg ***!
            \****************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <polygon class=\\\"ql-stroke ql-fill\\\" points=\\\"3 11 5 9 3 7 3 11\\\"></polygon> <line class=\\\"ql-stroke ql-fill\\\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/direction-ltr.svg?");
            /***/
          },

          /***/
          "./assets/icons/direction-rtl.svg":
          /*!****************************************!*\
            !*** ./assets/icons/direction-rtl.svg ***!
            \****************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <polygon class=\\\"ql-stroke ql-fill\\\" points=\\\"15 12 13 10 15 8 15 12\\\"></polygon> <line class=\\\"ql-stroke ql-fill\\\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/direction-rtl.svg?");
            /***/
          },

          /***/
          "./assets/icons/dropdown.svg":
          /*!***********************************!*\
            !*** ./assets/icons/dropdown.svg ***!
            \***********************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <polygon class=ql-stroke points=\\\"7 11 9 13 11 11 7 11\\\"></polygon> <polygon class=ql-stroke points=\\\"7 7 9 5 11 7 7 7\\\"></polygon> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/dropdown.svg?");
            /***/
          },

          /***/
          "./assets/icons/formula.svg":
          /*!**********************************!*\
            !*** ./assets/icons/formula.svg ***!
            \**********************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/formula.svg?");
            /***/
          },

          /***/
          "./assets/icons/header-2.svg":
          /*!***********************************!*\
            !*** ./assets/icons/header-2.svg ***!
            \***********************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewBox=\\\"0 0 18 18\\\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/header-2.svg?");
            /***/
          },

          /***/
          "./assets/icons/header.svg":
          /*!*********************************!*\
            !*** ./assets/icons/header.svg ***!
            \*********************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewBox=\\\"0 0 18 18\\\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/header.svg?");
            /***/
          },

          /***/
          "./assets/icons/image.svg":
          /*!********************************!*\
            !*** ./assets/icons/image.svg ***!
            \********************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\\\"ql-even ql-fill\\\" points=\\\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\\\"></polyline> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/image.svg?");
            /***/
          },

          /***/
          "./assets/icons/indent.svg":
          /*!*********************************!*\
            !*** ./assets/icons/indent.svg ***!
            \*********************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\\\"ql-fill ql-stroke\\\" points=\\\"3 7 3 11 5 9 3 7\\\"></polyline> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/indent.svg?");
            /***/
          },

          /***/
          "./assets/icons/italic.svg":
          /*!*********************************!*\
            !*** ./assets/icons/italic.svg ***!
            \*********************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/italic.svg?");
            /***/
          },

          /***/
          "./assets/icons/link.svg":
          /*!*******************************!*\
            !*** ./assets/icons/link.svg ***!
            \*******************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\\\"ql-even ql-stroke\\\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\\\"ql-even ql-stroke\\\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/link.svg?");
            /***/
          },

          /***/
          "./assets/icons/list-bullet.svg":
          /*!**************************************!*\
            !*** ./assets/icons/list-bullet.svg ***!
            \**************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/list-bullet.svg?");
            /***/
          },

          /***/
          "./assets/icons/list-check.svg":
          /*!*************************************!*\
            !*** ./assets/icons/list-check.svg ***!
            \*************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg class=\\\"\\\" viewbox=\\\"0 0 18 18\\\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\\\"3 4 4 5 6 3\\\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\\\"3 14 4 15 6 13\\\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\\\"3 9 4 10 6 8\\\"></polyline> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/list-check.svg?");
            /***/
          },

          /***/
          "./assets/icons/list-ordered.svg":
          /*!***************************************!*\
            !*** ./assets/icons/list-ordered.svg ***!
            \***************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\\\"ql-stroke ql-thin\\\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\\\"ql-stroke ql-thin\\\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\\\"ql-stroke ql-thin\\\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/list-ordered.svg?");
            /***/
          },

          /***/
          "./assets/icons/outdent.svg":
          /*!**********************************!*\
            !*** ./assets/icons/outdent.svg ***!
            \**********************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\\\"5 7 5 11 3 9 5 7\\\"></polyline> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/outdent.svg?");
            /***/
          },

          /***/
          "./assets/icons/strike.svg":
          /*!*********************************!*\
            !*** ./assets/icons/strike.svg ***!
            \*********************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <line class=\\\"ql-stroke ql-thin\\\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/strike.svg?");
            /***/
          },

          /***/
          "./assets/icons/subscript.svg":
          /*!************************************!*\
            !*** ./assets/icons/subscript.svg ***!
            \************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/subscript.svg?");
            /***/
          },

          /***/
          "./assets/icons/superscript.svg":
          /*!**************************************!*\
            !*** ./assets/icons/superscript.svg ***!
            \**************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/superscript.svg?");
            /***/
          },

          /***/
          "./assets/icons/table.svg":
          /*!********************************!*\
            !*** ./assets/icons/table.svg ***!
            \********************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=2 width=3 x=5 y=5></rect> <rect class=ql-fill height=2 width=4 x=9 y=5></rect> <g class=\\\"ql-fill ql-transparent\\\"> <rect height=2 width=3 x=5 y=8></rect> <rect height=2 width=4 x=9 y=8></rect> <rect height=2 width=3 x=5 y=11></rect> <rect height=2 width=4 x=9 y=11></rect> </g> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/table.svg?");
            /***/
          },

          /***/
          "./assets/icons/underline.svg":
          /*!************************************!*\
            !*** ./assets/icons/underline.svg ***!
            \************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/underline.svg?");
            /***/
          },

          /***/
          "./assets/icons/video.svg":
          /*!********************************!*\
            !*** ./assets/icons/video.svg ***!
            \********************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("module.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>\";\n\n//# sourceURL=webpack://Quill/./assets/icons/video.svg?");
            /***/
          },

          /***/
          "./blots/block.js":
          /*!************************!*\
            !*** ./blots/block.js ***!
            \************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.BlockEmbed = exports.bubbleFormats = exports.blockDelta = undefined;\n\nvar _extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _quillDelta = __webpack_require__(/*! quill-delta */ \"./node_modules/quill-delta/dist/Delta.js\");\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _break = __webpack_require__(/*! ./break */ \"./blots/break.js\");\n\nvar _break2 = _interopRequireDefault(_break);\n\nvar _inline = __webpack_require__(/*! ./inline */ \"./blots/inline.js\");\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _text = __webpack_require__(/*! ./text */ \"./blots/text.js\");\n\nvar _text2 = _interopRequireDefault(_text);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst NEWLINE_LENGTH = 1;\n\nclass Block extends _parchment.BlockBlot {\n  constructor(scroll, domNode) {\n    super(scroll, domNode);\n    this.cache = {};\n  }\n\n  delta() {\n    if (this.cache.delta == null) {\n      this.cache.delta = blockDelta(this);\n    }\n    return this.cache.delta;\n  }\n\n  deleteAt(index, length) {\n    super.deleteAt(index, length);\n    this.cache = {};\n  }\n\n  formatAt(index, length, name, value) {\n    if (length <= 0) return;\n    if (this.scroll.query(name, _parchment.Scope.BLOCK)) {\n      if (index + length === this.length()) {\n        this.format(name, value);\n      }\n    } else {\n      super.formatAt(index, Math.min(length, this.length() - index - 1), name, value);\n    }\n    this.cache = {};\n  }\n\n  insertAt(index, value, def) {\n    if (def != null) {\n      super.insertAt(index, value, def);\n      this.cache = {};\n      return;\n    }\n    if (value.length === 0) return;\n    const lines = value.split('\\n');\n    const text = lines.shift();\n    if (text.length > 0) {\n      if (index < this.length() - 1 || this.children.tail == null) {\n        super.insertAt(Math.min(index, this.length() - 1), text);\n      } else {\n        this.children.tail.insertAt(this.children.tail.length(), text);\n      }\n      this.cache = {};\n    }\n    let block = this;\n    lines.reduce((lineIndex, line) => {\n      block = block.split(lineIndex, true);\n      block.insertAt(0, line);\n      return line.length;\n    }, index + text.length);\n  }\n\n  insertBefore(blot, ref) {\n    const head = this.children.head;\n\n    super.insertBefore(blot, ref);\n    if (head instanceof _break2.default) {\n      head.remove();\n    }\n    this.cache = {};\n  }\n\n  length() {\n    if (this.cache.length == null) {\n      this.cache.length = super.length() + NEWLINE_LENGTH;\n    }\n    return this.cache.length;\n  }\n\n  moveChildren(target, ref) {\n    super.moveChildren(target, ref);\n    this.cache = {};\n  }\n\n  optimize(context) {\n    super.optimize(context);\n    this.cache = {};\n  }\n\n  path(index) {\n    return super.path(index, true);\n  }\n\n  removeChild(child) {\n    super.removeChild(child);\n    this.cache = {};\n  }\n\n  split(index, force = false) {\n    if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {\n      const clone = this.clone();\n      if (index === 0) {\n        this.parent.insertBefore(clone, this);\n        return this;\n      }\n      this.parent.insertBefore(clone, this.next);\n      return clone;\n    }\n    const next = super.split(index, force);\n    this.cache = {};\n    return next;\n  }\n}\nBlock.blotName = 'block';\nBlock.tagName = 'P';\nBlock.defaultChild = _break2.default;\nBlock.allowedChildren = [_break2.default, _inline2.default, _parchment.EmbedBlot, _text2.default];\n\nclass BlockEmbed extends _parchment.EmbedBlot {\n  attach() {\n    super.attach();\n    this.attributes = new _parchment.AttributorStore(this.domNode);\n  }\n\n  delta() {\n    return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));\n  }\n\n  format(name, value) {\n    const attribute = this.scroll.query(name, _parchment.Scope.BLOCK_ATTRIBUTE);\n    if (attribute != null) {\n      this.attributes.attribute(attribute, value);\n    }\n  }\n\n  formatAt(index, length, name, value) {\n    this.format(name, value);\n  }\n\n  insertAt(index, value, def) {\n    if (typeof value === 'string' && value.endsWith('\\n')) {\n      const block = this.scroll.create(Block.blotName);\n      this.parent.insertBefore(block, index === 0 ? this : this.next);\n      block.insertAt(0, value.slice(0, -1));\n    } else {\n      super.insertAt(index, value, def);\n    }\n  }\n}\nBlockEmbed.scope = _parchment.Scope.BLOCK_BLOT;\n// It is important for cursor behavior BlockEmbeds use tags that are block level elements\n\nfunction blockDelta(blot) {\n  return blot.descendants(_parchment.LeafBlot).reduce((delta, leaf) => {\n    if (leaf.length() === 0) {\n      return delta;\n    }\n    return delta.insert(leaf.value(), bubbleFormats(leaf));\n  }, new _quillDelta2.default()).insert('\\n', bubbleFormats(blot));\n}\n\nfunction bubbleFormats(blot, formats = {}) {\n  if (blot == null) return formats;\n  if (typeof blot.formats === 'function') {\n    formats = (0, _extend2.default)(formats, blot.formats());\n    // exclude syntax highlighting from deltas and getFormat()\n    delete formats['code-token'];\n  }\n  if (blot.parent == null || blot.parent.statics.blotName === 'scroll' || blot.parent.statics.scope !== blot.statics.scope) {\n    return formats;\n  }\n  return bubbleFormats(blot.parent, formats);\n}\n\nexports.blockDelta = blockDelta;\nexports.bubbleFormats = bubbleFormats;\nexports.BlockEmbed = BlockEmbed;\nexports.default = Block;\n\n//# sourceURL=webpack://Quill/./blots/block.js?");
            /***/
          },

          /***/
          "./blots/break.js":
          /*!************************!*\
            !*** ./blots/break.js ***!
            \************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nclass Break extends _parchment.EmbedBlot {\n  static value() {\n    return undefined;\n  }\n\n  optimize() {\n    if (this.prev || this.next) {\n      this.remove();\n    }\n  }\n\n  length() {\n    return 0;\n  }\n\n  value() {\n    return '';\n  }\n}\nBreak.blotName = 'break';\nBreak.tagName = 'BR';\n\nexports.default = Break;\n\n//# sourceURL=webpack://Quill/./blots/break.js?");
            /***/
          },

          /***/
          "./blots/container.js":
          /*!****************************!*\
            !*** ./blots/container.js ***!
            \****************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nclass Container extends _parchment.ContainerBlot {}\n\nexports.default = Container;\n\n//# sourceURL=webpack://Quill/./blots/container.js?");
            /***/
          },

          /***/
          "./blots/cursor.js":
          /*!*************************!*\
            !*** ./blots/cursor.js ***!
            \*************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _text = __webpack_require__(/*! ./text */ \"./blots/text.js\");\n\nvar _text2 = _interopRequireDefault(_text);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Cursor extends _parchment.EmbedBlot {\n  static value() {\n    return undefined;\n  }\n\n  constructor(scroll, domNode, selection) {\n    super(scroll, domNode);\n    this.selection = selection;\n    this.textNode = document.createTextNode(Cursor.CONTENTS);\n    this.domNode.appendChild(this.textNode);\n    this.savedLength = 0;\n  }\n\n  detach() {\n    // super.detach() will also clear domNode.__blot\n    if (this.parent != null) this.parent.removeChild(this);\n  }\n\n  format(name, value) {\n    if (this.savedLength !== 0) {\n      super.format(name, value);\n      return;\n    }\n    let target = this;\n    let index = 0;\n    while (target != null && target.statics.scope !== _parchment.Scope.BLOCK_BLOT) {\n      index += target.offset(target.parent);\n      target = target.parent;\n    }\n    if (target != null) {\n      this.savedLength = Cursor.CONTENTS.length;\n      target.optimize();\n      target.formatAt(index, Cursor.CONTENTS.length, name, value);\n      this.savedLength = 0;\n    }\n  }\n\n  index(node, offset) {\n    if (node === this.textNode) return 0;\n    return super.index(node, offset);\n  }\n\n  length() {\n    return this.savedLength;\n  }\n\n  position() {\n    return [this.textNode, this.textNode.data.length];\n  }\n\n  remove() {\n    super.remove();\n    this.parent = null;\n  }\n\n  restore() {\n    if (this.selection.composing || this.parent == null) return null;\n    const range = this.selection.getNativeRange();\n    // Link format will insert text outside of anchor tag\n    while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {\n      this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);\n    }\n\n    const prevTextBlot = this.prev instanceof _text2.default ? this.prev : null;\n    const prevTextLength = prevTextBlot ? prevTextBlot.length() : 0;\n    const nextTextBlot = this.next instanceof _text2.default ? this.next : null;\n    const nextText = nextTextBlot ? nextTextBlot.text : '';\n    const textNode = this.textNode;\n    // take text from inside this blot and reset it\n\n    const newText = textNode.data.split(Cursor.CONTENTS).join('');\n    textNode.data = Cursor.CONTENTS;\n\n    // proactively merge TextBlots around cursor so that optimization\n    // doesn't lose the cursor.  the reason we are here in cursor.restore\n    // could be that the user clicked in prevTextBlot or nextTextBlot, or\n    // the user typed something.\n    let mergedTextBlot;\n    if (prevTextBlot) {\n      mergedTextBlot = prevTextBlot;\n      if (newText || nextTextBlot) {\n        prevTextBlot.insertAt(prevTextBlot.length(), newText + nextText);\n        if (nextTextBlot) {\n          nextTextBlot.remove();\n        }\n      }\n    } else if (nextTextBlot) {\n      mergedTextBlot = nextTextBlot;\n      nextTextBlot.insertAt(0, newText);\n    } else {\n      const newTextNode = document.createTextNode(newText);\n      mergedTextBlot = this.scroll.create(newTextNode);\n      this.parent.insertBefore(mergedTextBlot, this);\n    }\n\n    this.remove();\n    if (range) {\n      // calculate selection to restore\n      const remapOffset = (node, offset) => {\n        if (prevTextBlot && node === prevTextBlot.domNode) {\n          return offset;\n        }\n        if (node === textNode) {\n          return prevTextLength + offset - 1;\n        }\n        if (nextTextBlot && node === nextTextBlot.domNode) {\n          return prevTextLength + newText.length + offset;\n        }\n        return null;\n      };\n\n      const start = remapOffset(range.start.node, range.start.offset);\n      const end = remapOffset(range.end.node, range.end.offset);\n      if (start !== null && end !== null) {\n        return {\n          startNode: mergedTextBlot.domNode,\n          startOffset: start,\n          endNode: mergedTextBlot.domNode,\n          endOffset: end\n        };\n      }\n    }\n    return null;\n  }\n\n  update(mutations, context) {\n    if (mutations.some(mutation => {\n      return mutation.type === 'characterData' && mutation.target === this.textNode;\n    })) {\n      const range = this.restore();\n      if (range) context.range = range;\n    }\n  }\n\n  value() {\n    return '';\n  }\n}\nCursor.blotName = 'cursor';\nCursor.className = 'ql-cursor';\nCursor.tagName = 'span';\nCursor.CONTENTS = '\\uFEFF'; // Zero width no break space\n\nexports.default = Cursor;\n\n//# sourceURL=webpack://Quill/./blots/cursor.js?");
            /***/
          },

          /***/
          "./blots/embed.js":
          /*!************************!*\
            !*** ./blots/embed.js ***!
            \************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _text = __webpack_require__(/*! ./text */ \"./blots/text.js\");\n\nvar _text2 = _interopRequireDefault(_text);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst GUARD_TEXT = '\\uFEFF';\n\nclass Embed extends _parchment.EmbedBlot {\n  constructor(scroll, node) {\n    super(scroll, node);\n    this.contentNode = document.createElement('span');\n    this.contentNode.setAttribute('contenteditable', false);\n    Array.from(this.domNode.childNodes).forEach(childNode => {\n      this.contentNode.appendChild(childNode);\n    });\n    this.leftGuard = document.createTextNode(GUARD_TEXT);\n    this.rightGuard = document.createTextNode(GUARD_TEXT);\n    this.domNode.appendChild(this.leftGuard);\n    this.domNode.appendChild(this.contentNode);\n    this.domNode.appendChild(this.rightGuard);\n  }\n\n  index(node, offset) {\n    if (node === this.leftGuard) return 0;\n    if (node === this.rightGuard) return 1;\n    return super.index(node, offset);\n  }\n\n  restore(node) {\n    let range;\n    let textNode;\n    const text = node.data.split(GUARD_TEXT).join('');\n    if (node === this.leftGuard) {\n      if (this.prev instanceof _text2.default) {\n        const prevLength = this.prev.length();\n        this.prev.insertAt(prevLength, text);\n        range = {\n          startNode: this.prev.domNode,\n          startOffset: prevLength + text.length\n        };\n      } else {\n        textNode = document.createTextNode(text);\n        this.parent.insertBefore(this.scroll.create(textNode), this);\n        range = {\n          startNode: textNode,\n          startOffset: text.length\n        };\n      }\n    } else if (node === this.rightGuard) {\n      if (this.next instanceof _text2.default) {\n        this.next.insertAt(0, text);\n        range = {\n          startNode: this.next.domNode,\n          startOffset: text.length\n        };\n      } else {\n        textNode = document.createTextNode(text);\n        this.parent.insertBefore(this.scroll.create(textNode), this.next);\n        range = {\n          startNode: textNode,\n          startOffset: text.length\n        };\n      }\n    }\n    node.data = GUARD_TEXT;\n    return range;\n  }\n\n  update(mutations, context) {\n    mutations.forEach(mutation => {\n      if (mutation.type === 'characterData' && (mutation.target === this.leftGuard || mutation.target === this.rightGuard)) {\n        const range = this.restore(mutation.target);\n        if (range) context.range = range;\n      }\n    });\n  }\n}\n\nexports.default = Embed;\n\n//# sourceURL=webpack://Quill/./blots/embed.js?");
            /***/
          },

          /***/
          "./blots/inline.js":
          /*!*************************!*\
            !*** ./blots/inline.js ***!
            \*************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _break = __webpack_require__(/*! ./break */ \"./blots/break.js\");\n\nvar _break2 = _interopRequireDefault(_break);\n\nvar _text = __webpack_require__(/*! ./text */ \"./blots/text.js\");\n\nvar _text2 = _interopRequireDefault(_text);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Inline extends _parchment.InlineBlot {\n  static compare(self, other) {\n    const selfIndex = Inline.order.indexOf(self);\n    const otherIndex = Inline.order.indexOf(other);\n    if (selfIndex >= 0 || otherIndex >= 0) {\n      return selfIndex - otherIndex;\n    }\n    if (self === other) {\n      return 0;\n    }\n    if (self < other) {\n      return -1;\n    }\n    return 1;\n  }\n\n  formatAt(index, length, name, value) {\n    if (Inline.compare(this.statics.blotName, name) < 0 && this.scroll.query(name, _parchment.Scope.BLOT)) {\n      const blot = this.isolate(index, length);\n      if (value) {\n        blot.wrap(name, value);\n      }\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  optimize(context) {\n    super.optimize(context);\n    if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {\n      const parent = this.parent.isolate(this.offset(), this.length());\n      this.moveChildren(parent);\n      parent.wrap(this);\n    }\n  }\n}\nInline.allowedChildren = [Inline, _break2.default, _parchment.EmbedBlot, _text2.default];\n// Lower index means deeper in the DOM tree, since not found (-1) is for embeds\nInline.order = ['cursor', 'inline', // Must be lower\n'underline', 'strike', 'italic', 'bold', 'script', 'link', 'code'];\n\nexports.default = Inline;\n\n//# sourceURL=webpack://Quill/./blots/inline.js?");
            /***/
          },

          /***/
          "./blots/scroll.js":
          /*!*************************!*\
            !*** ./blots/scroll.js ***!
            \*************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _emitter = __webpack_require__(/*! ../core/emitter */ \"./core/emitter.js\");\n\nvar _emitter2 = _interopRequireDefault(_emitter);\n\nvar _block = __webpack_require__(/*! ./block */ \"./blots/block.js\");\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _break = __webpack_require__(/*! ./break */ \"./blots/break.js\");\n\nvar _break2 = _interopRequireDefault(_break);\n\nvar _container = __webpack_require__(/*! ./container */ \"./blots/container.js\");\n\nvar _container2 = _interopRequireDefault(_container);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isLine(blot) {\n  return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;\n}\n\nclass Scroll extends _parchment.ScrollBlot {\n  constructor(registry, domNode, { emitter }) {\n    super(registry, domNode);\n    this.emitter = emitter;\n    this.batch = false;\n    this.optimize();\n    this.enable();\n  }\n\n  batchStart() {\n    if (!Array.isArray(this.batch)) {\n      this.batch = [];\n    }\n  }\n\n  batchEnd() {\n    const mutations = this.batch;\n    this.batch = false;\n    this.update(mutations);\n  }\n\n  emitMount(blot) {\n    this.emitter.emit(_emitter2.default.events.SCROLL_BLOT_MOUNT, blot);\n  }\n\n  emitUnmount(blot) {\n    this.emitter.emit(_emitter2.default.events.SCROLL_BLOT_UNMOUNT, blot);\n  }\n\n  deleteAt(index, length) {\n    var _line = this.line(index),\n        _line2 = _slicedToArray(_line, 2);\n\n    const first = _line2[0],\n          offset = _line2[1];\n\n    var _line3 = this.line(index + length),\n        _line4 = _slicedToArray(_line3, 1);\n\n    const last = _line4[0];\n\n    super.deleteAt(index, length);\n    if (last != null && first !== last && offset > 0) {\n      if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {\n        this.optimize();\n        return;\n      }\n      const ref = last.children.head instanceof _break2.default ? null : last.children.head;\n      first.moveChildren(last, ref);\n      first.remove();\n    }\n    this.optimize();\n  }\n\n  enable(enabled = true) {\n    this.domNode.setAttribute('contenteditable', enabled);\n  }\n\n  formatAt(index, length, format, value) {\n    super.formatAt(index, length, format, value);\n    this.optimize();\n  }\n\n  insertAt(index, value, def) {\n    if (index >= this.length()) {\n      if (def == null || this.scroll.query(value, _parchment.Scope.BLOCK) == null) {\n        const blot = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(blot);\n        if (def == null && value.endsWith('\\n')) {\n          blot.insertAt(0, value.slice(0, -1), def);\n        } else {\n          blot.insertAt(0, value, def);\n        }\n      } else {\n        const embed = this.scroll.create(value, def);\n        this.appendChild(embed);\n      }\n    } else {\n      super.insertAt(index, value, def);\n    }\n    this.optimize();\n  }\n\n  insertBefore(blot, ref) {\n    if (blot.statics.scope === _parchment.Scope.INLINE_BLOT) {\n      const wrapper = this.scroll.create(this.statics.defaultChild.blotName);\n      wrapper.appendChild(blot);\n      super.insertBefore(wrapper, ref);\n    } else {\n      super.insertBefore(blot, ref);\n    }\n  }\n\n  isEnabled() {\n    return this.domNode.getAttribute('contenteditable') === 'true';\n  }\n\n  leaf(index) {\n    return this.path(index).pop() || [null, -1];\n  }\n\n  line(index) {\n    if (index === this.length()) {\n      return this.line(index - 1);\n    }\n    return this.descendant(isLine, index);\n  }\n\n  lines(index = 0, length = Number.MAX_VALUE) {\n    const getLines = (blot, blotIndex, blotLength) => {\n      let lines = [];\n      let lengthLeft = blotLength;\n      blot.children.forEachAt(blotIndex, blotLength, (child, childIndex, childLength) => {\n        if (isLine(child)) {\n          lines.push(child);\n        } else if (child instanceof _parchment.ContainerBlot) {\n          lines = lines.concat(getLines(child, childIndex, lengthLeft));\n        }\n        lengthLeft -= childLength;\n      });\n      return lines;\n    };\n    return getLines(this, index, length);\n  }\n\n  optimize(mutations = [], context = {}) {\n    if (this.batch) return;\n    super.optimize(mutations, context);\n    if (mutations.length > 0) {\n      this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);\n    }\n  }\n\n  path(index) {\n    return super.path(index).slice(1); // Exclude self\n  }\n\n  remove() {\n    // Never remove self\n  }\n\n  update(mutations) {\n    if (this.batch) {\n      if (Array.isArray(mutations)) {\n        this.batch = this.batch.concat(mutations);\n      }\n      return;\n    }\n    let source = _emitter2.default.sources.USER;\n    if (typeof mutations === 'string') {\n      source = mutations;\n    }\n    if (!Array.isArray(mutations)) {\n      mutations = this.observer.takeRecords();\n    }\n    if (mutations.length > 0) {\n      this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);\n    }\n    super.update(mutations.concat([])); // pass copy\n    if (mutations.length > 0) {\n      this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);\n    }\n  }\n}\nScroll.blotName = 'scroll';\nScroll.className = 'ql-editor';\nScroll.tagName = 'DIV';\nScroll.defaultChild = _block2.default;\nScroll.allowedChildren = [_block2.default, _block.BlockEmbed, _container2.default];\n\nexports.default = Scroll;\n\n//# sourceURL=webpack://Quill/./blots/scroll.js?");
            /***/
          },

          /***/
          "./blots/text.js":
          /*!***********************!*\
            !*** ./blots/text.js ***!
            \***********************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.escapeText = exports.default = undefined;\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nclass Text extends _parchment.TextBlot {}\n\nfunction escapeText(text) {\n  return text.replace(/[&<>\"']/g, s => {\n    // https://lodash.com/docs#escape\n    const entityMap = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#39;'\n    };\n    return entityMap[s];\n  });\n}\n\nexports.default = Text;\nexports.escapeText = escapeText;\n\n//# sourceURL=webpack://Quill/./blots/text.js?");
            /***/
          },

          /***/
          "./core.js":
          /*!*****************!*\
            !*** ./core.js ***!
            \*****************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _quill = __webpack_require__(/*! ./core/quill */ \"./core/quill.js\");\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nvar _block = __webpack_require__(/*! ./blots/block */ \"./blots/block.js\");\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _break = __webpack_require__(/*! ./blots/break */ \"./blots/break.js\");\n\nvar _break2 = _interopRequireDefault(_break);\n\nvar _container = __webpack_require__(/*! ./blots/container */ \"./blots/container.js\");\n\nvar _container2 = _interopRequireDefault(_container);\n\nvar _cursor = __webpack_require__(/*! ./blots/cursor */ \"./blots/cursor.js\");\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _embed = __webpack_require__(/*! ./blots/embed */ \"./blots/embed.js\");\n\nvar _embed2 = _interopRequireDefault(_embed);\n\nvar _inline = __webpack_require__(/*! ./blots/inline */ \"./blots/inline.js\");\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _scroll = __webpack_require__(/*! ./blots/scroll */ \"./blots/scroll.js\");\n\nvar _scroll2 = _interopRequireDefault(_scroll);\n\nvar _text = __webpack_require__(/*! ./blots/text */ \"./blots/text.js\");\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _clipboard = __webpack_require__(/*! ./modules/clipboard */ \"./modules/clipboard.js\");\n\nvar _clipboard2 = _interopRequireDefault(_clipboard);\n\nvar _history = __webpack_require__(/*! ./modules/history */ \"./modules/history.js\");\n\nvar _history2 = _interopRequireDefault(_history);\n\nvar _keyboard = __webpack_require__(/*! ./modules/keyboard */ \"./modules/keyboard.js\");\n\nvar _keyboard2 = _interopRequireDefault(_keyboard);\n\nvar _uploader = __webpack_require__(/*! ./modules/uploader */ \"./modules/uploader.js\");\n\nvar _uploader2 = _interopRequireDefault(_uploader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_quill2.default.register({\n  'blots/block': _block2.default,\n  'blots/block/embed': _block.BlockEmbed,\n  'blots/break': _break2.default,\n  'blots/container': _container2.default,\n  'blots/cursor': _cursor2.default,\n  'blots/embed': _embed2.default,\n  'blots/inline': _inline2.default,\n  'blots/scroll': _scroll2.default,\n  'blots/text': _text2.default,\n\n  'modules/clipboard': _clipboard2.default,\n  'modules/history': _history2.default,\n  'modules/keyboard': _keyboard2.default,\n  'modules/uploader': _uploader2.default\n});\n\nexports.default = _quill2.default;\n\n//# sourceURL=webpack://Quill/./core.js?");
            /***/
          },

          /***/
          "./core/editor.js":
          /*!************************!*\
            !*** ./core/editor.js ***!
            \************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _clone = __webpack_require__(/*! clone */ \"./node_modules/clone/clone.js\");\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _deepEqual = __webpack_require__(/*! deep-equal */ \"./node_modules/deep-equal/index.js\");\n\nvar _deepEqual2 = _interopRequireDefault(_deepEqual);\n\nvar _extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _quillDelta = __webpack_require__(/*! quill-delta */ \"./node_modules/quill-delta/dist/Delta.js\");\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _selection = __webpack_require__(/*! ./selection */ \"./core/selection.js\");\n\nvar _cursor = __webpack_require__(/*! ../blots/cursor */ \"./blots/cursor.js\");\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _block = __webpack_require__(/*! ../blots/block */ \"./blots/block.js\");\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _break = __webpack_require__(/*! ../blots/break */ \"./blots/break.js\");\n\nvar _break2 = _interopRequireDefault(_break);\n\nvar _text = __webpack_require__(/*! ../blots/text */ \"./blots/text.js\");\n\nvar _text2 = _interopRequireDefault(_text);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\nconst ASCII = /^[ -~]*$/;\n\nclass Editor {\n  constructor(scroll) {\n    this.scroll = scroll;\n    this.delta = this.getDelta();\n  }\n\n  applyDelta(delta) {\n    let consumeNextNewline = false;\n    this.scroll.update();\n    let scrollLength = this.scroll.length();\n    this.scroll.batchStart();\n    const normalizedDelta = normalizeDelta(delta);\n    normalizedDelta.reduce((index, op) => {\n      const length = op.retain || op.delete || op.insert.length || 1;\n      let attributes = op.attributes || {};\n      if (op.insert != null) {\n        if (typeof op.insert === 'string') {\n          let text = op.insert;\n          if (text.endsWith('\\n') && consumeNextNewline) {\n            consumeNextNewline = false;\n            text = text.slice(0, -1);\n          }\n          if ((index >= scrollLength || this.scroll.descendant(_block.BlockEmbed, index)[0]) && !text.endsWith('\\n')) {\n            consumeNextNewline = true;\n          }\n          this.scroll.insertAt(index, text);\n\n          var _scroll$line = this.scroll.line(index),\n              _scroll$line2 = _slicedToArray(_scroll$line, 2);\n\n          const line = _scroll$line2[0],\n                offset = _scroll$line2[1];\n\n          let formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));\n          if (line instanceof _block2.default) {\n            var _line$descendant = line.descendant(_parchment.LeafBlot, offset),\n                _line$descendant2 = _slicedToArray(_line$descendant, 1);\n\n            const leaf = _line$descendant2[0];\n\n            formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));\n          }\n          attributes = _quillDelta.AttributeMap.diff(formats, attributes) || {};\n        } else if (typeof op.insert === 'object') {\n          const key = Object.keys(op.insert)[0]; // There should only be one key\n          if (key == null) return index;\n          this.scroll.insertAt(index, key, op.insert[key]);\n        }\n        scrollLength += length;\n      }\n      Object.keys(attributes).forEach(name => {\n        this.scroll.formatAt(index, length, name, attributes[name]);\n      });\n      return index + length;\n    }, 0);\n    normalizedDelta.reduce((index, op) => {\n      if (typeof op.delete === 'number') {\n        this.scroll.deleteAt(index, op.delete);\n        return index;\n      }\n      return index + (op.retain || op.insert.length || 1);\n    }, 0);\n    this.scroll.batchEnd();\n    this.scroll.optimize();\n    return this.update(normalizedDelta);\n  }\n\n  deleteText(index, length) {\n    this.scroll.deleteAt(index, length);\n    return this.update(new _quillDelta2.default().retain(index).delete(length));\n  }\n\n  formatLine(index, length, formats = {}) {\n    this.scroll.update();\n    Object.keys(formats).forEach(format => {\n      this.scroll.lines(index, Math.max(length, 1)).forEach(line => {\n        line.format(format, formats[format]);\n      });\n    });\n    this.scroll.optimize();\n    const delta = new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats));\n    return this.update(delta);\n  }\n\n  formatText(index, length, formats = {}) {\n    Object.keys(formats).forEach(format => {\n      this.scroll.formatAt(index, length, format, formats[format]);\n    });\n    const delta = new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats));\n    return this.update(delta);\n  }\n\n  getContents(index, length) {\n    return this.delta.slice(index, index + length);\n  }\n\n  getDelta() {\n    return this.scroll.lines().reduce((delta, line) => {\n      return delta.concat(line.delta());\n    }, new _quillDelta2.default());\n  }\n\n  getFormat(index, length = 0) {\n    let lines = [];\n    let leaves = [];\n    if (length === 0) {\n      this.scroll.path(index).forEach(path => {\n        var _path = _slicedToArray(path, 1);\n\n        const blot = _path[0];\n\n        if (blot instanceof _block2.default) {\n          lines.push(blot);\n        } else if (blot instanceof _parchment.LeafBlot) {\n          leaves.push(blot);\n        }\n      });\n    } else {\n      lines = this.scroll.lines(index, length);\n      leaves = this.scroll.descendants(_parchment.LeafBlot, index, length);\n    }\n    const formatsArr = [lines, leaves].map(blots => {\n      if (blots.length === 0) return {};\n      let formats = (0, _block.bubbleFormats)(blots.shift());\n      while (Object.keys(formats).length > 0) {\n        const blot = blots.shift();\n        if (blot == null) return formats;\n        formats = combineFormats((0, _block.bubbleFormats)(blot), formats);\n      }\n      return formats;\n    });\n    return _extend2.default.apply(_extend2.default, formatsArr);\n  }\n\n  getHTML(index, length) {\n    var _scroll$line3 = this.scroll.line(index),\n        _scroll$line4 = _slicedToArray(_scroll$line3, 2);\n\n    const line = _scroll$line4[0],\n          lineOffset = _scroll$line4[1];\n\n    if (line.length() >= lineOffset + length) {\n      return convertHTML(line, lineOffset, length, true);\n    }\n    return convertHTML(this.scroll, index, length, true);\n  }\n\n  getText(index, length) {\n    return this.getContents(index, length).filter(op => typeof op.insert === 'string').map(op => op.insert).join('');\n  }\n\n  insertEmbed(index, embed, value) {\n    this.scroll.insertAt(index, embed, value);\n    return this.update(new _quillDelta2.default().retain(index).insert({ [embed]: value }));\n  }\n\n  insertText(index, text, formats = {}) {\n    text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n    this.scroll.insertAt(index, text);\n    Object.keys(formats).forEach(format => {\n      this.scroll.formatAt(index, text.length, format, formats[format]);\n    });\n    return this.update(new _quillDelta2.default().retain(index).insert(text, (0, _clone2.default)(formats)));\n  }\n\n  isBlank() {\n    if (this.scroll.children.length === 0) return true;\n    if (this.scroll.children.length > 1) return false;\n    const block = this.scroll.children.head;\n    if (block.statics.blotName !== _block2.default.blotName) return false;\n    if (block.children.length > 1) return false;\n    return block.children.head instanceof _break2.default;\n  }\n\n  removeFormat(index, length) {\n    const text = this.getText(index, length);\n\n    var _scroll$line5 = this.scroll.line(index + length),\n        _scroll$line6 = _slicedToArray(_scroll$line5, 2);\n\n    const line = _scroll$line6[0],\n          offset = _scroll$line6[1];\n\n    let suffixLength = 0;\n    let suffix = new _quillDelta2.default();\n    if (line != null) {\n      suffixLength = line.length() - offset;\n      suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\\n');\n    }\n    const contents = this.getContents(index, length + suffixLength);\n    const diff = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));\n    const delta = new _quillDelta2.default().retain(index).concat(diff);\n    return this.applyDelta(delta);\n  }\n\n  update(change, mutations = [], selectionInfo = undefined) {\n    const oldDelta = this.delta;\n    if (mutations.length === 1 && mutations[0].type === 'characterData' && mutations[0].target.data.match(ASCII) && this.scroll.find(mutations[0].target)) {\n      // Optimization for character changes\n      const textBlot = this.scroll.find(mutations[0].target);\n      const formats = (0, _block.bubbleFormats)(textBlot);\n      const index = textBlot.offset(this.scroll);\n      const oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, '');\n      const oldText = new _quillDelta2.default().insert(oldValue);\n      const newText = new _quillDelta2.default().insert(textBlot.value());\n      const relativeSelectionInfo = selectionInfo && {\n        oldRange: shiftRange(selectionInfo.oldRange, -index),\n        newRange: shiftRange(selectionInfo.newRange, -index)\n      };\n      const diffDelta = new _quillDelta2.default().retain(index).concat(oldText.diff(newText, relativeSelectionInfo));\n      change = diffDelta.reduce((delta, op) => {\n        if (op.insert) {\n          return delta.insert(op.insert, formats);\n        }\n        return delta.push(op);\n      }, new _quillDelta2.default());\n      this.delta = oldDelta.compose(change);\n    } else {\n      this.delta = this.getDelta();\n      if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {\n        change = oldDelta.diff(this.delta, selectionInfo);\n      }\n    }\n    return change;\n  }\n}\n\nfunction convertListHTML(items, lastIndent, types) {\n  if (items.length === 0) {\n    var _getListType = getListType(types.pop()),\n        _getListType2 = _slicedToArray(_getListType, 1);\n\n    const endTag = _getListType2[0];\n\n    if (lastIndent <= 0) {\n      return `</li></${endTag}>`;\n    }\n    return `</li></${endTag}>${convertListHTML([], lastIndent - 1, types)}`;\n  }\n\n  var _items = _toArray(items),\n      _items$ = _items[0];\n\n  const child = _items$.child,\n        offset = _items$.offset,\n        length = _items$.length,\n        indent = _items$.indent,\n        type = _items$.type,\n        rest = _items.slice(1);\n\n  var _getListType3 = getListType(type),\n      _getListType4 = _slicedToArray(_getListType3, 2);\n\n  const tag = _getListType4[0],\n        attribute = _getListType4[1];\n\n  if (indent > lastIndent) {\n    types.push(type);\n    return `<${tag}><li${attribute}>${convertHTML(child, offset, length)}${convertListHTML(rest, indent, types)}`;\n  }\n  if (indent === lastIndent) {\n    return `</li><li${attribute}>${convertHTML(child, offset, length)}${convertListHTML(rest, indent, types)}`;\n  }\n\n  var _getListType5 = getListType(types.pop()),\n      _getListType6 = _slicedToArray(_getListType5, 1);\n\n  const endTag = _getListType6[0];\n\n  return `</li></${endTag}>${convertListHTML(items, lastIndent - 1, types)}`;\n}\n\nfunction convertHTML(blot, index, length, isRoot = false) {\n  if (typeof blot.html === 'function') {\n    return blot.html(index, length);\n  }\n  if (blot instanceof _text2.default) {\n    return (0, _text.escapeText)(blot.value().slice(index, index + length));\n  }\n  if (blot.children) {\n    // TODO fix API\n    if (blot.statics.blotName === 'list-container') {\n      const items = [];\n      blot.children.forEachAt(index, length, (child, offset, childLength) => {\n        const formats = child.formats();\n        items.push({\n          child,\n          offset,\n          length: childLength,\n          indent: formats.indent || 0,\n          type: formats.list\n        });\n      });\n      return convertListHTML(items, -1, []);\n    }\n    const parts = [];\n    blot.children.forEachAt(index, length, (child, offset, childLength) => {\n      parts.push(convertHTML(child, offset, childLength));\n    });\n    if (isRoot || blot.statics.blotName === 'list') {\n      return parts.join('');\n    }\n    var _blot$domNode = blot.domNode;\n    const outerHTML = _blot$domNode.outerHTML,\n          innerHTML = _blot$domNode.innerHTML;\n\n    var _outerHTML$split = outerHTML.split(`>${innerHTML}<`),\n        _outerHTML$split2 = _slicedToArray(_outerHTML$split, 2);\n\n    const start = _outerHTML$split2[0],\n          end = _outerHTML$split2[1];\n    // TODO cleanup\n\n    if (start === '<table') {\n      return `<table style=\"border: 1px solid #000;\">${parts.join('')}<${end}`;\n    }\n    return `${start}>${parts.join('')}<${end}`;\n  }\n  return blot.domNode.outerHTML;\n}\n\nfunction combineFormats(formats, combined) {\n  return Object.keys(combined).reduce((merged, name) => {\n    if (formats[name] == null) return merged;\n    if (combined[name] === formats[name]) {\n      merged[name] = combined[name];\n    } else if (Array.isArray(combined[name])) {\n      if (combined[name].indexOf(formats[name]) < 0) {\n        merged[name] = combined[name].concat([formats[name]]);\n      }\n    } else {\n      merged[name] = [combined[name], formats[name]];\n    }\n    return merged;\n  }, {});\n}\n\nfunction getListType(type) {\n  const tag = type === 'ordered' ? 'ol' : 'ul';\n  switch (type) {\n    case 'checked':\n      return [tag, ' data-list=\"checked\"'];\n    case 'unchecked':\n      return [tag, ' data-list=\"unchecked\"'];\n    default:\n      return [tag, ''];\n  }\n}\n\nfunction normalizeDelta(delta) {\n  return delta.reduce((normalizedDelta, op) => {\n    if (typeof op.insert === 'string') {\n      const text = op.insert.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n      return normalizedDelta.insert(text, op.attributes);\n    }\n    return normalizedDelta.push(op);\n  }, new _quillDelta2.default());\n}\n\nfunction shiftRange({ index, length }, amount) {\n  return new _selection.Range(index + amount, length);\n}\n\nexports.default = Editor;\n\n//# sourceURL=webpack://Quill/./core/editor.js?");
            /***/
          },

          /***/
          "./core/emitter.js":
          /*!*************************!*\
            !*** ./core/emitter.js ***!
            \*************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eventemitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n\nvar _eventemitter2 = _interopRequireDefault(_eventemitter);\n\nvar _instances = __webpack_require__(/*! ./instances */ \"./core/instances.js\");\n\nvar _instances2 = _interopRequireDefault(_instances);\n\nvar _logger = __webpack_require__(/*! ./logger */ \"./core/logger.js\");\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _logger2.default)('quill:events');\nconst EVENTS = ['selectionchange', 'mousedown', 'mouseup', 'click'];\n\nEVENTS.forEach(eventName => {\n  document.addEventListener(eventName, (...args) => {\n    Array.from(document.querySelectorAll('.ql-container')).forEach(node => {\n      const quill = _instances2.default.get(node);\n      if (quill && quill.emitter) {\n        quill.emitter.handleDOM(...args);\n      }\n    });\n  });\n});\n\nclass Emitter extends _eventemitter2.default {\n  constructor() {\n    super();\n    this.listeners = {};\n    this.on('error', debug.error);\n  }\n\n  emit(...args) {\n    debug.log.call(debug, ...args);\n    super.emit(...args);\n  }\n\n  handleDOM(event, ...args) {\n    (this.listeners[event.type] || []).forEach(({ node, handler }) => {\n      if (event.target === node || node.contains(event.target)) {\n        handler(event, ...args);\n      }\n    });\n  }\n\n  listenDOM(eventName, node, handler) {\n    if (!this.listeners[eventName]) {\n      this.listeners[eventName] = [];\n    }\n    this.listeners[eventName].push({ node, handler });\n  }\n}\n\nEmitter.events = {\n  EDITOR_CHANGE: 'editor-change',\n  SCROLL_BEFORE_UPDATE: 'scroll-before-update',\n  SCROLL_BLOT_MOUNT: 'scroll-blot-mount',\n  SCROLL_BLOT_UNMOUNT: 'scroll-blot-unmount',\n  SCROLL_OPTIMIZE: 'scroll-optimize',\n  SCROLL_UPDATE: 'scroll-update',\n  SELECTION_CHANGE: 'selection-change',\n  TEXT_CHANGE: 'text-change'\n};\nEmitter.sources = {\n  API: 'api',\n  SILENT: 'silent',\n  USER: 'user'\n};\n\nexports.default = Emitter;\n\n//# sourceURL=webpack://Quill/./core/emitter.js?");
            /***/
          },

          /***/
          "./core/instances.js":
          /*!***************************!*\
            !*** ./core/instances.js ***!
            \***************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = new WeakMap();\n\n//# sourceURL=webpack://Quill/./core/instances.js?");
            /***/
          },

          /***/
          "./core/logger.js":
          /*!************************!*\
            !*** ./core/logger.js ***!
            \************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst levels = ['error', 'warn', 'log', 'info'];\nlet level = 'warn';\n\nfunction debug(method, ...args) {\n  if (levels.indexOf(method) <= levels.indexOf(level)) {\n    console[method](...args); // eslint-disable-line no-console\n  }\n}\n\nfunction namespace(ns) {\n  return levels.reduce((logger, method) => {\n    logger[method] = debug.bind(console, method, ns);\n    return logger;\n  }, {});\n}\n\nnamespace.level = newLevel => {\n  level = newLevel;\n};\ndebug.level = namespace.level;\n\nexports.default = namespace;\n\n//# sourceURL=webpack://Quill/./core/logger.js?");
            /***/
          },

          /***/
          "./core/module.js":
          /*!************************!*\
            !*** ./core/module.js ***!
            \************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass Module {\n  constructor(quill, options = {}) {\n    this.quill = quill;\n    this.options = options;\n  }\n}\nModule.DEFAULTS = {};\n\nexports.default = Module;\n\n//# sourceURL=webpack://Quill/./core/module.js?");
            /***/
          },

          /***/
          "./core/quill.js":
          /*!***********************!*\
            !*** ./core/quill.js ***!
            \***********************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.overload = exports.expandConfig = exports.globalRegistry = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _quillDelta = __webpack_require__(/*! quill-delta */ \"./node_modules/quill-delta/dist/Delta.js\");\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar Parchment = _interopRequireWildcard(_parchment);\n\nvar _extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _editor = __webpack_require__(/*! ./editor */ \"./core/editor.js\");\n\nvar _editor2 = _interopRequireDefault(_editor);\n\nvar _emitter = __webpack_require__(/*! ./emitter */ \"./core/emitter.js\");\n\nvar _emitter2 = _interopRequireDefault(_emitter);\n\nvar _module = __webpack_require__(/*! ./module */ \"./core/module.js\");\n\nvar _module2 = _interopRequireDefault(_module);\n\nvar _selection = __webpack_require__(/*! ./selection */ \"./core/selection.js\");\n\nvar _selection2 = _interopRequireDefault(_selection);\n\nvar _instances = __webpack_require__(/*! ./instances */ \"./core/instances.js\");\n\nvar _instances2 = _interopRequireDefault(_instances);\n\nvar _logger = __webpack_require__(/*! ./logger */ \"./core/logger.js\");\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _theme = __webpack_require__(/*! ./theme */ \"./core/theme.js\");\n\nvar _theme2 = _interopRequireDefault(_theme);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _logger2.default)('quill');\n\nconst globalRegistry = new Parchment.Registry();\nParchment.ParentBlot.uiClass = 'ql-ui';\n\nclass Quill {\n  static debug(limit) {\n    if (limit === true) {\n      limit = 'log';\n    }\n    _logger2.default.level(limit);\n  }\n\n  static find(node) {\n    return _instances2.default.get(node) || globalRegistry.find(node);\n  }\n\n  static import(name) {\n    if (this.imports[name] == null) {\n      debug.error(`Cannot import ${name}. Are you sure it was registered?`);\n    }\n    return this.imports[name];\n  }\n\n  static register(path, target, overwrite = false) {\n    if (typeof path !== 'string') {\n      const name = path.attrName || path.blotName;\n      if (typeof name === 'string') {\n        // register(Blot | Attributor, overwrite)\n        this.register(`formats/${name}`, path, target);\n      } else {\n        Object.keys(path).forEach(key => {\n          this.register(key, path[key], target);\n        });\n      }\n    } else {\n      if (this.imports[path] != null && !overwrite) {\n        debug.warn(`Overwriting ${path} with`, target);\n      }\n      this.imports[path] = target;\n      if ((path.startsWith('blots/') || path.startsWith('formats/')) && target.blotName !== 'abstract') {\n        globalRegistry.register(target);\n      }\n      if (typeof target.register === 'function') {\n        target.register(globalRegistry);\n      }\n    }\n  }\n\n  constructor(container, options = {}) {\n    this.options = expandConfig(container, options);\n    this.container = this.options.container;\n    if (this.container == null) {\n      return debug.error('Invalid Quill container', container);\n    }\n    if (this.options.debug) {\n      Quill.debug(this.options.debug);\n    }\n    const html = this.container.innerHTML.trim();\n    this.container.classList.add('ql-container');\n    this.container.innerHTML = '';\n    _instances2.default.set(this.container, this);\n    this.root = this.addContainer('ql-editor');\n    this.root.addEventListener('dragstart', e => {\n      e.preventDefault();\n    });\n    this.root.classList.add('ql-blank');\n    this.root.setAttribute('data-gramm', false);\n    this.scrollingContainer = this.options.scrollingContainer || this.root;\n    this.emitter = new _emitter2.default();\n    const ScrollBlot = this.options.registry.query(Parchment.ScrollBlot.blotName);\n    this.scroll = new ScrollBlot(this.options.registry, this.root, {\n      emitter: this.emitter\n    });\n    this.editor = new _editor2.default(this.scroll);\n    this.selection = new _selection2.default(this.scroll, this.emitter);\n    this.theme = new this.options.theme(this, this.options); // eslint-disable-line new-cap\n    this.keyboard = this.theme.addModule('keyboard');\n    this.clipboard = this.theme.addModule('clipboard');\n    this.history = this.theme.addModule('history');\n    this.uploader = this.theme.addModule('uploader');\n    this.theme.init();\n    this.emitter.on(_emitter2.default.events.EDITOR_CHANGE, type => {\n      if (type === _emitter2.default.events.TEXT_CHANGE) {\n        this.root.classList.toggle('ql-blank', this.editor.isBlank());\n      }\n    });\n    this.emitter.on(_emitter2.default.events.SCROLL_UPDATE, (source, mutations) => {\n      const oldRange = this.selection.lastRange;\n\n      var _selection$getRange = this.selection.getRange(),\n          _selection$getRange2 = _slicedToArray(_selection$getRange, 1);\n\n      const newRange = _selection$getRange2[0];\n\n      const selectionInfo = oldRange && newRange ? { oldRange, newRange } : undefined;\n      modify.call(this, () => this.editor.update(null, mutations, selectionInfo), source);\n    });\n    const contents = this.clipboard.convert({\n      html: `${html}<p><br></p>`,\n      text: '\\n'\n    });\n    this.setContents(contents);\n    this.history.clear();\n    if (this.options.placeholder) {\n      this.root.setAttribute('data-placeholder', this.options.placeholder);\n    }\n    if (this.options.readOnly) {\n      this.disable();\n    }\n    this.allowReadOnlyEdits = false;\n  }\n\n  addContainer(container, refNode = null) {\n    if (typeof container === 'string') {\n      const className = container;\n      container = document.createElement('div');\n      container.classList.add(className);\n    }\n    this.container.insertBefore(container, refNode);\n    return container;\n  }\n\n  blur() {\n    this.selection.setRange(null);\n  }\n\n  deleteText(index, length, source) {\n    var _overload = overload(index, length, source);\n\n    var _overload2 = _slicedToArray(_overload, 4);\n\n    index = _overload2[0];\n    length = _overload2[1];\n    source = _overload2[3];\n\n    return modify.call(this, () => {\n      return this.editor.deleteText(index, length);\n    }, source, index, -1 * length);\n  }\n\n  disable() {\n    this.enable(false);\n  }\n\n  editReadOnly(modifier) {\n    this.allowReadOnlyEdits = true;\n    const value = modifier();\n    this.allowReadOnlyEdits = false;\n    return value;\n  }\n\n  enable(enabled = true) {\n    this.scroll.enable(enabled);\n    this.container.classList.toggle('ql-disabled', !enabled);\n  }\n\n  focus() {\n    const scrollTop = this.scrollingContainer.scrollTop;\n\n    this.selection.focus();\n    this.scrollingContainer.scrollTop = scrollTop;\n    this.scrollIntoView();\n  }\n\n  format(name, value, source = _emitter2.default.sources.API) {\n    return modify.call(this, () => {\n      const range = this.getSelection(true);\n      let change = new _quillDelta2.default();\n      if (range == null) return change;\n      if (this.scroll.query(name, Parchment.Scope.BLOCK)) {\n        change = this.editor.formatLine(range.index, range.length, {\n          [name]: value\n        });\n      } else if (range.length === 0) {\n        this.selection.format(name, value);\n        return change;\n      } else {\n        change = this.editor.formatText(range.index, range.length, {\n          [name]: value\n        });\n      }\n      this.setSelection(range, _emitter2.default.sources.SILENT);\n      return change;\n    }, source);\n  }\n\n  formatLine(index, length, name, value, source) {\n    let formats;\n    // eslint-disable-next-line prefer-const\n\n    var _overload3 = overload(index, length, name, value, source);\n\n    var _overload4 = _slicedToArray(_overload3, 4);\n\n    index = _overload4[0];\n    length = _overload4[1];\n    formats = _overload4[2];\n    source = _overload4[3];\n\n    return modify.call(this, () => {\n      return this.editor.formatLine(index, length, formats);\n    }, source, index, 0);\n  }\n\n  formatText(index, length, name, value, source) {\n    let formats;\n    // eslint-disable-next-line prefer-const\n\n    var _overload5 = overload(index, length, name, value, source);\n\n    var _overload6 = _slicedToArray(_overload5, 4);\n\n    index = _overload6[0];\n    length = _overload6[1];\n    formats = _overload6[2];\n    source = _overload6[3];\n\n    return modify.call(this, () => {\n      return this.editor.formatText(index, length, formats);\n    }, source, index, 0);\n  }\n\n  getBounds(index, length = 0) {\n    let bounds;\n    if (typeof index === 'number') {\n      bounds = this.selection.getBounds(index, length);\n    } else {\n      bounds = this.selection.getBounds(index.index, index.length);\n    }\n    const containerBounds = this.container.getBoundingClientRect();\n    return {\n      bottom: bounds.bottom - containerBounds.top,\n      height: bounds.height,\n      left: bounds.left - containerBounds.left,\n      right: bounds.right - containerBounds.left,\n      top: bounds.top - containerBounds.top,\n      width: bounds.width\n    };\n  }\n\n  getContents(index = 0, length = this.getLength() - index) {\n    var _overload7 = overload(index, length);\n\n    var _overload8 = _slicedToArray(_overload7, 2);\n\n    index = _overload8[0];\n    length = _overload8[1];\n\n    return this.editor.getContents(index, length);\n  }\n\n  getFormat(index = this.getSelection(true), length = 0) {\n    if (typeof index === 'number') {\n      return this.editor.getFormat(index, length);\n    }\n    return this.editor.getFormat(index.index, index.length);\n  }\n\n  getIndex(blot) {\n    return blot.offset(this.scroll);\n  }\n\n  getLength() {\n    return this.scroll.length();\n  }\n\n  getLeaf(index) {\n    return this.scroll.leaf(index);\n  }\n\n  getLine(index) {\n    return this.scroll.line(index);\n  }\n\n  getLines(index = 0, length = Number.MAX_VALUE) {\n    if (typeof index !== 'number') {\n      return this.scroll.lines(index.index, index.length);\n    }\n    return this.scroll.lines(index, length);\n  }\n\n  getModule(name) {\n    return this.theme.modules[name];\n  }\n\n  getSelection(focus = false) {\n    if (focus) this.focus();\n    this.update(); // Make sure we access getRange with editor in consistent state\n    return this.selection.getRange()[0];\n  }\n\n  getSemanticHTML(index = 0, length = this.getLength() - index) {\n    var _overload9 = overload(index, length);\n\n    var _overload10 = _slicedToArray(_overload9, 2);\n\n    index = _overload10[0];\n    length = _overload10[1];\n\n    return this.editor.getHTML(index, length);\n  }\n\n  getText(index = 0, length = this.getLength() - index) {\n    var _overload11 = overload(index, length);\n\n    var _overload12 = _slicedToArray(_overload11, 2);\n\n    index = _overload12[0];\n    length = _overload12[1];\n\n    return this.editor.getText(index, length);\n  }\n\n  hasFocus() {\n    return this.selection.hasFocus();\n  }\n\n  insertEmbed(index, embed, value, source = Quill.sources.API) {\n    return modify.call(this, () => {\n      return this.editor.insertEmbed(index, embed, value);\n    }, source, index);\n  }\n\n  insertText(index, text, name, value, source) {\n    let formats;\n    // eslint-disable-next-line prefer-const\n\n    var _overload13 = overload(index, 0, name, value, source);\n\n    var _overload14 = _slicedToArray(_overload13, 4);\n\n    index = _overload14[0];\n    formats = _overload14[2];\n    source = _overload14[3];\n\n    return modify.call(this, () => {\n      return this.editor.insertText(index, text, formats);\n    }, source, index, text.length);\n  }\n\n  isEnabled() {\n    return this.scroll.isEnabled();\n  }\n\n  off(...args) {\n    return this.emitter.off(...args);\n  }\n\n  on(...args) {\n    return this.emitter.on(...args);\n  }\n\n  once(...args) {\n    return this.emitter.once(...args);\n  }\n\n  removeFormat(index, length, source) {\n    var _overload15 = overload(index, length, source);\n\n    var _overload16 = _slicedToArray(_overload15, 4);\n\n    index = _overload16[0];\n    length = _overload16[1];\n    source = _overload16[3];\n\n    return modify.call(this, () => {\n      return this.editor.removeFormat(index, length);\n    }, source, index);\n  }\n\n  scrollIntoView() {\n    this.selection.scrollIntoView(this.scrollingContainer);\n  }\n\n  setContents(delta, source = _emitter2.default.sources.API) {\n    return modify.call(this, () => {\n      delta = new _quillDelta2.default(delta);\n      const length = this.getLength();\n      const deleted = this.editor.deleteText(0, length);\n      const applied = this.editor.applyDelta(delta);\n      const lastOp = applied.ops[applied.ops.length - 1];\n      if (lastOp != null && typeof lastOp.insert === 'string' && lastOp.insert[lastOp.insert.length - 1] === '\\n') {\n        this.editor.deleteText(this.getLength() - 1, 1);\n        applied.delete(1);\n      }\n      return deleted.compose(applied);\n    }, source);\n  }\n\n  setSelection(index, length, source) {\n    if (index == null) {\n      this.selection.setRange(null, length || Quill.sources.API);\n    } else {\n      var _overload17 = overload(index, length, source);\n\n      var _overload18 = _slicedToArray(_overload17, 4);\n\n      index = _overload18[0];\n      length = _overload18[1];\n      source = _overload18[3];\n\n      this.selection.setRange(new _selection.Range(Math.max(0, index), length), source);\n      if (source !== _emitter2.default.sources.SILENT) {\n        this.selection.scrollIntoView(this.scrollingContainer);\n      }\n    }\n  }\n\n  setText(text, source = _emitter2.default.sources.API) {\n    const delta = new _quillDelta2.default().insert(text);\n    return this.setContents(delta, source);\n  }\n\n  update(source = _emitter2.default.sources.USER) {\n    const change = this.scroll.update(source); // Will update selection before selection.update() does if text changes\n    this.selection.update(source);\n    // TODO this is usually undefined\n    return change;\n  }\n\n  updateContents(delta, source = _emitter2.default.sources.API) {\n    return modify.call(this, () => {\n      delta = new _quillDelta2.default(delta);\n      return this.editor.applyDelta(delta, source);\n    }, source, true);\n  }\n}\nQuill.DEFAULTS = {\n  bounds: null,\n  modules: {},\n  placeholder: '',\n  readOnly: false,\n  registry: globalRegistry,\n  scrollingContainer: null,\n  theme: 'default'\n};\nQuill.events = _emitter2.default.events;\nQuill.sources = _emitter2.default.sources;\n// eslint-disable-next-line no-undef\nQuill.version =  false ? undefined : \"2.0.0-dev.3\";\n\nQuill.imports = {\n  delta: _quillDelta2.default,\n  parchment: Parchment,\n  'core/module': _module2.default,\n  'core/theme': _theme2.default\n};\n\nfunction expandConfig(container, userConfig) {\n  userConfig = (0, _extend2.default)(true, {\n    container,\n    modules: {\n      clipboard: true,\n      keyboard: true,\n      history: true,\n      uploader: true\n    }\n  }, userConfig);\n  if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {\n    userConfig.theme = _theme2.default;\n  } else {\n    userConfig.theme = Quill.import(`themes/${userConfig.theme}`);\n    if (userConfig.theme == null) {\n      throw new Error(`Invalid theme ${userConfig.theme}. Did you register it?`);\n    }\n  }\n  const themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);\n  [themeConfig, userConfig].forEach(config => {\n    config.modules = config.modules || {};\n    Object.keys(config.modules).forEach(module => {\n      if (config.modules[module] === true) {\n        config.modules[module] = {};\n      }\n    });\n  });\n  const moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));\n  const moduleConfig = moduleNames.reduce((config, name) => {\n    const moduleClass = Quill.import(`modules/${name}`);\n    if (moduleClass == null) {\n      debug.error(`Cannot load ${name} module. Are you sure you registered it?`);\n    } else {\n      config[name] = moduleClass.DEFAULTS || {};\n    }\n    return config;\n  }, {});\n  // Special case toolbar shorthand\n  if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {\n    userConfig.modules.toolbar = {\n      container: userConfig.modules.toolbar\n    };\n  }\n  userConfig = (0, _extend2.default)(true, {}, Quill.DEFAULTS, { modules: moduleConfig }, themeConfig, userConfig);\n  ['bounds', 'container', 'scrollingContainer'].forEach(key => {\n    if (typeof userConfig[key] === 'string') {\n      userConfig[key] = document.querySelector(userConfig[key]);\n    }\n  });\n  userConfig.modules = Object.keys(userConfig.modules).reduce((config, name) => {\n    if (userConfig.modules[name]) {\n      config[name] = userConfig.modules[name];\n    }\n    return config;\n  }, {});\n  return userConfig;\n}\n\n// Handle selection preservation and TEXT_CHANGE emission\n// common to modification APIs\nfunction modify(modifier, source, index, shift) {\n  if (!this.isEnabled() && source === _emitter2.default.sources.USER && !this.allowReadOnlyEdits) {\n    return new _quillDelta2.default();\n  }\n  let range = index == null ? null : this.getSelection();\n  const oldDelta = this.editor.delta;\n  const change = modifier();\n  if (range != null) {\n    if (index === true) {\n      index = range.index; // eslint-disable-line prefer-destructuring\n    }\n    if (shift == null) {\n      range = shiftRange(range, change, source);\n    } else if (shift !== 0) {\n      range = shiftRange(range, index, shift, source);\n    }\n    this.setSelection(range, _emitter2.default.sources.SILENT);\n  }\n  if (change.length() > 0) {\n    const args = [_emitter2.default.events.TEXT_CHANGE, change, oldDelta, source];\n    this.emitter.emit(_emitter2.default.events.EDITOR_CHANGE, ...args);\n    if (source !== _emitter2.default.sources.SILENT) {\n      this.emitter.emit(...args);\n    }\n  }\n  return change;\n}\n\nfunction overload(index, length, name, value, source) {\n  let formats = {};\n  if (typeof index.index === 'number' && typeof index.length === 'number') {\n    // Allow for throwaway end (used by insertText/insertEmbed)\n    if (typeof length !== 'number') {\n      source = value;\n      value = name;\n      name = length;\n      length = index.length; // eslint-disable-line prefer-destructuring\n      index = index.index; // eslint-disable-line prefer-destructuring\n    } else {\n      length = index.length; // eslint-disable-line prefer-destructuring\n      index = index.index; // eslint-disable-line prefer-destructuring\n    }\n  } else if (typeof length !== 'number') {\n    source = value;\n    value = name;\n    name = length;\n    length = 0;\n  }\n  // Handle format being object, two format name/value strings or excluded\n  if (typeof name === 'object') {\n    formats = name;\n    source = value;\n  } else if (typeof name === 'string') {\n    if (value != null) {\n      formats[name] = value;\n    } else {\n      source = name;\n    }\n  }\n  // Handle optional source\n  source = source || _emitter2.default.sources.API;\n  return [index, length, formats, source];\n}\n\nfunction shiftRange(range, index, length, source) {\n  if (range == null) return null;\n  let start;\n  let end;\n  if (index instanceof _quillDelta2.default) {\n    var _map = [range.index, range.index + range.length].map(pos => index.transformPosition(pos, source !== _emitter2.default.sources.USER));\n\n    var _map2 = _slicedToArray(_map, 2);\n\n    start = _map2[0];\n    end = _map2[1];\n  } else {\n    var _map3 = [range.index, range.index + range.length].map(pos => {\n      if (pos < index || pos === index && source === _emitter2.default.sources.USER) return pos;\n      if (length >= 0) {\n        return pos + length;\n      }\n      return Math.max(index, pos + length);\n    });\n\n    var _map4 = _slicedToArray(_map3, 2);\n\n    start = _map4[0];\n    end = _map4[1];\n  }\n  return new _selection.Range(start, end - start);\n}\n\nexports.globalRegistry = globalRegistry;\nexports.expandConfig = expandConfig;\nexports.overload = overload;\nexports.default = Quill;\n\n//# sourceURL=webpack://Quill/./core/quill.js?");
            /***/
          },

          /***/
          "./core/selection.js":
          /*!***************************!*\
            !*** ./core/selection.js ***!
            \***************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.Range = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _clone = __webpack_require__(/*! clone */ \"./node_modules/clone/clone.js\");\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _deepEqual = __webpack_require__(/*! deep-equal */ \"./node_modules/deep-equal/index.js\");\n\nvar _deepEqual2 = _interopRequireDefault(_deepEqual);\n\nvar _emitter = __webpack_require__(/*! ./emitter */ \"./core/emitter.js\");\n\nvar _emitter2 = _interopRequireDefault(_emitter);\n\nvar _logger = __webpack_require__(/*! ./logger */ \"./core/logger.js\");\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _logger2.default)('quill:selection');\n\nclass Range {\n  constructor(index, length = 0) {\n    this.index = index;\n    this.length = length;\n  }\n}\n\nclass Selection {\n  constructor(scroll, emitter) {\n    this.emitter = emitter;\n    this.scroll = scroll;\n    this.composing = false;\n    this.mouseDown = false;\n    this.root = this.scroll.domNode;\n    this.cursor = this.scroll.create('cursor', this);\n    // savedRange is last non-null range\n    this.savedRange = new Range(0, 0);\n    this.lastRange = this.savedRange;\n    this.handleComposition();\n    this.handleDragging();\n    this.emitter.listenDOM('selectionchange', document, () => {\n      if (!this.mouseDown && !this.composing) {\n        setTimeout(this.update.bind(this, _emitter2.default.sources.USER), 1);\n      }\n    });\n    this.emitter.on(_emitter2.default.events.SCROLL_BEFORE_UPDATE, () => {\n      if (!this.hasFocus()) return;\n      const native = this.getNativeRange();\n      if (native == null) return;\n      if (native.start.node === this.cursor.textNode) return; // cursor.restore() will handle\n      this.emitter.once(_emitter2.default.events.SCROLL_UPDATE, () => {\n        try {\n          if (this.root.contains(native.start.node) && this.root.contains(native.end.node)) {\n            this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);\n          }\n          this.update(_emitter2.default.sources.SILENT);\n        } catch (ignored) {\n          // ignore\n        }\n      });\n    });\n    this.emitter.on(_emitter2.default.events.SCROLL_OPTIMIZE, (mutations, context) => {\n      if (context.range) {\n        var _context$range = context.range;\n        const startNode = _context$range.startNode,\n              startOffset = _context$range.startOffset,\n              endNode = _context$range.endNode,\n              endOffset = _context$range.endOffset;\n\n        this.setNativeRange(startNode, startOffset, endNode, endOffset);\n        this.update(_emitter2.default.sources.SILENT);\n      }\n    });\n    this.update(_emitter2.default.sources.SILENT);\n  }\n\n  handleComposition() {\n    this.root.addEventListener('compositionstart', () => {\n      this.composing = true;\n      this.scroll.batchStart();\n    });\n    this.root.addEventListener('compositionend', () => {\n      this.scroll.batchEnd();\n      this.composing = false;\n      if (this.cursor.parent) {\n        const range = this.cursor.restore();\n        if (!range) return;\n        setTimeout(() => {\n          this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);\n        }, 1);\n      }\n    });\n  }\n\n  handleDragging() {\n    this.emitter.listenDOM('mousedown', document.body, () => {\n      this.mouseDown = true;\n    });\n    this.emitter.listenDOM('mouseup', document.body, () => {\n      this.mouseDown = false;\n      this.update(_emitter2.default.sources.USER);\n    });\n  }\n\n  focus() {\n    if (this.hasFocus()) return;\n    this.root.focus();\n    this.setRange(this.savedRange);\n  }\n\n  format(format, value) {\n    this.scroll.update();\n    const nativeRange = this.getNativeRange();\n    if (nativeRange == null || !nativeRange.native.collapsed || this.scroll.query(format, _parchment.Scope.BLOCK)) return;\n    if (nativeRange.start.node !== this.cursor.textNode) {\n      const blot = this.scroll.find(nativeRange.start.node, false);\n      if (blot == null) return;\n      // TODO Give blot ability to not split\n      if (blot instanceof _parchment.LeafBlot) {\n        const after = blot.split(nativeRange.start.offset);\n        blot.parent.insertBefore(this.cursor, after);\n      } else {\n        blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen\n      }\n      this.cursor.attach();\n    }\n    this.cursor.format(format, value);\n    this.scroll.optimize();\n    this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);\n    this.update();\n  }\n\n  getBounds(index, length = 0) {\n    const scrollLength = this.scroll.length();\n    index = Math.min(index, scrollLength - 1);\n    length = Math.min(index + length, scrollLength - 1) - index;\n    let node;\n\n    var _scroll$leaf = this.scroll.leaf(index),\n        _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2);\n\n    let leaf = _scroll$leaf2[0],\n        offset = _scroll$leaf2[1];\n\n    if (leaf == null) return null;\n\n    var _leaf$position = leaf.position(offset, true);\n\n    var _leaf$position2 = _slicedToArray(_leaf$position, 2);\n\n    node = _leaf$position2[0];\n    offset = _leaf$position2[1];\n\n    const range = document.createRange();\n    if (length > 0) {\n      range.setStart(node, offset);\n\n      var _scroll$leaf3 = this.scroll.leaf(index + length);\n\n      var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);\n\n      leaf = _scroll$leaf4[0];\n      offset = _scroll$leaf4[1];\n\n      if (leaf == null) return null;\n\n      var _leaf$position3 = leaf.position(offset, true);\n\n      var _leaf$position4 = _slicedToArray(_leaf$position3, 2);\n\n      node = _leaf$position4[0];\n      offset = _leaf$position4[1];\n\n      range.setEnd(node, offset);\n      return range.getBoundingClientRect();\n    }\n    let side = 'left';\n    let rect;\n    if (node instanceof Text) {\n      if (offset < node.data.length) {\n        range.setStart(node, offset);\n        range.setEnd(node, offset + 1);\n      } else {\n        range.setStart(node, offset - 1);\n        range.setEnd(node, offset);\n        side = 'right';\n      }\n      rect = range.getBoundingClientRect();\n    } else {\n      rect = leaf.domNode.getBoundingClientRect();\n      if (offset > 0) side = 'right';\n    }\n    return {\n      bottom: rect.top + rect.height,\n      height: rect.height,\n      left: rect[side],\n      right: rect[side],\n      top: rect.top,\n      width: 0\n    };\n  }\n\n  getNativeRange() {\n    const selection = document.getSelection();\n    if (selection == null || selection.rangeCount <= 0) return null;\n    const nativeRange = selection.getRangeAt(0);\n    if (nativeRange == null) return null;\n    const range = this.normalizeNative(nativeRange);\n    debug.info('getNativeRange', range);\n    return range;\n  }\n\n  getRange() {\n    const normalized = this.getNativeRange();\n    if (normalized == null) return [null, null];\n    const range = this.normalizedToRange(normalized);\n    return [range, normalized];\n  }\n\n  hasFocus() {\n    return document.activeElement === this.root || contains(this.root, document.activeElement);\n  }\n\n  normalizedToRange(range) {\n    const positions = [[range.start.node, range.start.offset]];\n    if (!range.native.collapsed) {\n      positions.push([range.end.node, range.end.offset]);\n    }\n    const indexes = positions.map(position => {\n      var _position = _slicedToArray(position, 2);\n\n      const node = _position[0],\n            offset = _position[1];\n\n      const blot = this.scroll.find(node, true);\n      const index = blot.offset(this.scroll);\n      if (offset === 0) {\n        return index;\n      }\n      if (blot instanceof _parchment.LeafBlot) {\n        return index + blot.index(node, offset);\n      }\n      return index + blot.length();\n    });\n    const end = Math.min(Math.max(...indexes), this.scroll.length() - 1);\n    const start = Math.min(end, ...indexes);\n    return new Range(start, end - start);\n  }\n\n  normalizeNative(nativeRange) {\n    if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {\n      return null;\n    }\n    const range = {\n      start: {\n        node: nativeRange.startContainer,\n        offset: nativeRange.startOffset\n      },\n      end: { node: nativeRange.endContainer, offset: nativeRange.endOffset },\n      native: nativeRange\n    };\n    [range.start, range.end].forEach(position => {\n      let node = position.node,\n          offset = position.offset;\n\n      while (!(node instanceof Text) && node.childNodes.length > 0) {\n        if (node.childNodes.length > offset) {\n          node = node.childNodes[offset];\n          offset = 0;\n        } else if (node.childNodes.length === offset) {\n          node = node.lastChild;\n          if (node instanceof Text) {\n            offset = node.data.length;\n          } else if (node.childNodes.length > 0) {\n            // Container case\n            offset = node.childNodes.length;\n          } else {\n            // Embed case\n            offset = node.childNodes.length + 1;\n          }\n        } else {\n          break;\n        }\n      }\n      position.node = node;\n      position.offset = offset;\n    });\n    return range;\n  }\n\n  rangeToNative(range) {\n    const indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];\n    const args = [];\n    const scrollLength = this.scroll.length();\n    indexes.forEach((index, i) => {\n      index = Math.min(scrollLength - 1, index);\n\n      var _scroll$leaf5 = this.scroll.leaf(index),\n          _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2);\n\n      const leaf = _scroll$leaf6[0],\n            leafOffset = _scroll$leaf6[1];\n\n      var _leaf$position5 = leaf.position(leafOffset, i !== 0),\n          _leaf$position6 = _slicedToArray(_leaf$position5, 2);\n\n      const node = _leaf$position6[0],\n            offset = _leaf$position6[1];\n\n      args.push(node, offset);\n    });\n    if (args.length < 2) {\n      return args.concat(args);\n    }\n    return args;\n  }\n\n  scrollIntoView(scrollingContainer) {\n    const range = this.lastRange;\n    if (range == null) return;\n    const bounds = this.getBounds(range.index, range.length);\n    if (bounds == null) return;\n    const limit = this.scroll.length() - 1;\n\n    var _scroll$line = this.scroll.line(Math.min(range.index, limit)),\n        _scroll$line2 = _slicedToArray(_scroll$line, 1);\n\n    const first = _scroll$line2[0];\n\n    let last = first;\n    if (range.length > 0) {\n      var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));\n\n      var _scroll$line4 = _slicedToArray(_scroll$line3, 1);\n\n      last = _scroll$line4[0];\n    }\n    if (first == null || last == null) return;\n    const scrollBounds = scrollingContainer.getBoundingClientRect();\n    if (bounds.top < scrollBounds.top) {\n      scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;\n    } else if (bounds.bottom > scrollBounds.bottom) {\n      scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;\n    }\n  }\n\n  setNativeRange(startNode, startOffset, endNode = startNode, endOffset = startOffset, force = false) {\n    debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);\n    if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {\n      return;\n    }\n    const selection = document.getSelection();\n    if (selection == null) return;\n    if (startNode != null) {\n      if (!this.hasFocus()) this.root.focus();\n\n      var _ref = this.getNativeRange() || {};\n\n      const native = _ref.native;\n\n      if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {\n        if (startNode.tagName === 'BR') {\n          startOffset = Array.from(startNode.parentNode.childNodes).indexOf(startNode);\n          startNode = startNode.parentNode;\n        }\n        if (endNode.tagName === 'BR') {\n          endOffset = Array.from(endNode.parentNode.childNodes).indexOf(endNode);\n          endNode = endNode.parentNode;\n        }\n        const range = document.createRange();\n        range.setStart(startNode, startOffset);\n        range.setEnd(endNode, endOffset);\n        selection.removeAllRanges();\n        selection.addRange(range);\n      }\n    } else {\n      selection.removeAllRanges();\n      this.root.blur();\n    }\n  }\n\n  setRange(range, force = false, source = _emitter2.default.sources.API) {\n    if (typeof force === 'string') {\n      source = force;\n      force = false;\n    }\n    debug.info('setRange', range);\n    if (range != null) {\n      const args = this.rangeToNative(range);\n      this.setNativeRange(...args, force);\n    } else {\n      this.setNativeRange(null);\n    }\n    this.update(source);\n  }\n\n  update(source = _emitter2.default.sources.USER) {\n    const oldRange = this.lastRange;\n\n    var _getRange = this.getRange(),\n        _getRange2 = _slicedToArray(_getRange, 2);\n\n    const lastRange = _getRange2[0],\n          nativeRange = _getRange2[1];\n\n    this.lastRange = lastRange;\n    if (this.lastRange != null) {\n      this.savedRange = this.lastRange;\n    }\n    if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {\n      if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {\n        const range = this.cursor.restore();\n        if (range) {\n          this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);\n        }\n      }\n      const args = [_emitter2.default.events.SELECTION_CHANGE, (0, _clone2.default)(this.lastRange), (0, _clone2.default)(oldRange), source];\n      this.emitter.emit(_emitter2.default.events.EDITOR_CHANGE, ...args);\n      if (source !== _emitter2.default.sources.SILENT) {\n        this.emitter.emit(...args);\n      }\n    }\n  }\n}\n\nfunction contains(parent, descendant) {\n  try {\n    // Firefox inserts inaccessible nodes around video elements\n    descendant.parentNode; // eslint-disable-line no-unused-expressions\n  } catch (e) {\n    return false;\n  }\n  return parent.contains(descendant);\n}\n\nexports.Range = Range;\nexports.default = Selection;\n\n//# sourceURL=webpack://Quill/./core/selection.js?");
            /***/
          },

          /***/
          "./core/theme.js":
          /*!***********************!*\
            !*** ./core/theme.js ***!
            \***********************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass Theme {\n  constructor(quill, options) {\n    this.quill = quill;\n    this.options = options;\n    this.modules = {};\n  }\n\n  init() {\n    Object.keys(this.options.modules).forEach(name => {\n      if (this.modules[name] == null) {\n        this.addModule(name);\n      }\n    });\n  }\n\n  addModule(name) {\n    const ModuleClass = this.quill.constructor.import(`modules/${name}`);\n    this.modules[name] = new ModuleClass(this.quill, this.options.modules[name] || {});\n    return this.modules[name];\n  }\n}\nTheme.DEFAULTS = {\n  modules: {}\n};\nTheme.themes = {\n  default: Theme\n};\n\nexports.default = Theme;\n\n//# sourceURL=webpack://Quill/./core/theme.js?");
            /***/
          },

          /***/
          "./formats/align.js":
          /*!**************************!*\
            !*** ./formats/align.js ***!
            \**************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AlignStyle = exports.AlignClass = exports.AlignAttribute = undefined;\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nconst config = {\n  scope: _parchment.Scope.BLOCK,\n  whitelist: ['right', 'center', 'justify']\n};\n\nconst AlignAttribute = new _parchment.Attributor('align', 'align', config);\nconst AlignClass = new _parchment.ClassAttributor('align', 'ql-align', config);\nconst AlignStyle = new _parchment.StyleAttributor('align', 'text-align', config);\n\nexports.AlignAttribute = AlignAttribute;\nexports.AlignClass = AlignClass;\nexports.AlignStyle = AlignStyle;\n\n//# sourceURL=webpack://Quill/./formats/align.js?");
            /***/
          },

          /***/
          "./formats/background.js":
          /*!*******************************!*\
            !*** ./formats/background.js ***!
            \*******************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BackgroundStyle = exports.BackgroundClass = undefined;\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _color = __webpack_require__(/*! ./color */ \"./formats/color.js\");\n\nconst BackgroundClass = new _parchment.ClassAttributor('background', 'ql-bg', {\n  scope: _parchment.Scope.INLINE\n});\nconst BackgroundStyle = new _color.ColorAttributor('background', 'background-color', {\n  scope: _parchment.Scope.INLINE\n});\n\nexports.BackgroundClass = BackgroundClass;\nexports.BackgroundStyle = BackgroundStyle;\n\n//# sourceURL=webpack://Quill/./formats/background.js?");
            /***/
          },

          /***/
          "./formats/blockquote.js":
          /*!*******************************!*\
            !*** ./formats/blockquote.js ***!
            \*******************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _block = __webpack_require__(/*! ../blots/block */ \"./blots/block.js\");\n\nvar _block2 = _interopRequireDefault(_block);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Blockquote extends _block2.default {}\nBlockquote.blotName = 'blockquote';\nBlockquote.tagName = 'blockquote';\n\nexports.default = Blockquote;\n\n//# sourceURL=webpack://Quill/./formats/blockquote.js?");
            /***/
          },

          /***/
          "./formats/bold.js":
          /*!*************************!*\
            !*** ./formats/bold.js ***!
            \*************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _inline = __webpack_require__(/*! ../blots/inline */ \"./blots/inline.js\");\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Bold extends _inline2.default {\n  static create() {\n    return super.create();\n  }\n\n  static formats() {\n    return true;\n  }\n\n  optimize(context) {\n    super.optimize(context);\n    if (this.domNode.tagName !== this.statics.tagName[0]) {\n      this.replaceWith(this.statics.blotName);\n    }\n  }\n}\nBold.blotName = 'bold';\nBold.tagName = ['STRONG', 'B'];\n\nexports.default = Bold;\n\n//# sourceURL=webpack://Quill/./formats/bold.js?");
            /***/
          },

          /***/
          "./formats/code.js":
          /*!*************************!*\
            !*** ./formats/code.js ***!
            \*************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.CodeBlockContainer = exports.Code = undefined;\n\nvar _block = __webpack_require__(/*! ../blots/block */ \"./blots/block.js\");\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _break = __webpack_require__(/*! ../blots/break */ \"./blots/break.js\");\n\nvar _break2 = _interopRequireDefault(_break);\n\nvar _cursor = __webpack_require__(/*! ../blots/cursor */ \"./blots/cursor.js\");\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _inline = __webpack_require__(/*! ../blots/inline */ \"./blots/inline.js\");\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _text = __webpack_require__(/*! ../blots/text */ \"./blots/text.js\");\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _container = __webpack_require__(/*! ../blots/container */ \"./blots/container.js\");\n\nvar _container2 = _interopRequireDefault(_container);\n\nvar _quill = __webpack_require__(/*! ../core/quill */ \"./core/quill.js\");\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass CodeBlockContainer extends _container2.default {\n  static create(value) {\n    const domNode = super.create(value);\n    domNode.setAttribute('spellcheck', false);\n    return domNode;\n  }\n\n  html(index, length) {\n    const text = this.children.map(child => child.domNode.innerText).join('\\n').slice(index, index + length);\n    return `<pre>${(0, _text.escapeText)(text)}</pre>`;\n  }\n}\n\nclass CodeBlock extends _block2.default {\n  static register() {\n    _quill2.default.register(CodeBlockContainer);\n  }\n}\n\nclass Code extends _inline2.default {}\nCode.blotName = 'code';\nCode.tagName = 'CODE';\n\nCodeBlock.blotName = 'code-block';\nCodeBlock.className = 'ql-code-block';\nCodeBlock.tagName = 'DIV';\nCodeBlockContainer.blotName = 'code-block-container';\nCodeBlockContainer.className = 'ql-code-block-container';\nCodeBlockContainer.tagName = 'DIV';\n\nCodeBlockContainer.allowedChildren = [CodeBlock];\n\nCodeBlock.allowedChildren = [_text2.default, _break2.default, _cursor2.default];\nCodeBlock.requiredContainer = CodeBlockContainer;\nCodeBlock.TAB = '  ';\n\nexports.Code = Code;\nexports.CodeBlockContainer = CodeBlockContainer;\nexports.default = CodeBlock;\n\n//# sourceURL=webpack://Quill/./formats/code.js?");
            /***/
          },

          /***/
          "./formats/color.js":
          /*!**************************!*\
            !*** ./formats/color.js ***!
            \**************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ColorStyle = exports.ColorClass = exports.ColorAttributor = undefined;\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nclass ColorAttributor extends _parchment.StyleAttributor {\n  value(domNode) {\n    let value = super.value(domNode);\n    if (!value.startsWith('rgb(')) return value;\n    value = value.replace(/^[^\\d]+/, '').replace(/[^\\d]+$/, '');\n    const hex = value.split(',').map(component => `00${parseInt(component, 10).toString(16)}`.slice(-2)).join('');\n    return `#${hex}`;\n  }\n}\n\nconst ColorClass = new _parchment.ClassAttributor('color', 'ql-color', {\n  scope: _parchment.Scope.INLINE\n});\nconst ColorStyle = new ColorAttributor('color', 'color', {\n  scope: _parchment.Scope.INLINE\n});\n\nexports.ColorAttributor = ColorAttributor;\nexports.ColorClass = ColorClass;\nexports.ColorStyle = ColorStyle;\n\n//# sourceURL=webpack://Quill/./formats/color.js?");
            /***/
          },

          /***/
          "./formats/direction.js":
          /*!******************************!*\
            !*** ./formats/direction.js ***!
            \******************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DirectionStyle = exports.DirectionClass = exports.DirectionAttribute = undefined;\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nconst config = {\n  scope: _parchment.Scope.BLOCK,\n  whitelist: ['rtl']\n};\n\nconst DirectionAttribute = new _parchment.Attributor('direction', 'dir', config);\nconst DirectionClass = new _parchment.ClassAttributor('direction', 'ql-direction', config);\nconst DirectionStyle = new _parchment.StyleAttributor('direction', 'direction', config);\n\nexports.DirectionAttribute = DirectionAttribute;\nexports.DirectionClass = DirectionClass;\nexports.DirectionStyle = DirectionStyle;\n\n//# sourceURL=webpack://Quill/./formats/direction.js?");
            /***/
          },

          /***/
          "./formats/font.js":
          /*!*************************!*\
            !*** ./formats/font.js ***!
            \*************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FontClass = exports.FontStyle = undefined;\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nconst config = {\n  scope: _parchment.Scope.INLINE,\n  whitelist: ['serif', 'monospace']\n};\n\nconst FontClass = new _parchment.ClassAttributor('font', 'ql-font', config);\n\nclass FontStyleAttributor extends _parchment.StyleAttributor {\n  value(node) {\n    return super.value(node).replace(/[\"']/g, '');\n  }\n}\n\nconst FontStyle = new FontStyleAttributor('font', 'font-family', config);\n\nexports.FontStyle = FontStyle;\nexports.FontClass = FontClass;\n\n//# sourceURL=webpack://Quill/./formats/font.js?");
            /***/
          },

          /***/
          "./formats/formula.js":
          /*!****************************!*\
            !*** ./formats/formula.js ***!
            \****************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _embed = __webpack_require__(/*! ../blots/embed */ \"./blots/embed.js\");\n\nvar _embed2 = _interopRequireDefault(_embed);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Formula extends _embed2.default {\n  static create(value) {\n    if (window.katex == null) {\n      throw new Error('Formula module requires KaTeX.');\n    }\n    const node = super.create(value);\n    if (typeof value === 'string') {\n      window.katex.render(value, node, {\n        throwOnError: false,\n        errorColor: '#f00'\n      });\n      node.setAttribute('data-value', value);\n    }\n    return node;\n  }\n\n  static value(domNode) {\n    return domNode.getAttribute('data-value');\n  }\n\n  html() {\n    var _value = this.value();\n\n    const formula = _value.formula;\n\n    return `<span>${formula}</span>`;\n  }\n}\nFormula.blotName = 'formula';\nFormula.className = 'ql-formula';\nFormula.tagName = 'SPAN';\n\nexports.default = Formula;\n\n//# sourceURL=webpack://Quill/./formats/formula.js?");
            /***/
          },

          /***/
          "./formats/header.js":
          /*!***************************!*\
            !*** ./formats/header.js ***!
            \***************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _block = __webpack_require__(/*! ../blots/block */ \"./blots/block.js\");\n\nvar _block2 = _interopRequireDefault(_block);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Header extends _block2.default {\n  static formats(domNode) {\n    return this.tagName.indexOf(domNode.tagName) + 1;\n  }\n}\nHeader.blotName = 'header';\nHeader.tagName = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];\n\nexports.default = Header;\n\n//# sourceURL=webpack://Quill/./formats/header.js?");
            /***/
          },

          /***/
          "./formats/image.js":
          /*!**************************!*\
            !*** ./formats/image.js ***!
            \**************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _link = __webpack_require__(/*! ./link */ \"./formats/link.js\");\n\nconst ATTRIBUTES = ['alt', 'height', 'width'];\n\nclass Image extends _parchment.EmbedBlot {\n  static create(value) {\n    const node = super.create(value);\n    if (typeof value === 'string') {\n      node.setAttribute('src', this.sanitize(value));\n    }\n    return node;\n  }\n\n  static formats(domNode) {\n    return ATTRIBUTES.reduce((formats, attribute) => {\n      if (domNode.hasAttribute(attribute)) {\n        formats[attribute] = domNode.getAttribute(attribute);\n      }\n      return formats;\n    }, {});\n  }\n\n  static match(url) {\n    return (/\\.(jpe?g|gif|png)$/.test(url) || /^data:image\\/.+;base64/.test(url)\n    );\n  }\n\n  static register() {\n    if (/Firefox/i.test(navigator.userAgent)) {\n      setTimeout(() => {\n        // Disable image resizing in Firefox\n        document.execCommand('enableObjectResizing', false, false);\n      }, 1);\n    }\n  }\n\n  static sanitize(url) {\n    return (0, _link.sanitize)(url, ['http', 'https', 'data']) ? url : '//:0';\n  }\n\n  static value(domNode) {\n    return domNode.getAttribute('src');\n  }\n\n  format(name, value) {\n    if (ATTRIBUTES.indexOf(name) > -1) {\n      if (value) {\n        this.domNode.setAttribute(name, value);\n      } else {\n        this.domNode.removeAttribute(name);\n      }\n    } else {\n      super.format(name, value);\n    }\n  }\n}\nImage.blotName = 'image';\nImage.tagName = 'IMG';\n\nexports.default = Image;\n\n//# sourceURL=webpack://Quill/./formats/image.js?");
            /***/
          },

          /***/
          "./formats/indent.js":
          /*!***************************!*\
            !*** ./formats/indent.js ***!
            \***************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nclass IndentAttributor extends _parchment.ClassAttributor {\n  add(node, value) {\n    if (value === '+1' || value === '-1') {\n      const indent = this.value(node) || 0;\n      value = value === '+1' ? indent + 1 : indent - 1;\n    }\n    if (value === 0) {\n      this.remove(node);\n      return true;\n    }\n    return super.add(node, value);\n  }\n\n  canAdd(node, value) {\n    return super.canAdd(node, value) || super.canAdd(node, parseInt(value, 10));\n  }\n\n  value(node) {\n    return parseInt(super.value(node), 10) || undefined; // Don't return NaN\n  }\n}\n\nconst IndentClass = new IndentAttributor('indent', 'ql-indent', {\n  scope: _parchment.Scope.BLOCK,\n  whitelist: [1, 2, 3, 4, 5, 6, 7, 8]\n});\n\nexports.default = IndentClass;\n\n//# sourceURL=webpack://Quill/./formats/indent.js?");
            /***/
          },

          /***/
          "./formats/italic.js":
          /*!***************************!*\
            !*** ./formats/italic.js ***!
            \***************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _bold = __webpack_require__(/*! ./bold */ \"./formats/bold.js\");\n\nvar _bold2 = _interopRequireDefault(_bold);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Italic extends _bold2.default {}\nItalic.blotName = 'italic';\nItalic.tagName = ['EM', 'I'];\n\nexports.default = Italic;\n\n//# sourceURL=webpack://Quill/./formats/italic.js?");
            /***/
          },

          /***/
          "./formats/link.js":
          /*!*************************!*\
            !*** ./formats/link.js ***!
            \*************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sanitize = exports.default = undefined;\n\nvar _inline = __webpack_require__(/*! ../blots/inline */ \"./blots/inline.js\");\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Link extends _inline2.default {\n  static create(value) {\n    const node = super.create(value);\n    node.setAttribute('href', this.sanitize(value));\n    node.setAttribute('target', '_blank');\n    return node;\n  }\n\n  static formats(domNode) {\n    return domNode.getAttribute('href');\n  }\n\n  static sanitize(url) {\n    return sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;\n  }\n\n  format(name, value) {\n    if (name !== this.statics.blotName || !value) {\n      super.format(name, value);\n    } else {\n      this.domNode.setAttribute('href', this.constructor.sanitize(value));\n    }\n  }\n}\nLink.blotName = 'link';\nLink.tagName = 'A';\nLink.SANITIZED_URL = 'about:blank';\nLink.PROTOCOL_WHITELIST = ['http', 'https', 'mailto', 'tel'];\n\nfunction sanitize(url, protocols) {\n  const anchor = document.createElement('a');\n  anchor.href = url;\n  const protocol = anchor.href.slice(0, anchor.href.indexOf(':'));\n  return protocols.indexOf(protocol) > -1;\n}\n\nexports.default = Link;\nexports.sanitize = sanitize;\n\n//# sourceURL=webpack://Quill/./formats/link.js?");
            /***/
          },

          /***/
          "./formats/list.js":
          /*!*************************!*\
            !*** ./formats/list.js ***!
            \*************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.ListContainer = undefined;\n\nvar _block = __webpack_require__(/*! ../blots/block */ \"./blots/block.js\");\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _container = __webpack_require__(/*! ../blots/container */ \"./blots/container.js\");\n\nvar _container2 = _interopRequireDefault(_container);\n\nvar _quill = __webpack_require__(/*! ../core/quill */ \"./core/quill.js\");\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass ListContainer extends _container2.default {}\nListContainer.blotName = 'list-container';\nListContainer.tagName = 'OL';\n\nclass ListItem extends _block2.default {\n  static create(value) {\n    const node = super.create();\n    node.setAttribute('data-list', value);\n    return node;\n  }\n\n  static formats(domNode) {\n    return domNode.getAttribute('data-list') || undefined;\n  }\n\n  static register() {\n    _quill2.default.register(ListContainer);\n  }\n\n  constructor(scroll, domNode) {\n    super(scroll, domNode);\n    const ui = domNode.ownerDocument.createElement('span');\n    const listEventHandler = e => {\n      if (!scroll.isEnabled()) return;\n      const format = this.statics.formats(domNode, scroll);\n      if (format === 'checked') {\n        this.format('list', 'unchecked');\n        e.preventDefault();\n      } else if (format === 'unchecked') {\n        this.format('list', 'checked');\n        e.preventDefault();\n      }\n    };\n    ui.addEventListener('mousedown', listEventHandler);\n    ui.addEventListener('touchstart', listEventHandler);\n    this.attachUI(ui);\n  }\n\n  format(name, value) {\n    if (name === this.statics.blotName && value) {\n      this.domNode.setAttribute('data-list', value);\n    } else {\n      super.format(name, value);\n    }\n  }\n}\nListItem.blotName = 'list';\nListItem.tagName = 'LI';\n\nListContainer.allowedChildren = [ListItem];\nListItem.requiredContainer = ListContainer;\n\nexports.ListContainer = ListContainer;\nexports.default = ListItem;\n\n//# sourceURL=webpack://Quill/./formats/list.js?");
            /***/
          },

          /***/
          "./formats/script.js":
          /*!***************************!*\
            !*** ./formats/script.js ***!
            \***************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _inline = __webpack_require__(/*! ../blots/inline */ \"./blots/inline.js\");\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Script extends _inline2.default {\n  static create(value) {\n    if (value === 'super') {\n      return document.createElement('sup');\n    }\n    if (value === 'sub') {\n      return document.createElement('sub');\n    }\n    return super.create(value);\n  }\n\n  static formats(domNode) {\n    if (domNode.tagName === 'SUB') return 'sub';\n    if (domNode.tagName === 'SUP') return 'super';\n    return undefined;\n  }\n}\nScript.blotName = 'script';\nScript.tagName = ['SUB', 'SUP'];\n\nexports.default = Script;\n\n//# sourceURL=webpack://Quill/./formats/script.js?");
            /***/
          },

          /***/
          "./formats/size.js":
          /*!*************************!*\
            !*** ./formats/size.js ***!
            \*************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SizeStyle = exports.SizeClass = undefined;\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nconst SizeClass = new _parchment.ClassAttributor('size', 'ql-size', {\n  scope: _parchment.Scope.INLINE,\n  whitelist: ['small', 'large', 'huge']\n});\nconst SizeStyle = new _parchment.StyleAttributor('size', 'font-size', {\n  scope: _parchment.Scope.INLINE,\n  whitelist: ['10px', '18px', '32px']\n});\n\nexports.SizeClass = SizeClass;\nexports.SizeStyle = SizeStyle;\n\n//# sourceURL=webpack://Quill/./formats/size.js?");
            /***/
          },

          /***/
          "./formats/strike.js":
          /*!***************************!*\
            !*** ./formats/strike.js ***!
            \***************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _inline = __webpack_require__(/*! ../blots/inline */ \"./blots/inline.js\");\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Strike extends _inline2.default {}\nStrike.blotName = 'strike';\nStrike.tagName = 'S';\n\nexports.default = Strike;\n\n//# sourceURL=webpack://Quill/./formats/strike.js?");
            /***/
          },

          /***/
          "./formats/table.js":
          /*!**************************!*\
            !*** ./formats/table.js ***!
            \**************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tableId = exports.TableContainer = exports.TableBody = exports.TableRow = exports.TableCell = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _block = __webpack_require__(/*! ../blots/block */ \"./blots/block.js\");\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _container = __webpack_require__(/*! ../blots/container */ \"./blots/container.js\");\n\nvar _container2 = _interopRequireDefault(_container);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass TableCell extends _block2.default {\n  static create(value) {\n    const node = super.create();\n    if (value) {\n      node.setAttribute('data-row', value);\n    } else {\n      node.setAttribute('data-row', tableId());\n    }\n    return node;\n  }\n\n  static formats(domNode) {\n    if (domNode.hasAttribute('data-row')) {\n      return domNode.getAttribute('data-row');\n    }\n    return undefined;\n  }\n\n  cellOffset() {\n    if (this.parent) {\n      return this.parent.children.indexOf(this);\n    }\n    return -1;\n  }\n\n  format(name, value) {\n    if (name === TableCell.blotName && value) {\n      this.domNode.setAttribute('data-row', value);\n    } else {\n      super.format(name, value);\n    }\n  }\n\n  row() {\n    return this.parent;\n  }\n\n  rowOffset() {\n    if (this.row()) {\n      return this.row().rowOffset();\n    }\n    return -1;\n  }\n\n  table() {\n    return this.row() && this.row().table();\n  }\n}\nTableCell.blotName = 'table';\nTableCell.tagName = 'TD';\n\nclass TableRow extends _container2.default {\n  checkMerge() {\n    if (super.checkMerge() && this.next.children.head != null) {\n      const thisHead = this.children.head.formats();\n      const thisTail = this.children.tail.formats();\n      const nextHead = this.next.children.head.formats();\n      const nextTail = this.next.children.tail.formats();\n      return thisHead.table === thisTail.table && thisHead.table === nextHead.table && thisHead.table === nextTail.table;\n    }\n    return false;\n  }\n\n  optimize(...args) {\n    super.optimize(...args);\n    this.children.forEach(child => {\n      if (child.next == null) return;\n      const childFormats = child.formats();\n      const nextFormats = child.next.formats();\n      if (childFormats.table !== nextFormats.table) {\n        const next = this.splitAfter(child);\n        if (next) {\n          next.optimize();\n        }\n        // We might be able to merge with prev now\n        if (this.prev) {\n          this.prev.optimize();\n        }\n      }\n    });\n  }\n\n  rowOffset() {\n    if (this.parent) {\n      return this.parent.children.indexOf(this);\n    }\n    return -1;\n  }\n\n  table() {\n    return this.parent && this.parent.parent;\n  }\n}\nTableRow.blotName = 'table-row';\nTableRow.tagName = 'TR';\n\nclass TableBody extends _container2.default {}\nTableBody.blotName = 'table-body';\nTableBody.tagName = 'TBODY';\n\nclass TableContainer extends _container2.default {\n  balanceCells() {\n    const rows = this.descendants(TableRow);\n    const maxColumns = rows.reduce((max, row) => {\n      return Math.max(row.children.length, max);\n    }, 0);\n    rows.forEach(row => {\n      new Array(maxColumns - row.children.length).fill(0).forEach(() => {\n        let value;\n        if (row.children.head != null) {\n          value = TableCell.formats(row.children.head.domNode);\n        }\n        const blot = this.scroll.create(TableCell.blotName, value);\n        row.appendChild(blot);\n        blot.optimize(); // Add break blot\n      });\n    });\n  }\n\n  cells(column) {\n    return this.rows().map(row => row.children.at(column));\n  }\n\n  deleteColumn(index) {\n    var _descendant = this.descendant(TableBody),\n        _descendant2 = _slicedToArray(_descendant, 1);\n\n    const body = _descendant2[0];\n\n    if (body == null || body.children.head == null) return;\n    body.children.forEach(row => {\n      const cell = row.children.at(index);\n      if (cell != null) {\n        cell.remove();\n      }\n    });\n  }\n\n  insertColumn(index) {\n    var _descendant3 = this.descendant(TableBody),\n        _descendant4 = _slicedToArray(_descendant3, 1);\n\n    const body = _descendant4[0];\n\n    if (body == null || body.children.head == null) return;\n    body.children.forEach(row => {\n      const ref = row.children.at(index);\n      const value = TableCell.formats(row.children.head.domNode);\n      const cell = this.scroll.create(TableCell.blotName, value);\n      row.insertBefore(cell, ref);\n    });\n  }\n\n  insertRow(index) {\n    var _descendant5 = this.descendant(TableBody),\n        _descendant6 = _slicedToArray(_descendant5, 1);\n\n    const body = _descendant6[0];\n\n    if (body == null || body.children.head == null) return;\n    const id = tableId();\n    const row = this.scroll.create(TableRow.blotName);\n    body.children.head.children.forEach(() => {\n      const cell = this.scroll.create(TableCell.blotName, id);\n      row.appendChild(cell);\n    });\n    const ref = body.children.at(index);\n    body.insertBefore(row, ref);\n  }\n\n  rows() {\n    const body = this.children.head;\n    if (body == null) return [];\n    return body.children.map(row => row);\n  }\n}\nTableContainer.blotName = 'table-container';\nTableContainer.tagName = 'TABLE';\n\nTableContainer.allowedChildren = [TableBody];\nTableBody.requiredContainer = TableContainer;\n\nTableBody.allowedChildren = [TableRow];\nTableRow.requiredContainer = TableBody;\n\nTableRow.allowedChildren = [TableCell];\nTableCell.requiredContainer = TableRow;\n\nfunction tableId() {\n  const id = Math.random().toString(36).slice(2, 6);\n  return `row-${id}`;\n}\n\nexports.TableCell = TableCell;\nexports.TableRow = TableRow;\nexports.TableBody = TableBody;\nexports.TableContainer = TableContainer;\nexports.tableId = tableId;\n\n//# sourceURL=webpack://Quill/./formats/table.js?");
            /***/
          },

          /***/
          "./formats/underline.js":
          /*!******************************!*\
            !*** ./formats/underline.js ***!
            \******************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _inline = __webpack_require__(/*! ../blots/inline */ \"./blots/inline.js\");\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Underline extends _inline2.default {}\nUnderline.blotName = 'underline';\nUnderline.tagName = 'U';\n\nexports.default = Underline;\n\n//# sourceURL=webpack://Quill/./formats/underline.js?");
            /***/
          },

          /***/
          "./formats/video.js":
          /*!**************************!*\
            !*** ./formats/video.js ***!
            \**************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _block = __webpack_require__(/*! ../blots/block */ \"./blots/block.js\");\n\nvar _link = __webpack_require__(/*! ./link */ \"./formats/link.js\");\n\nvar _link2 = _interopRequireDefault(_link);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst ATTRIBUTES = ['height', 'width'];\n\nclass Video extends _block.BlockEmbed {\n  static create(value) {\n    const node = super.create(value);\n    node.setAttribute('frameborder', '0');\n    node.setAttribute('allowfullscreen', true);\n    node.setAttribute('src', this.sanitize(value));\n    return node;\n  }\n\n  static formats(domNode) {\n    return ATTRIBUTES.reduce((formats, attribute) => {\n      if (domNode.hasAttribute(attribute)) {\n        formats[attribute] = domNode.getAttribute(attribute);\n      }\n      return formats;\n    }, {});\n  }\n\n  static sanitize(url) {\n    return _link2.default.sanitize(url); // eslint-disable-line import/no-named-as-default-member\n  }\n\n  static value(domNode) {\n    return domNode.getAttribute('src');\n  }\n\n  format(name, value) {\n    if (ATTRIBUTES.indexOf(name) > -1) {\n      if (value) {\n        this.domNode.setAttribute(name, value);\n      } else {\n        this.domNode.removeAttribute(name);\n      }\n    } else {\n      super.format(name, value);\n    }\n  }\n\n  html() {\n    var _value = this.value();\n\n    const video = _value.video;\n\n    return `<a href=\"${video}\">${video}</a>`;\n  }\n}\nVideo.blotName = 'video';\nVideo.className = 'ql-video';\nVideo.tagName = 'IFRAME';\n\nexports.default = Video;\n\n//# sourceURL=webpack://Quill/./formats/video.js?");
            /***/
          },

          /***/
          "./modules/clipboard.js":
          /*!******************************!*\
            !*** ./modules/clipboard.js ***!
            \******************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.traverse = exports.matchText = exports.matchNewline = exports.matchBlot = exports.matchAttributor = exports.default = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _quillDelta = __webpack_require__(/*! quill-delta */ \"./node_modules/quill-delta/dist/Delta.js\");\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _quill = __webpack_require__(/*! ../core/quill */ \"./core/quill.js\");\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nvar _logger = __webpack_require__(/*! ../core/logger */ \"./core/logger.js\");\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _module = __webpack_require__(/*! ../core/module */ \"./core/module.js\");\n\nvar _module2 = _interopRequireDefault(_module);\n\nvar _align = __webpack_require__(/*! ../formats/align */ \"./formats/align.js\");\n\nvar _background = __webpack_require__(/*! ../formats/background */ \"./formats/background.js\");\n\nvar _code = __webpack_require__(/*! ../formats/code */ \"./formats/code.js\");\n\nvar _code2 = _interopRequireDefault(_code);\n\nvar _color = __webpack_require__(/*! ../formats/color */ \"./formats/color.js\");\n\nvar _direction = __webpack_require__(/*! ../formats/direction */ \"./formats/direction.js\");\n\nvar _font = __webpack_require__(/*! ../formats/font */ \"./formats/font.js\");\n\nvar _size = __webpack_require__(/*! ../formats/size */ \"./formats/size.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _logger2.default)('quill:clipboard');\n\nconst CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ['br', matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ['li', matchIndent], ['ol, ul', matchList], ['pre', matchCodeBlock], ['tr', matchTable], ['b', matchAlias.bind(matchAlias, 'bold')], ['i', matchAlias.bind(matchAlias, 'italic')], ['style', matchIgnore]];\n\nconst ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce((memo, attr) => {\n  memo[attr.keyName] = attr;\n  return memo;\n}, {});\n\nconst STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce((memo, attr) => {\n  memo[attr.keyName] = attr;\n  return memo;\n}, {});\n\nclass Clipboard extends _module2.default {\n  constructor(quill, options) {\n    super(quill, options);\n    this.quill.root.addEventListener('copy', e => this.onCaptureCopy(e, false));\n    this.quill.root.addEventListener('cut', e => this.onCaptureCopy(e, true));\n    this.quill.root.addEventListener('paste', this.onCapturePaste.bind(this));\n    this.matchers = [];\n    CLIPBOARD_CONFIG.concat(this.options.matchers).forEach(([selector, matcher]) => {\n      this.addMatcher(selector, matcher);\n    });\n  }\n\n  addMatcher(selector, matcher) {\n    this.matchers.push([selector, matcher]);\n  }\n\n  convert({ html, text }, formats = {}) {\n    if (formats[_code2.default.blotName]) {\n      return new _quillDelta2.default().insert(text, {\n        [_code2.default.blotName]: formats[_code2.default.blotName]\n      });\n    }\n    if (!html) {\n      return new _quillDelta2.default().insert(text || '');\n    }\n    const doc = new DOMParser().parseFromString(html, 'text/html');\n    const container = doc.body;\n    const nodeMatches = new WeakMap();\n\n    var _prepareMatching = this.prepareMatching(container, nodeMatches),\n        _prepareMatching2 = _slicedToArray(_prepareMatching, 2);\n\n    const elementMatchers = _prepareMatching2[0],\n          textMatchers = _prepareMatching2[1];\n\n    const delta = traverse(this.quill.scroll, container, elementMatchers, textMatchers, nodeMatches);\n    // Remove trailing newline\n    if (deltaEndsWith(delta, '\\n') && (delta.ops[delta.ops.length - 1].attributes == null || formats.table)) {\n      return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));\n    }\n    return delta;\n  }\n\n  dangerouslyPasteHTML(index, html, source = _quill2.default.sources.API) {\n    if (typeof index === 'string') {\n      const delta = this.convert({ html: index, text: '' });\n      this.quill.setContents(delta, html);\n      this.quill.setSelection(0, _quill2.default.sources.SILENT);\n    } else {\n      const paste = this.convert({ html, text: '' });\n      this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste), source);\n      this.quill.setSelection(index + paste.length(), _quill2.default.sources.SILENT);\n    }\n  }\n\n  onCaptureCopy(e, isCut = false) {\n    if (e.defaultPrevented) return;\n    e.preventDefault();\n\n    var _quill$selection$getR = this.quill.selection.getRange(),\n        _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1);\n\n    const range = _quill$selection$getR2[0];\n\n    if (range == null) return;\n\n    var _onCopy = this.onCopy(range, isCut);\n\n    const html = _onCopy.html,\n          text = _onCopy.text;\n\n    e.clipboardData.setData('text/plain', text);\n    e.clipboardData.setData('text/html', html);\n    if (isCut) {\n      this.quill.deleteText(range, _quill2.default.sources.USER);\n    }\n  }\n\n  onCapturePaste(e) {\n    if (e.defaultPrevented || !this.quill.isEnabled()) return;\n    e.preventDefault();\n    const range = this.quill.getSelection(true);\n    if (range == null) return;\n    const html = e.clipboardData.getData('text/html');\n    const text = e.clipboardData.getData('text/plain');\n    const files = Array.from(e.clipboardData.files || []);\n    if (!html && files.length > 0) {\n      this.quill.uploader.upload(range, files);\n    } else {\n      this.onPaste(range, { html, text });\n    }\n  }\n\n  onCopy(range) {\n    const text = this.quill.getText(range);\n    const html = this.quill.getSemanticHTML(range);\n    return { html, text };\n  }\n\n  onPaste(range, { text, html }) {\n    const formats = this.quill.getFormat(range.index);\n    const pastedDelta = this.convert({ text, html }, formats);\n    debug.log('onPaste', pastedDelta, { text, html });\n    const delta = new _quillDelta2.default().retain(range.index).delete(range.length).concat(pastedDelta);\n    this.quill.updateContents(delta, _quill2.default.sources.USER);\n    // range.length contributes to delta.length()\n    this.quill.setSelection(delta.length() - range.length, _quill2.default.sources.SILENT);\n    this.quill.scrollIntoView();\n  }\n\n  prepareMatching(container, nodeMatches) {\n    const elementMatchers = [];\n    const textMatchers = [];\n    this.matchers.forEach(pair => {\n      var _pair = _slicedToArray(pair, 2);\n\n      const selector = _pair[0],\n            matcher = _pair[1];\n\n      switch (selector) {\n        case Node.TEXT_NODE:\n          textMatchers.push(matcher);\n          break;\n        case Node.ELEMENT_NODE:\n          elementMatchers.push(matcher);\n          break;\n        default:\n          Array.from(container.querySelectorAll(selector)).forEach(node => {\n            if (nodeMatches.has(node)) {\n              const matches = nodeMatches.get(node);\n              matches.push(matcher);\n            } else {\n              nodeMatches.set(node, [matcher]);\n            }\n          });\n          break;\n      }\n    });\n    return [elementMatchers, textMatchers];\n  }\n}\nClipboard.DEFAULTS = {\n  matchers: []\n};\n\nfunction applyFormat(delta, format, value) {\n  if (typeof format === 'object') {\n    return Object.keys(format).reduce((newDelta, key) => {\n      return applyFormat(newDelta, key, format[key]);\n    }, delta);\n  }\n  return delta.reduce((newDelta, op) => {\n    if (op.attributes && op.attributes[format]) {\n      return newDelta.push(op);\n    }\n    return newDelta.insert(op.insert, (0, _extend2.default)({}, { [format]: value }, op.attributes));\n  }, new _quillDelta2.default());\n}\n\nfunction deltaEndsWith(delta, text) {\n  let endText = '';\n  for (let i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i // eslint-disable-line no-plusplus\n  ) {\n    const op = delta.ops[i];\n    if (typeof op.insert !== 'string') break;\n    endText = op.insert + endText;\n  }\n  return endText.slice(-1 * text.length) === text;\n}\n\nfunction isLine(node) {\n  if (node.childNodes.length === 0) return false; // Exclude embed blocks\n  return ['address', 'article', 'blockquote', 'canvas', 'dd', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'iframe', 'li', 'main', 'nav', 'ol', 'output', 'p', 'pre', 'section', 'table', 'td', 'tr', 'ul', 'video'].includes(node.tagName.toLowerCase());\n}\n\nconst preNodes = new WeakMap();\nfunction isPre(node) {\n  if (node == null) return false;\n  if (!preNodes.has(node)) {\n    if (node.tagName === 'PRE') {\n      preNodes.set(node, true);\n    } else {\n      preNodes.set(node, isPre(node.parentNode));\n    }\n  }\n  return preNodes.get(node);\n}\n\nfunction traverse(scroll, node, elementMatchers, textMatchers, nodeMatches) {\n  // Post-order\n  if (node.nodeType === node.TEXT_NODE) {\n    return textMatchers.reduce((delta, matcher) => {\n      return matcher(node, delta, scroll);\n    }, new _quillDelta2.default());\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    return Array.from(node.childNodes || []).reduce((delta, childNode) => {\n      let childrenDelta = traverse(scroll, childNode, elementMatchers, textMatchers, nodeMatches);\n      if (childNode.nodeType === node.ELEMENT_NODE) {\n        childrenDelta = elementMatchers.reduce((reducedDelta, matcher) => {\n          return matcher(childNode, reducedDelta, scroll);\n        }, childrenDelta);\n        childrenDelta = (nodeMatches.get(childNode) || []).reduce((reducedDelta, matcher) => {\n          return matcher(childNode, reducedDelta, scroll);\n        }, childrenDelta);\n      }\n      return delta.concat(childrenDelta);\n    }, new _quillDelta2.default());\n  }\n  return new _quillDelta2.default();\n}\n\nfunction matchAlias(format, node, delta) {\n  return applyFormat(delta, format, true);\n}\n\nfunction matchAttributor(node, delta, scroll) {\n  const attributes = _parchment.Attributor.keys(node);\n  const classes = _parchment.ClassAttributor.keys(node);\n  const styles = _parchment.StyleAttributor.keys(node);\n  const formats = {};\n  attributes.concat(classes).concat(styles).forEach(name => {\n    let attr = scroll.query(name, _parchment.Scope.ATTRIBUTE);\n    if (attr != null) {\n      formats[attr.attrName] = attr.value(node);\n      if (formats[attr.attrName]) return;\n    }\n    attr = ATTRIBUTE_ATTRIBUTORS[name];\n    if (attr != null && (attr.attrName === name || attr.keyName === name)) {\n      formats[attr.attrName] = attr.value(node) || undefined;\n    }\n    attr = STYLE_ATTRIBUTORS[name];\n    if (attr != null && (attr.attrName === name || attr.keyName === name)) {\n      attr = STYLE_ATTRIBUTORS[name];\n      formats[attr.attrName] = attr.value(node) || undefined;\n    }\n  });\n  if (Object.keys(formats).length > 0) {\n    return applyFormat(delta, formats);\n  }\n  return delta;\n}\n\nfunction matchBlot(node, delta, scroll) {\n  const match = scroll.query(node);\n  if (match == null) return delta;\n  if (match.prototype instanceof _parchment.EmbedBlot) {\n    const embed = {};\n    const value = match.value(node);\n    if (value != null) {\n      embed[match.blotName] = value;\n      return new _quillDelta2.default().insert(embed, match.formats(node, scroll));\n    }\n  } else {\n    if (match.prototype instanceof _parchment.BlockBlot && !deltaEndsWith(delta, '\\n')) {\n      delta.insert('\\n');\n    }\n    if (typeof match.formats === 'function') {\n      return applyFormat(delta, match.blotName, match.formats(node, scroll));\n    }\n  }\n  return delta;\n}\n\nfunction matchBreak(node, delta) {\n  if (!deltaEndsWith(delta, '\\n')) {\n    delta.insert('\\n');\n  }\n  return delta;\n}\n\nfunction matchCodeBlock(node, delta, scroll) {\n  const match = scroll.query('code-block');\n  const language = match ? match.formats(node, scroll) : true;\n  return applyFormat(delta, 'code-block', language);\n}\n\nfunction matchIgnore() {\n  return new _quillDelta2.default();\n}\n\nfunction matchIndent(node, delta, scroll) {\n  const match = scroll.query(node);\n  if (match == null || match.blotName !== 'list' || !deltaEndsWith(delta, '\\n')) {\n    return delta;\n  }\n  let indent = -1;\n  let parent = node.parentNode;\n  while (parent != null) {\n    if (['OL', 'UL'].includes(parent.tagName)) {\n      indent += 1;\n    }\n    parent = parent.parentNode;\n  }\n  if (indent <= 0) return delta;\n  return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, { indent }));\n}\n\nfunction matchList(node, delta) {\n  const list = node.tagName === 'OL' ? 'ordered' : 'bullet';\n  return applyFormat(delta, 'list', list);\n}\n\nfunction matchNewline(node, delta) {\n  if (!deltaEndsWith(delta, '\\n')) {\n    if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {\n      delta.insert('\\n');\n    }\n  }\n  return delta;\n}\n\nfunction matchStyles(node, delta) {\n  const formats = {};\n  const style = node.style || {};\n  if (style.fontStyle === 'italic') {\n    formats.italic = true;\n  }\n  if (style.fontWeight.startsWith('bold') || parseInt(style.fontWeight, 10) >= 700) {\n    formats.bold = true;\n  }\n  if (Object.keys(formats).length > 0) {\n    delta = applyFormat(delta, formats);\n  }\n  if (parseFloat(style.textIndent || 0) > 0) {\n    // Could be 0.5in\n    return new _quillDelta2.default().insert('\\t').concat(delta);\n  }\n  return delta;\n}\n\nfunction matchTable(node, delta) {\n  const table = node.parentNode.tagName === 'TABLE' ? node.parentNode : node.parentNode.parentNode;\n  const rows = Array.from(table.querySelectorAll('tr'));\n  const row = rows.indexOf(node) + 1;\n  return applyFormat(delta, 'table', row);\n}\n\nfunction matchText(node, delta) {\n  let text = node.data;\n  // Word represents empty line with <o:p>&nbsp;</o:p>\n  if (node.parentNode.tagName === 'O:P') {\n    return delta.insert(text.trim());\n  }\n  if (text.trim().length === 0) {\n    return delta;\n  }\n  if (!isPre(node)) {\n    const replacer = (collapse, match) => {\n      const replaced = match.replace(/[^\\u00a0]/g, ''); // \\u00a0 is nbsp;\n      return replaced.length < 1 && collapse ? ' ' : replaced;\n    };\n    text = text.replace(/\\r\\n/g, ' ').replace(/\\n/g, ' ');\n    text = text.replace(/\\s\\s+/g, replacer.bind(replacer, true)); // collapse whitespace\n    if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {\n      text = text.replace(/^\\s+/, replacer.bind(replacer, false));\n    }\n    if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {\n      text = text.replace(/\\s+$/, replacer.bind(replacer, false));\n    }\n  }\n  return delta.insert(text);\n}\n\nexports.default = Clipboard;\nexports.matchAttributor = matchAttributor;\nexports.matchBlot = matchBlot;\nexports.matchNewline = matchNewline;\nexports.matchText = matchText;\nexports.traverse = traverse;\n\n//# sourceURL=webpack://Quill/./modules/clipboard.js?");
            /***/
          },

          /***/
          "./modules/history.js":
          /*!****************************!*\
            !*** ./modules/history.js ***!
            \****************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLastChangeIndex = exports.default = undefined;\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _quillDelta = __webpack_require__(/*! quill-delta */ \"./node_modules/quill-delta/dist/Delta.js\");\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _quill = __webpack_require__(/*! ../core/quill */ \"./core/quill.js\");\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nvar _module = __webpack_require__(/*! ../core/module */ \"./core/module.js\");\n\nvar _module2 = _interopRequireDefault(_module);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass History extends _module2.default {\n  constructor(quill, options) {\n    super(quill, options);\n    this.lastRecorded = 0;\n    this.ignoreChange = false;\n    this.clear();\n    this.quill.on(_quill2.default.events.EDITOR_CHANGE, (eventName, delta, oldDelta, source) => {\n      if (eventName !== _quill2.default.events.TEXT_CHANGE || this.ignoreChange) return;\n      if (!this.options.userOnly || source === _quill2.default.sources.USER) {\n        this.record(delta, oldDelta);\n      } else {\n        this.transform(delta);\n      }\n    });\n    this.quill.keyboard.addBinding({ key: 'z', shortKey: true }, this.undo.bind(this));\n    this.quill.keyboard.addBinding({ key: 'z', shortKey: true, shiftKey: true }, this.redo.bind(this));\n    if (/Win/i.test(navigator.platform)) {\n      this.quill.keyboard.addBinding({ key: 'y', shortKey: true }, this.redo.bind(this));\n    }\n  }\n\n  change(source, dest) {\n    if (this.stack[source].length === 0) return;\n    const delta = this.stack[source].pop();\n    this.stack[dest].push(delta);\n    this.lastRecorded = 0;\n    this.ignoreChange = true;\n    this.quill.updateContents(delta[source], _quill2.default.sources.USER);\n    this.ignoreChange = false;\n    const index = getLastChangeIndex(this.quill.scroll, delta[source]);\n    this.quill.setSelection(index);\n  }\n\n  clear() {\n    this.stack = { undo: [], redo: [] };\n  }\n\n  cutoff() {\n    this.lastRecorded = 0;\n  }\n\n  record(changeDelta, oldDelta) {\n    if (changeDelta.ops.length === 0) return;\n    this.stack.redo = [];\n    let undoDelta = guessUndoDelta(changeDelta);\n    if (undoDelta == null) {\n      undoDelta = this.quill.getContents().diff(oldDelta);\n    }\n    const timestamp = Date.now();\n    if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {\n      const delta = this.stack.undo.pop();\n      undoDelta = undoDelta.compose(delta.undo);\n      changeDelta = delta.redo.compose(changeDelta);\n    } else {\n      this.lastRecorded = timestamp;\n    }\n    this.stack.undo.push({\n      redo: changeDelta,\n      undo: undoDelta\n    });\n    if (this.stack.undo.length > this.options.maxStack) {\n      this.stack.undo.shift();\n    }\n  }\n\n  redo() {\n    this.change('redo', 'undo');\n  }\n\n  transform(delta) {\n    this.stack.undo.forEach(change => {\n      change.undo = delta.transform(change.undo, true);\n      change.redo = delta.transform(change.redo, true);\n    });\n    this.stack.redo.forEach(change => {\n      change.undo = delta.transform(change.undo, true);\n      change.redo = delta.transform(change.redo, true);\n    });\n  }\n\n  undo() {\n    this.change('undo', 'redo');\n  }\n}\nHistory.DEFAULTS = {\n  delay: 1000,\n  maxStack: 100,\n  userOnly: false\n};\n\nfunction endsWithNewlineChange(scroll, delta) {\n  const lastOp = delta.ops[delta.ops.length - 1];\n  if (lastOp == null) return false;\n  if (lastOp.insert != null) {\n    return typeof lastOp.insert === 'string' && lastOp.insert.endsWith('\\n');\n  }\n  if (lastOp.attributes != null) {\n    return Object.keys(lastOp.attributes).some(attr => {\n      return scroll.query(attr, _parchment.Scope.BLOCK) != null;\n    });\n  }\n  return false;\n}\n\nfunction getLastChangeIndex(scroll, delta) {\n  const deleteLength = delta.reduce((length, op) => {\n    return length + (op.delete || 0);\n  }, 0);\n  let changeIndex = delta.length() - deleteLength;\n  if (endsWithNewlineChange(scroll, delta)) {\n    changeIndex -= 1;\n  }\n  return changeIndex;\n}\n\nfunction guessUndoDelta(delta) {\n  const undoDelta = new _quillDelta2.default();\n  let failed = false;\n  delta.forEach(op => {\n    if (op.insert) {\n      undoDelta.delete(_quillDelta.Op.length(op));\n    } else if (op.retain && op.attributes == null) {\n      undoDelta.retain(op.retain);\n    } else {\n      failed = true;\n      return false;\n    }\n    return true;\n  });\n  return failed ? null : undoDelta;\n}\n\nexports.default = History;\nexports.getLastChangeIndex = getLastChangeIndex;\n\n//# sourceURL=webpack://Quill/./modules/history.js?");
            /***/
          },

          /***/
          "./modules/keyboard.js":
          /*!*****************************!*\
            !*** ./modules/keyboard.js ***!
            \*****************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalize = exports.SHORTKEY = exports.default = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _clone = __webpack_require__(/*! clone */ \"./node_modules/clone/clone.js\");\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _deepEqual = __webpack_require__(/*! deep-equal */ \"./node_modules/deep-equal/index.js\");\n\nvar _deepEqual2 = _interopRequireDefault(_deepEqual);\n\nvar _extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _quillDelta = __webpack_require__(/*! quill-delta */ \"./node_modules/quill-delta/dist/Delta.js\");\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _quill = __webpack_require__(/*! ../core/quill */ \"./core/quill.js\");\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nvar _logger = __webpack_require__(/*! ../core/logger */ \"./core/logger.js\");\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _module = __webpack_require__(/*! ../core/module */ \"./core/module.js\");\n\nvar _module2 = _interopRequireDefault(_module);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _logger2.default)('quill:keyboard');\n\nconst SHORTKEY = /Mac/i.test(navigator.platform) ? 'metaKey' : 'ctrlKey';\n\nclass Keyboard extends _module2.default {\n  static match(evt, binding) {\n    if (['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].some(key => {\n      return !!binding[key] !== evt[key] && binding[key] !== null;\n    })) {\n      return false;\n    }\n    return binding.key === evt.key || binding.key === evt.which;\n  }\n\n  constructor(quill, options) {\n    super(quill, options);\n    this.bindings = {};\n    Object.keys(this.options.bindings).forEach(name => {\n      if (this.options.bindings[name]) {\n        this.addBinding(this.options.bindings[name]);\n      }\n    });\n    this.addBinding({ key: 'Enter', shiftKey: null }, handleEnter);\n    this.addBinding({ key: 'Enter', metaKey: null, ctrlKey: null, altKey: null }, () => {});\n    if (/Firefox/i.test(navigator.userAgent)) {\n      // Need to handle delete and backspace for Firefox in the general case #1171\n      this.addBinding({ key: 'Backspace' }, { collapsed: true }, handleBackspace);\n      this.addBinding({ key: 'Delete' }, { collapsed: true }, handleDelete);\n    } else {\n      this.addBinding({ key: 'Backspace' }, { collapsed: true, prefix: /^.?$/ }, handleBackspace);\n      this.addBinding({ key: 'Delete' }, { collapsed: true, suffix: /^.?$/ }, handleDelete);\n    }\n    this.addBinding({ key: 'Backspace' }, { collapsed: false }, handleDeleteRange);\n    this.addBinding({ key: 'Delete' }, { collapsed: false }, handleDeleteRange);\n    this.addBinding({\n      key: 'Backspace',\n      altKey: null,\n      ctrlKey: null,\n      metaKey: null,\n      shiftKey: null\n    }, { collapsed: true, offset: 0 }, handleBackspace);\n    this.listen();\n  }\n\n  addBinding(keyBinding, context = {}, handler = {}) {\n    const binding = normalize(keyBinding);\n    if (binding == null) {\n      debug.warn('Attempted to add invalid keyboard binding', binding);\n      return;\n    }\n    if (typeof context === 'function') {\n      context = { handler: context };\n    }\n    if (typeof handler === 'function') {\n      handler = { handler };\n    }\n    const keys = Array.isArray(binding.key) ? binding.key : [binding.key];\n    keys.forEach(key => {\n      const singleBinding = (0, _extend2.default)({}, binding, { key }, context, handler);\n      this.bindings[singleBinding.key] = this.bindings[singleBinding.key] || [];\n      this.bindings[singleBinding.key].push(singleBinding);\n    });\n  }\n\n  listen() {\n    this.quill.root.addEventListener('keydown', evt => {\n      if (evt.defaultPrevented) return;\n      const bindings = (this.bindings[evt.key] || []).concat(this.bindings[evt.which] || []);\n      const matches = bindings.filter(binding => Keyboard.match(evt, binding));\n      if (matches.length === 0) return;\n      const range = this.quill.getSelection();\n      if (range == null || !this.quill.hasFocus()) return;\n\n      var _quill$getLine = this.quill.getLine(range.index),\n          _quill$getLine2 = _slicedToArray(_quill$getLine, 2);\n\n      const line = _quill$getLine2[0],\n            offset = _quill$getLine2[1];\n\n      var _quill$getLeaf = this.quill.getLeaf(range.index),\n          _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2);\n\n      const leafStart = _quill$getLeaf2[0],\n            offsetStart = _quill$getLeaf2[1];\n\n      var _ref = range.length === 0 ? [leafStart, offsetStart] : this.quill.getLeaf(range.index + range.length),\n          _ref2 = _slicedToArray(_ref, 2);\n\n      const leafEnd = _ref2[0],\n            offsetEnd = _ref2[1];\n\n      const prefixText = leafStart instanceof _parchment.TextBlot ? leafStart.value().slice(0, offsetStart) : '';\n      const suffixText = leafEnd instanceof _parchment.TextBlot ? leafEnd.value().slice(offsetEnd) : '';\n      const curContext = {\n        collapsed: range.length === 0,\n        empty: range.length === 0 && line.length() <= 1,\n        format: this.quill.getFormat(range),\n        line,\n        offset,\n        prefix: prefixText,\n        suffix: suffixText,\n        event: evt\n      };\n      const prevented = matches.some(binding => {\n        if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) {\n          return false;\n        }\n        if (binding.empty != null && binding.empty !== curContext.empty) {\n          return false;\n        }\n        if (binding.offset != null && binding.offset !== curContext.offset) {\n          return false;\n        }\n        if (Array.isArray(binding.format)) {\n          // any format is present\n          if (binding.format.every(name => curContext.format[name] == null)) {\n            return false;\n          }\n        } else if (typeof binding.format === 'object') {\n          // all formats must match\n          if (!Object.keys(binding.format).every(name => {\n            if (binding.format[name] === true) return curContext.format[name] != null;\n            if (binding.format[name] === false) return curContext.format[name] == null;\n            return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);\n          })) {\n            return false;\n          }\n        }\n        if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) {\n          return false;\n        }\n        if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) {\n          return false;\n        }\n        return binding.handler.call(this, range, curContext, binding) !== true;\n      });\n      if (prevented) {\n        evt.preventDefault();\n      }\n    });\n  }\n}\n\nKeyboard.DEFAULTS = {\n  bindings: {\n    bold: makeFormatHandler('bold'),\n    italic: makeFormatHandler('italic'),\n    underline: makeFormatHandler('underline'),\n    indent: {\n      // highlight tab or tab at beginning of list, indent or blockquote\n      key: 'Tab',\n      format: ['blockquote', 'indent', 'list'],\n      handler(range, context) {\n        if (context.collapsed && context.offset !== 0) return true;\n        this.quill.format('indent', '+1', _quill2.default.sources.USER);\n        return false;\n      }\n    },\n    outdent: {\n      key: 'Tab',\n      shiftKey: true,\n      format: ['blockquote', 'indent', 'list'],\n      // highlight tab or tab at beginning of list, indent or blockquote\n      handler(range, context) {\n        if (context.collapsed && context.offset !== 0) return true;\n        this.quill.format('indent', '-1', _quill2.default.sources.USER);\n        return false;\n      }\n    },\n    'outdent backspace': {\n      key: 'Backspace',\n      collapsed: true,\n      shiftKey: null,\n      metaKey: null,\n      ctrlKey: null,\n      altKey: null,\n      format: ['indent', 'list'],\n      offset: 0,\n      handler(range, context) {\n        if (context.format.indent != null) {\n          this.quill.format('indent', '-1', _quill2.default.sources.USER);\n        } else if (context.format.list != null) {\n          this.quill.format('list', false, _quill2.default.sources.USER);\n        }\n      }\n    },\n    'indent code-block': makeCodeBlockHandler(true),\n    'outdent code-block': makeCodeBlockHandler(false),\n    'remove tab': {\n      key: 'Tab',\n      shiftKey: true,\n      collapsed: true,\n      prefix: /\\t$/,\n      handler(range) {\n        this.quill.deleteText(range.index - 1, 1, _quill2.default.sources.USER);\n      }\n    },\n    tab: {\n      key: 'Tab',\n      handler(range, context) {\n        if (context.format.table) return true;\n        this.quill.history.cutoff();\n        const delta = new _quillDelta2.default().retain(range.index).delete(range.length).insert('\\t');\n        this.quill.updateContents(delta, _quill2.default.sources.USER);\n        this.quill.history.cutoff();\n        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n        return false;\n      }\n    },\n    'blockquote empty enter': {\n      key: 'Enter',\n      collapsed: true,\n      format: ['blockquote'],\n      empty: true,\n      handler() {\n        this.quill.format('blockquote', false, _quill2.default.sources.USER);\n      }\n    },\n    'list empty enter': {\n      key: 'Enter',\n      collapsed: true,\n      format: ['list'],\n      empty: true,\n      handler(range, context) {\n        const formats = { list: false };\n        if (context.format.indent) {\n          formats.indent = false;\n        }\n        this.quill.formatLine(range.index, range.length, formats, _quill2.default.sources.USER);\n      }\n    },\n    'checklist enter': {\n      key: 'Enter',\n      collapsed: true,\n      format: { list: 'checked' },\n      handler(range) {\n        var _quill$getLine3 = this.quill.getLine(range.index),\n            _quill$getLine4 = _slicedToArray(_quill$getLine3, 2);\n\n        const line = _quill$getLine4[0],\n              offset = _quill$getLine4[1];\n\n        const formats = (0, _extend2.default)({}, line.formats(), { list: 'checked' });\n        const delta = new _quillDelta2.default().retain(range.index).insert('\\n', formats).retain(line.length() - offset - 1).retain(1, { list: 'unchecked' });\n        this.quill.updateContents(delta, _quill2.default.sources.USER);\n        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n        this.quill.scrollIntoView();\n      }\n    },\n    'header enter': {\n      key: 'Enter',\n      collapsed: true,\n      format: ['header'],\n      suffix: /^$/,\n      handler(range, context) {\n        var _quill$getLine5 = this.quill.getLine(range.index),\n            _quill$getLine6 = _slicedToArray(_quill$getLine5, 2);\n\n        const line = _quill$getLine6[0],\n              offset = _quill$getLine6[1];\n\n        const delta = new _quillDelta2.default().retain(range.index).insert('\\n', context.format).retain(line.length() - offset - 1).retain(1, { header: null });\n        this.quill.updateContents(delta, _quill2.default.sources.USER);\n        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n        this.quill.scrollIntoView();\n      }\n    },\n    'table backspace': {\n      key: 'Backspace',\n      format: ['table'],\n      collapsed: true,\n      offset: 0,\n      handler() {}\n    },\n    'table delete': {\n      key: 'Delete',\n      format: ['table'],\n      collapsed: true,\n      suffix: /^$/,\n      handler() {}\n    },\n    'table enter': {\n      key: 'Enter',\n      shiftKey: null,\n      format: ['table'],\n      handler(range) {\n        const module = this.quill.getModule('table');\n        if (module) {\n          var _module$getTable = module.getTable(range),\n              _module$getTable2 = _slicedToArray(_module$getTable, 4);\n\n          const table = _module$getTable2[0],\n                row = _module$getTable2[1],\n                cell = _module$getTable2[2],\n                offset = _module$getTable2[3];\n\n          const shift = tableSide(table, row, cell, offset);\n          if (shift == null) return;\n          let index = table.offset();\n          if (shift < 0) {\n            const delta = new _quillDelta2.default().retain(index).insert('\\n');\n            this.quill.updateContents(delta, _quill2.default.sources.USER);\n            this.quill.setSelection(range.index + 1, range.length, _quill2.default.sources.SILENT);\n          } else if (shift > 0) {\n            index += table.length();\n            const delta = new _quillDelta2.default().retain(index).insert('\\n');\n            this.quill.updateContents(delta, _quill2.default.sources.USER);\n            this.quill.setSelection(index, _quill2.default.sources.USER);\n          }\n        }\n      }\n    },\n    'table tab': {\n      key: 'Tab',\n      shiftKey: null,\n      format: ['table'],\n      handler(range, context) {\n        const event = context.event,\n              cell = context.line;\n\n        const offset = cell.offset(this.quill.scroll);\n        if (event.shiftKey) {\n          this.quill.setSelection(offset - 1, _quill2.default.sources.USER);\n        } else {\n          this.quill.setSelection(offset + cell.length(), _quill2.default.sources.USER);\n        }\n      }\n    },\n    'list autofill': {\n      key: ' ',\n      shiftKey: null,\n      collapsed: true,\n      format: {\n        list: false,\n        'code-block': false,\n        blockquote: false,\n        header: false,\n        table: false\n      },\n      prefix: /^\\s*?(\\d+\\.|-|\\*|\\[ ?\\]|\\[x\\])$/,\n      handler(range, context) {\n        if (this.quill.scroll.query('list') == null) return true;\n        const length = context.prefix.length;\n\n        var _quill$getLine7 = this.quill.getLine(range.index),\n            _quill$getLine8 = _slicedToArray(_quill$getLine7, 2);\n\n        const line = _quill$getLine8[0],\n              offset = _quill$getLine8[1];\n\n        if (offset > length) return true;\n        let value;\n        switch (context.prefix.trim()) {\n          case '[]':\n          case '[ ]':\n            value = 'unchecked';\n            break;\n          case '[x]':\n            value = 'checked';\n            break;\n          case '-':\n          case '*':\n            value = 'bullet';\n            break;\n          default:\n            value = 'ordered';\n        }\n        this.quill.insertText(range.index, ' ', _quill2.default.sources.USER);\n        this.quill.history.cutoff();\n        const delta = new _quillDelta2.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, { list: value });\n        this.quill.updateContents(delta, _quill2.default.sources.USER);\n        this.quill.history.cutoff();\n        this.quill.setSelection(range.index - length, _quill2.default.sources.SILENT);\n        return false;\n      }\n    },\n    'code exit': {\n      key: 'Enter',\n      collapsed: true,\n      format: ['code-block'],\n      prefix: /^$/,\n      suffix: /^\\s*$/,\n      handler(range) {\n        var _quill$getLine9 = this.quill.getLine(range.index),\n            _quill$getLine10 = _slicedToArray(_quill$getLine9, 2);\n\n        const line = _quill$getLine10[0],\n              offset = _quill$getLine10[1];\n\n        let numLines = 2;\n        let cur = line;\n        while (cur != null && cur.length() <= 1 && cur.formats()['code-block']) {\n          cur = cur.prev;\n          numLines -= 1;\n          // Requisite prev lines are empty\n          if (numLines <= 0) {\n            const delta = new _quillDelta2.default().retain(range.index + line.length() - offset - 2).retain(1, { 'code-block': null }).delete(1);\n            this.quill.updateContents(delta, _quill2.default.sources.USER);\n            this.quill.setSelection(range.index - 1, _quill2.default.sources.SILENT);\n            return false;\n          }\n        }\n        return true;\n      }\n    },\n    'embed left': makeEmbedArrowHandler('ArrowLeft', false),\n    'embed left shift': makeEmbedArrowHandler('ArrowLeft', true),\n    'embed right': makeEmbedArrowHandler('ArrowRight', false),\n    'embed right shift': makeEmbedArrowHandler('ArrowRight', true),\n    'table down': makeTableArrowHandler(false),\n    'table up': makeTableArrowHandler(true)\n  }\n};\n\nfunction handleBackspace(range, context) {\n  if (range.index === 0 || this.quill.getLength() <= 1) return;\n\n  var _quill$getLine11 = this.quill.getLine(range.index),\n      _quill$getLine12 = _slicedToArray(_quill$getLine11, 1);\n\n  const line = _quill$getLine12[0];\n\n  let formats = {};\n  if (context.offset === 0) {\n    var _quill$getLine13 = this.quill.getLine(range.index - 1),\n        _quill$getLine14 = _slicedToArray(_quill$getLine13, 1);\n\n    const prev = _quill$getLine14[0];\n\n    if (prev != null) {\n      if (prev.length() > 1 || prev.statics.blotName === 'table') {\n        const curFormats = line.formats();\n        const prevFormats = this.quill.getFormat(range.index - 1, 1);\n        formats = _quillDelta.AttributeMap.diff(curFormats, prevFormats) || {};\n      }\n    }\n  }\n  // Check for astral symbols\n  const length = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]$/.test(context.prefix) ? 2 : 1;\n  this.quill.deleteText(range.index - length, length, _quill2.default.sources.USER);\n  if (Object.keys(formats).length > 0) {\n    this.quill.formatLine(range.index - length, length, formats, _quill2.default.sources.USER);\n  }\n  this.quill.focus();\n}\n\nfunction handleDelete(range, context) {\n  // Check for astral symbols\n  const length = /^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/.test(context.suffix) ? 2 : 1;\n  if (range.index >= this.quill.getLength() - length) return;\n  let formats = {};\n  let nextLength = 0;\n\n  var _quill$getLine15 = this.quill.getLine(range.index),\n      _quill$getLine16 = _slicedToArray(_quill$getLine15, 1);\n\n  const line = _quill$getLine16[0];\n\n  if (context.offset >= line.length() - 1) {\n    var _quill$getLine17 = this.quill.getLine(range.index + 1),\n        _quill$getLine18 = _slicedToArray(_quill$getLine17, 1);\n\n    const next = _quill$getLine18[0];\n\n    if (next) {\n      const curFormats = line.formats();\n      const nextFormats = this.quill.getFormat(range.index, 1);\n      formats = _quillDelta.AttributeMap.diff(curFormats, nextFormats) || {};\n      nextLength = next.length();\n    }\n  }\n  this.quill.deleteText(range.index, length, _quill2.default.sources.USER);\n  if (Object.keys(formats).length > 0) {\n    this.quill.formatLine(range.index + nextLength - 1, length, formats, _quill2.default.sources.USER);\n  }\n}\n\nfunction handleDeleteRange(range) {\n  const lines = this.quill.getLines(range);\n  let formats = {};\n  if (lines.length > 1) {\n    const firstFormats = lines[0].formats();\n    const lastFormats = lines[lines.length - 1].formats();\n    formats = _quillDelta.AttributeMap.diff(lastFormats, firstFormats) || {};\n  }\n  this.quill.deleteText(range, _quill2.default.sources.USER);\n  if (Object.keys(formats).length > 0) {\n    this.quill.formatLine(range.index, 1, formats, _quill2.default.sources.USER);\n  }\n  this.quill.setSelection(range.index, _quill2.default.sources.SILENT);\n  this.quill.focus();\n}\n\n// TODO use just updateContents()\nfunction handleEnter(range, context) {\n  if (range.length > 0) {\n    this.quill.scroll.deleteAt(range.index, range.length); // So we do not trigger text-change\n  }\n  const lineFormats = Object.keys(context.format).reduce((formats, format) => {\n    if (this.quill.scroll.query(format, _parchment.Scope.BLOCK) && !Array.isArray(context.format[format])) {\n      formats[format] = context.format[format];\n    }\n    return formats;\n  }, {});\n  this.quill.insertText(range.index, '\\n', lineFormats, _quill2.default.sources.USER);\n  // Earlier scroll.deleteAt might have messed up our selection,\n  // so insertText's built in selection preservation is not reliable\n  this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n  this.quill.focus();\n  Object.keys(context.format).forEach(name => {\n    if (lineFormats[name] != null) return;\n    if (Array.isArray(context.format[name])) return;\n    if (name === 'link') return;\n    this.quill.format(name, context.format[name], _quill2.default.sources.USER);\n  });\n}\n\nfunction makeCodeBlockHandler(indent) {\n  return {\n    key: 'Tab',\n    shiftKey: !indent,\n    format: { 'code-block': true },\n    handler(range) {\n      const CodeBlock = this.quill.scroll.query('code-block');\n      const lines = range.length === 0 ? this.quill.getLines(range.index, 1) : this.quill.getLines(range);\n      let index = range.index,\n          length = range.length;\n\n      lines.forEach((line, i) => {\n        if (indent) {\n          line.insertAt(0, CodeBlock.TAB);\n          if (i === 0) {\n            index += CodeBlock.TAB.length;\n          } else {\n            length += CodeBlock.TAB.length;\n          }\n        } else if (line.domNode.textContent.startsWith(CodeBlock.TAB)) {\n          line.deleteAt(0, CodeBlock.TAB.length);\n          if (i === 0) {\n            index -= CodeBlock.TAB.length;\n          } else {\n            length -= CodeBlock.TAB.length;\n          }\n        }\n      });\n      this.quill.update(_quill2.default.sources.USER);\n      this.quill.setSelection(index, length, _quill2.default.sources.SILENT);\n    }\n  };\n}\n\nfunction makeEmbedArrowHandler(key, shiftKey) {\n  const where = key === 'ArrowLeft' ? 'prefix' : 'suffix';\n  return {\n    key,\n    shiftKey,\n    altKey: null,\n    [where]: /^$/,\n    handler(range) {\n      let index = range.index;\n\n      if (key === 'ArrowRight') {\n        index += range.length + 1;\n      }\n\n      var _quill$getLeaf3 = this.quill.getLeaf(index),\n          _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1);\n\n      const leaf = _quill$getLeaf4[0];\n\n      if (!(leaf instanceof _parchment.EmbedBlot)) return true;\n      if (key === 'ArrowLeft') {\n        if (shiftKey) {\n          this.quill.setSelection(range.index - 1, range.length + 1, _quill2.default.sources.USER);\n        } else {\n          this.quill.setSelection(range.index - 1, _quill2.default.sources.USER);\n        }\n      } else if (shiftKey) {\n        this.quill.setSelection(range.index, range.length + 1, _quill2.default.sources.USER);\n      } else {\n        this.quill.setSelection(range.index + range.length + 1, _quill2.default.sources.USER);\n      }\n      return false;\n    }\n  };\n}\n\nfunction makeFormatHandler(format) {\n  return {\n    key: format[0],\n    shortKey: true,\n    handler(range, context) {\n      this.quill.format(format, !context.format[format], _quill2.default.sources.USER);\n    }\n  };\n}\n\nfunction makeTableArrowHandler(up) {\n  return {\n    key: up ? 'ArrowUp' : 'ArrowDown',\n    collapsed: true,\n    format: ['table'],\n    handler(range, context) {\n      // TODO move to table module\n      const key = up ? 'prev' : 'next';\n      const cell = context.line;\n      const targetRow = cell.parent[key];\n      if (targetRow != null) {\n        if (targetRow.statics.blotName === 'table-row') {\n          let targetCell = targetRow.children.head;\n          let cur = cell;\n          while (cur.prev != null) {\n            cur = cur.prev;\n            targetCell = targetCell.next;\n          }\n          const index = targetCell.offset(this.quill.scroll) + Math.min(context.offset, targetCell.length() - 1);\n          this.quill.setSelection(index, 0, _quill2.default.sources.USER);\n        }\n      } else {\n        const targetLine = cell.table()[key];\n        if (targetLine != null) {\n          if (up) {\n            this.quill.setSelection(targetLine.offset(this.quill.scroll) + targetLine.length() - 1, 0, _quill2.default.sources.USER);\n          } else {\n            this.quill.setSelection(targetLine.offset(this.quill.scroll), 0, _quill2.default.sources.USER);\n          }\n        }\n      }\n      return false;\n    }\n  };\n}\n\nfunction normalize(binding) {\n  if (typeof binding === 'string' || typeof binding === 'number') {\n    binding = { key: binding };\n  } else if (typeof binding === 'object') {\n    binding = (0, _clone2.default)(binding, false);\n  } else {\n    return null;\n  }\n  if (binding.shortKey) {\n    binding[SHORTKEY] = binding.shortKey;\n    delete binding.shortKey;\n  }\n  return binding;\n}\n\nfunction tableSide(table, row, cell, offset) {\n  if (row.prev == null && row.next == null) {\n    if (cell.prev == null && cell.next == null) {\n      return offset === 0 ? -1 : 1;\n    }\n    return cell.prev == null ? -1 : 1;\n  }\n  if (row.prev == null) {\n    return -1;\n  }\n  if (row.next == null) {\n    return 1;\n  }\n  return null;\n}\n\nexports.default = Keyboard;\nexports.SHORTKEY = SHORTKEY;\nexports.normalize = normalize;\n\n//# sourceURL=webpack://Quill/./modules/keyboard.js?");
            /***/
          },

          /***/
          "./modules/syntax.js":
          /*!***************************!*\
            !*** ./modules/syntax.js ***!
            \***************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.CodeToken = exports.CodeBlock = undefined;\n\nvar _quillDelta = __webpack_require__(/*! quill-delta */ \"./node_modules/quill-delta/dist/Delta.js\");\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _inline = __webpack_require__(/*! ../blots/inline */ \"./blots/inline.js\");\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _quill = __webpack_require__(/*! ../core/quill */ \"./core/quill.js\");\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nvar _module = __webpack_require__(/*! ../core/module */ \"./core/module.js\");\n\nvar _module2 = _interopRequireDefault(_module);\n\nvar _block = __webpack_require__(/*! ../blots/block */ \"./blots/block.js\");\n\nvar _break = __webpack_require__(/*! ../blots/break */ \"./blots/break.js\");\n\nvar _break2 = _interopRequireDefault(_break);\n\nvar _cursor = __webpack_require__(/*! ../blots/cursor */ \"./blots/cursor.js\");\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _text = __webpack_require__(/*! ../blots/text */ \"./blots/text.js\");\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _code = __webpack_require__(/*! ../formats/code */ \"./formats/code.js\");\n\nvar _code2 = _interopRequireDefault(_code);\n\nvar _clipboard = __webpack_require__(/*! ./clipboard */ \"./modules/clipboard.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst TokenAttributor = new _parchment.ClassAttributor('code-token', 'hljs', {\n  scope: _parchment.Scope.INLINE\n});\nclass CodeToken extends _inline2.default {\n  static formats(node, scroll) {\n    while (node != null && node !== scroll.domNode) {\n      if (node.classList.contains(_code2.default.className)) {\n        return super.formats(node, scroll);\n      }\n      node = node.parentNode;\n    }\n    return undefined;\n  }\n\n  constructor(scroll, domNode, value) {\n    super(scroll, domNode, value);\n    TokenAttributor.add(this.domNode, value);\n  }\n\n  format(format, value) {\n    if (format !== CodeToken.blotName) {\n      super.format(format, value);\n    } else if (value) {\n      TokenAttributor.add(this.domNode, value);\n    } else {\n      TokenAttributor.remove(this.domNode);\n      this.domNode.classList.remove(this.statics.className);\n    }\n  }\n\n  optimize(...args) {\n    super.optimize(...args);\n    if (!TokenAttributor.value(this.domNode)) {\n      this.unwrap();\n    }\n  }\n}\nCodeToken.blotName = 'code-token';\nCodeToken.className = 'ql-token';\n\nclass SyntaxCodeBlock extends _code2.default {\n  static create(value) {\n    const domNode = super.create(value);\n    if (typeof value === 'string') {\n      domNode.setAttribute('data-language', value);\n    }\n    return domNode;\n  }\n\n  static formats(domNode) {\n    return domNode.getAttribute('data-language') || 'plain';\n  }\n\n  static register() {} // Syntax module will register\n\n  format(name, value) {\n    if (name === this.statics.blotName && value) {\n      this.domNode.setAttribute('data-language', value);\n    } else {\n      super.format(name, value);\n    }\n  }\n\n  replaceWith(name, value) {\n    this.formatAt(0, this.length(), CodeToken.blotName, false);\n    return super.replaceWith(name, value);\n  }\n}\n\nclass SyntaxCodeBlockContainer extends _code.CodeBlockContainer {\n  attach() {\n    super.attach();\n    this.forceNext = false;\n    this.scroll.emitMount(this);\n  }\n\n  format(name, value) {\n    if (name === SyntaxCodeBlock.blotName) {\n      this.forceNext = true;\n      this.children.forEach(child => {\n        child.format(name, value);\n      });\n    }\n  }\n\n  formatAt(index, length, name, value) {\n    if (name === SyntaxCodeBlock.blotName) {\n      this.forceNext = true;\n    }\n    super.formatAt(index, length, name, value);\n  }\n\n  highlight(highlight, forced = false) {\n    if (this.children.head == null) return;\n    const nodes = Array.from(this.domNode.childNodes).filter(node => node !== this.uiNode);\n    const text = `${nodes.map(node => node.textContent).join('\\n')}\\n`;\n    const language = SyntaxCodeBlock.formats(this.children.head.domNode);\n    if (forced || this.forceNext || this.cachedText !== text) {\n      if (text.trim().length > 0 || this.cachedText == null) {\n        const oldDelta = this.children.reduce((delta, child) => {\n          return delta.concat((0, _block.blockDelta)(child));\n        }, new _quillDelta2.default());\n        const delta = highlight(text, language);\n        oldDelta.diff(delta).reduce((index, { retain, attributes }) => {\n          // Should be all retains\n          if (!retain) return index;\n          if (attributes) {\n            Object.keys(attributes).forEach(format => {\n              if ([SyntaxCodeBlock.blotName, CodeToken.blotName].includes(format)) {\n                this.formatAt(index, retain, format, attributes[format]);\n              }\n            });\n          }\n          return index + retain;\n        }, 0);\n      }\n      this.cachedText = text;\n      this.forceNext = false;\n    }\n  }\n\n  optimize(context) {\n    super.optimize(context);\n    if (this.parent != null && this.children.head != null && this.uiNode != null) {\n      const language = SyntaxCodeBlock.formats(this.children.head.domNode);\n      if (language !== this.uiNode.value) {\n        this.uiNode.value = language;\n      }\n    }\n  }\n}\nSyntaxCodeBlockContainer.allowedChildren = [SyntaxCodeBlock];\nSyntaxCodeBlock.requiredContainer = SyntaxCodeBlockContainer;\nSyntaxCodeBlock.allowedChildren = [CodeToken, _cursor2.default, _text2.default, _break2.default];\n\nclass Syntax extends _module2.default {\n  static register() {\n    _quill2.default.register(CodeToken, true);\n    _quill2.default.register(SyntaxCodeBlock, true);\n    _quill2.default.register(SyntaxCodeBlockContainer, true);\n  }\n\n  constructor(quill, options) {\n    super(quill, options);\n    if (this.options.hljs == null) {\n      throw new Error('Syntax module requires highlight.js. Please include the library on the page before Quill.');\n    }\n    this.highlightBlot = this.highlightBlot.bind(this);\n    this.initListener();\n    this.initTimer();\n  }\n\n  initListener() {\n    this.quill.on(_quill2.default.events.SCROLL_BLOT_MOUNT, blot => {\n      if (!(blot instanceof SyntaxCodeBlockContainer)) return;\n      const select = this.quill.root.ownerDocument.createElement('select');\n      this.options.languages.forEach(({ key, label }) => {\n        const option = select.ownerDocument.createElement('option');\n        option.textContent = label;\n        option.setAttribute('value', key);\n        select.appendChild(option);\n      });\n      select.addEventListener('change', () => {\n        blot.format(SyntaxCodeBlock.blotName, select.value);\n        this.quill.root.focus(); // Prevent scrolling\n        this.highlight(blot, true);\n      });\n      if (blot.uiNode == null) {\n        blot.attachUI(select);\n        if (blot.children.head) {\n          select.value = SyntaxCodeBlock.formats(blot.children.head.domNode);\n        }\n      }\n    });\n  }\n\n  initTimer() {\n    let timer = null;\n    this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, () => {\n      clearTimeout(timer);\n      timer = setTimeout(() => {\n        this.highlight();\n        timer = null;\n      }, this.options.interval);\n    });\n  }\n\n  highlight(blot = null, force = false) {\n    if (this.quill.selection.composing) return;\n    this.quill.update(_quill2.default.sources.USER);\n    const range = this.quill.getSelection();\n    const blots = blot == null ? this.quill.scroll.descendants(SyntaxCodeBlockContainer) : [blot];\n    blots.forEach(container => {\n      container.highlight(this.highlightBlot, force);\n    });\n    this.quill.update(_quill2.default.sources.SILENT);\n    if (range != null) {\n      this.quill.setSelection(range, _quill2.default.sources.SILENT);\n    }\n  }\n\n  highlightBlot(text, language = 'plain') {\n    if (language === 'plain') {\n      return (0, _text.escapeText)(text).split('\\n').reduce((delta, line, i) => {\n        if (i !== 0) {\n          delta.insert('\\n', { [_code2.default.blotName]: language });\n        }\n        return delta.insert(line);\n      }, new _quillDelta2.default());\n    }\n    const container = this.quill.root.ownerDocument.createElement('div');\n    container.classList.add(_code2.default.className);\n    container.innerHTML = this.options.hljs.highlight(language, text).value;\n    return (0, _clipboard.traverse)(this.quill.scroll, container, [(node, delta) => {\n      const value = TokenAttributor.value(node);\n      if (value) {\n        return delta.compose(new _quillDelta2.default().retain(delta.length(), {\n          [CodeToken.blotName]: value\n        }));\n      }\n      return delta;\n    }], [(node, delta) => {\n      return node.data.split('\\n').reduce((memo, nodeText, i) => {\n        if (i !== 0) memo.insert('\\n', { [_code2.default.blotName]: language });\n        return memo.insert(nodeText);\n      }, delta);\n    }], new WeakMap());\n  }\n}\nSyntax.DEFAULTS = {\n  hljs: (() => {\n    return window.hljs;\n  })(),\n  interval: 1000,\n  languages: [{ key: 'plain', label: 'Plain' }, { key: 'bash', label: 'Bash' }, { key: 'cpp', label: 'C++' }, { key: 'cs', label: 'C#' }, { key: 'css', label: 'CSS' }, { key: 'diff', label: 'Diff' }, { key: 'xml', label: 'HTML/XML' }, { key: 'java', label: 'Java' }, { key: 'javascript', label: 'Javascript' }, { key: 'markdown', label: 'Markdown' }, { key: 'php', label: 'PHP' }, { key: 'python', label: 'Python' }, { key: 'ruby', label: 'Ruby' }, { key: 'sql', label: 'SQL' }]\n};\n\nexports.CodeBlock = SyntaxCodeBlock;\nexports.CodeToken = CodeToken;\nexports.default = Syntax;\n\n//# sourceURL=webpack://Quill/./modules/syntax.js?");
            /***/
          },

          /***/
          "./modules/table.js":
          /*!**************************!*\
            !*** ./modules/table.js ***!
            \**************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _quillDelta = __webpack_require__(/*! quill-delta */ \"./node_modules/quill-delta/dist/Delta.js\");\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _quill = __webpack_require__(/*! ../core/quill */ \"./core/quill.js\");\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nvar _module = __webpack_require__(/*! ../core/module */ \"./core/module.js\");\n\nvar _module2 = _interopRequireDefault(_module);\n\nvar _table = __webpack_require__(/*! ../formats/table */ \"./formats/table.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Table extends _module2.default {\n  static register() {\n    _quill2.default.register(_table.TableCell);\n    _quill2.default.register(_table.TableRow);\n    _quill2.default.register(_table.TableBody);\n    _quill2.default.register(_table.TableContainer);\n  }\n\n  constructor(...args) {\n    super(...args);\n    this.listenBalanceCells();\n  }\n\n  balanceTables() {\n    this.quill.scroll.descendants(_table.TableContainer).forEach(table => {\n      table.balanceCells();\n    });\n  }\n\n  deleteColumn() {\n    var _getTable = this.getTable(),\n        _getTable2 = _slicedToArray(_getTable, 3);\n\n    const table = _getTable2[0],\n          cell = _getTable2[2];\n\n    if (cell == null) return;\n    table.deleteColumn(cell.cellOffset());\n    this.quill.update(_quill2.default.sources.USER);\n  }\n\n  deleteRow() {\n    var _getTable3 = this.getTable(),\n        _getTable4 = _slicedToArray(_getTable3, 2);\n\n    const row = _getTable4[1];\n\n    if (row == null) return;\n    row.remove();\n    this.quill.update(_quill2.default.sources.USER);\n  }\n\n  deleteTable() {\n    var _getTable5 = this.getTable(),\n        _getTable6 = _slicedToArray(_getTable5, 1);\n\n    const table = _getTable6[0];\n\n    if (table == null) return;\n    const offset = table.offset();\n    table.remove();\n    this.quill.update(_quill2.default.sources.USER);\n    this.quill.setSelection(offset, _quill2.default.sources.SILENT);\n  }\n\n  getTable(range = this.quill.getSelection()) {\n    if (range == null) return [null, null, null, -1];\n\n    var _quill$getLine = this.quill.getLine(range.index),\n        _quill$getLine2 = _slicedToArray(_quill$getLine, 2);\n\n    const cell = _quill$getLine2[0],\n          offset = _quill$getLine2[1];\n\n    if (cell == null || cell.statics.blotName !== _table.TableCell.blotName) {\n      return [null, null, null, -1];\n    }\n    const row = cell.parent;\n    const table = row.parent.parent;\n    return [table, row, cell, offset];\n  }\n\n  insertColumn(offset) {\n    const range = this.quill.getSelection();\n\n    var _getTable7 = this.getTable(range),\n        _getTable8 = _slicedToArray(_getTable7, 3);\n\n    const table = _getTable8[0],\n          row = _getTable8[1],\n          cell = _getTable8[2];\n\n    if (cell == null) return;\n    const column = cell.cellOffset();\n    table.insertColumn(column + offset);\n    this.quill.update(_quill2.default.sources.USER);\n    let shift = row.rowOffset();\n    if (offset === 0) {\n      shift += 1;\n    }\n    this.quill.setSelection(range.index + shift, range.length, _quill2.default.sources.SILENT);\n  }\n\n  insertColumnLeft() {\n    this.insertColumn(0);\n  }\n\n  insertColumnRight() {\n    this.insertColumn(1);\n  }\n\n  insertRow(offset) {\n    const range = this.quill.getSelection();\n\n    var _getTable9 = this.getTable(range),\n        _getTable10 = _slicedToArray(_getTable9, 3);\n\n    const table = _getTable10[0],\n          row = _getTable10[1],\n          cell = _getTable10[2];\n\n    if (cell == null) return;\n    const index = row.rowOffset();\n    table.insertRow(index + offset);\n    this.quill.update(_quill2.default.sources.USER);\n    if (offset > 0) {\n      this.quill.setSelection(range, _quill2.default.sources.SILENT);\n    } else {\n      this.quill.setSelection(range.index + row.children.length, range.length, _quill2.default.sources.SILENT);\n    }\n  }\n\n  insertRowAbove() {\n    this.insertRow(0);\n  }\n\n  insertRowBelow() {\n    this.insertRow(1);\n  }\n\n  insertTable(rows, columns) {\n    const range = this.quill.getSelection();\n    if (range == null) return;\n    const delta = new Array(rows).fill(0).reduce(memo => {\n      const text = new Array(columns).fill('\\n').join('');\n      return memo.insert(text, { table: (0, _table.tableId)() });\n    }, new _quillDelta2.default().retain(range.index));\n    this.quill.updateContents(delta, _quill2.default.sources.USER);\n    this.quill.setSelection(range.index, _quill2.default.sources.SILENT);\n    this.balanceTables();\n  }\n\n  listenBalanceCells() {\n    this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, mutations => {\n      mutations.some(mutation => {\n        if (['TD', 'TR', 'TBODY', 'TABLE'].includes(mutation.target.tagName)) {\n          this.quill.once(_quill2.default.events.TEXT_CHANGE, (delta, old, source) => {\n            if (source !== _quill2.default.sources.USER) return;\n            this.balanceTables();\n          });\n          return true;\n        }\n        return false;\n      });\n    });\n  }\n}\n\nexports.default = Table;\n\n//# sourceURL=webpack://Quill/./modules/table.js?");
            /***/
          },

          /***/
          "./modules/toolbar.js":
          /*!****************************!*\
            !*** ./modules/toolbar.js ***!
            \****************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addControls = exports.default = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _quillDelta = __webpack_require__(/*! quill-delta */ \"./node_modules/quill-delta/dist/Delta.js\");\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _parchment = __webpack_require__(/*! parchment */ \"./node_modules/parchment/src/parchment.ts\");\n\nvar _quill = __webpack_require__(/*! ../core/quill */ \"./core/quill.js\");\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nvar _logger = __webpack_require__(/*! ../core/logger */ \"./core/logger.js\");\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _module = __webpack_require__(/*! ../core/module */ \"./core/module.js\");\n\nvar _module2 = _interopRequireDefault(_module);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _logger2.default)('quill:toolbar');\n\nclass Toolbar extends _module2.default {\n  constructor(quill, options) {\n    super(quill, options);\n    if (Array.isArray(this.options.container)) {\n      const container = document.createElement('div');\n      addControls(container, this.options.container);\n      quill.container.parentNode.insertBefore(container, quill.container);\n      this.container = container;\n    } else if (typeof this.options.container === 'string') {\n      this.container = document.querySelector(this.options.container);\n    } else {\n      this.container = this.options.container;\n    }\n    if (!(this.container instanceof HTMLElement)) {\n      return debug.error('Container required for toolbar', this.options);\n    }\n    this.container.classList.add('ql-toolbar');\n    this.controls = [];\n    this.handlers = {};\n    Object.keys(this.options.handlers).forEach(format => {\n      this.addHandler(format, this.options.handlers[format]);\n    });\n    Array.from(this.container.querySelectorAll('button, select')).forEach(input => {\n      this.attach(input);\n    });\n    this.quill.on(_quill2.default.events.EDITOR_CHANGE, (type, range) => {\n      if (type === _quill2.default.events.SELECTION_CHANGE) {\n        this.update(range);\n      }\n    });\n    this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, () => {\n      var _quill$selection$getR = this.quill.selection.getRange(),\n          _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1);\n\n      const range = _quill$selection$getR2[0]; // quill.getSelection triggers update\n\n      this.update(range);\n    });\n  }\n\n  addHandler(format, handler) {\n    this.handlers[format] = handler;\n  }\n\n  attach(input) {\n    let format = Array.from(input.classList).find(className => {\n      return className.indexOf('ql-') === 0;\n    });\n    if (!format) return;\n    format = format.slice('ql-'.length);\n    if (input.tagName === 'BUTTON') {\n      input.setAttribute('type', 'button');\n    }\n    if (this.handlers[format] == null && this.quill.scroll.query(format) == null) {\n      debug.warn('ignoring attaching to nonexistent format', format, input);\n      return;\n    }\n    const eventName = input.tagName === 'SELECT' ? 'change' : 'click';\n    input.addEventListener(eventName, e => {\n      let value;\n      if (input.tagName === 'SELECT') {\n        if (input.selectedIndex < 0) return;\n        const selected = input.options[input.selectedIndex];\n        if (selected.hasAttribute('selected')) {\n          value = false;\n        } else {\n          value = selected.value || false;\n        }\n      } else {\n        if (input.classList.contains('ql-active')) {\n          value = false;\n        } else {\n          value = input.value || !input.hasAttribute('value');\n        }\n        e.preventDefault();\n      }\n      this.quill.focus();\n\n      var _quill$selection$getR3 = this.quill.selection.getRange(),\n          _quill$selection$getR4 = _slicedToArray(_quill$selection$getR3, 1);\n\n      const range = _quill$selection$getR4[0];\n\n      if (this.handlers[format] != null) {\n        this.handlers[format].call(this, value);\n      } else if (this.quill.scroll.query(format).prototype instanceof _parchment.EmbedBlot) {\n        value = prompt(`Enter ${format}`); // eslint-disable-line no-alert\n        if (!value) return;\n        this.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({ [format]: value }), _quill2.default.sources.USER);\n      } else {\n        this.quill.format(format, value, _quill2.default.sources.USER);\n      }\n      this.update(range);\n    });\n    this.controls.push([format, input]);\n  }\n\n  update(range) {\n    const formats = range == null ? {} : this.quill.getFormat(range);\n    this.controls.forEach(pair => {\n      var _pair = _slicedToArray(pair, 2);\n\n      const format = _pair[0],\n            input = _pair[1];\n\n      if (input.tagName === 'SELECT') {\n        let option;\n        if (range == null) {\n          option = null;\n        } else if (formats[format] == null) {\n          option = input.querySelector('option[selected]');\n        } else if (!Array.isArray(formats[format])) {\n          let value = formats[format];\n          if (typeof value === 'string') {\n            value = value.replace(/\"/g, '\\\\\"');\n          }\n          option = input.querySelector(`option[value=\"${value}\"]`);\n        }\n        if (option == null) {\n          input.value = ''; // TODO make configurable?\n          input.selectedIndex = -1;\n        } else {\n          option.selected = true;\n        }\n      } else if (range == null) {\n        input.classList.remove('ql-active');\n      } else if (input.hasAttribute('value')) {\n        // both being null should match (default values)\n        // '1' should match with 1 (headers)\n        const isActive = formats[format] === input.getAttribute('value') || formats[format] != null && formats[format].toString() === input.getAttribute('value') || formats[format] == null && !input.getAttribute('value');\n        input.classList.toggle('ql-active', isActive);\n      } else {\n        input.classList.toggle('ql-active', formats[format] != null);\n      }\n    });\n  }\n}\nToolbar.DEFAULTS = {};\n\nfunction addButton(container, format, value) {\n  const input = document.createElement('button');\n  input.setAttribute('type', 'button');\n  input.classList.add(`ql-${format}`);\n  if (value != null) {\n    input.value = value;\n  }\n  container.appendChild(input);\n}\n\nfunction addControls(container, groups) {\n  if (!Array.isArray(groups[0])) {\n    groups = [groups];\n  }\n  groups.forEach(controls => {\n    const group = document.createElement('span');\n    group.classList.add('ql-formats');\n    controls.forEach(control => {\n      if (typeof control === 'string') {\n        addButton(group, control);\n      } else {\n        const format = Object.keys(control)[0];\n        const value = control[format];\n        if (Array.isArray(value)) {\n          addSelect(group, format, value);\n        } else {\n          addButton(group, format, value);\n        }\n      }\n    });\n    container.appendChild(group);\n  });\n}\n\nfunction addSelect(container, format, values) {\n  const input = document.createElement('select');\n  input.classList.add(`ql-${format}`);\n  values.forEach(value => {\n    const option = document.createElement('option');\n    if (value !== false) {\n      option.setAttribute('value', value);\n    } else {\n      option.setAttribute('selected', 'selected');\n    }\n    input.appendChild(option);\n  });\n  container.appendChild(input);\n}\n\nToolbar.DEFAULTS = {\n  container: null,\n  handlers: {\n    clean() {\n      const range = this.quill.getSelection();\n      if (range == null) return;\n      if (range.length === 0) {\n        const formats = this.quill.getFormat();\n        Object.keys(formats).forEach(name => {\n          // Clean functionality in existing apps only clean inline formats\n          if (this.quill.scroll.query(name, _parchment.Scope.INLINE) != null) {\n            this.quill.format(name, false, _quill2.default.sources.USER);\n          }\n        });\n      } else {\n        this.quill.removeFormat(range, _quill2.default.sources.USER);\n      }\n    },\n    direction(value) {\n      var _quill$getFormat = this.quill.getFormat();\n\n      const align = _quill$getFormat.align;\n\n      if (value === 'rtl' && align == null) {\n        this.quill.format('align', 'right', _quill2.default.sources.USER);\n      } else if (!value && align === 'right') {\n        this.quill.format('align', false, _quill2.default.sources.USER);\n      }\n      this.quill.format('direction', value, _quill2.default.sources.USER);\n    },\n    indent(value) {\n      const range = this.quill.getSelection();\n      const formats = this.quill.getFormat(range);\n      const indent = parseInt(formats.indent || 0, 10);\n      if (value === '+1' || value === '-1') {\n        let modifier = value === '+1' ? 1 : -1;\n        if (formats.direction === 'rtl') modifier *= -1;\n        this.quill.format('indent', indent + modifier, _quill2.default.sources.USER);\n      }\n    },\n    link(value) {\n      if (value === true) {\n        value = prompt('Enter link URL:'); // eslint-disable-line no-alert\n      }\n      this.quill.format('link', value, _quill2.default.sources.USER);\n    },\n    list(value) {\n      const range = this.quill.getSelection();\n      const formats = this.quill.getFormat(range);\n      if (value === 'check') {\n        if (formats.list === 'checked' || formats.list === 'unchecked') {\n          this.quill.format('list', false, _quill2.default.sources.USER);\n        } else {\n          this.quill.format('list', 'unchecked', _quill2.default.sources.USER);\n        }\n      } else {\n        this.quill.format('list', value, _quill2.default.sources.USER);\n      }\n    }\n  }\n};\n\nexports.default = Toolbar;\nexports.addControls = addControls;\n\n//# sourceURL=webpack://Quill/./modules/toolbar.js?");
            /***/
          },

          /***/
          "./modules/uploader.js":
          /*!*****************************!*\
            !*** ./modules/uploader.js ***!
            \*****************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _quillDelta = __webpack_require__(/*! quill-delta */ \"./node_modules/quill-delta/dist/Delta.js\");\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _emitter = __webpack_require__(/*! ../core/emitter */ \"./core/emitter.js\");\n\nvar _emitter2 = _interopRequireDefault(_emitter);\n\nvar _module = __webpack_require__(/*! ../core/module */ \"./core/module.js\");\n\nvar _module2 = _interopRequireDefault(_module);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Uploader extends _module2.default {\n  constructor(quill, options) {\n    super(quill, options);\n    quill.root.addEventListener('drop', e => {\n      e.preventDefault();\n      let native;\n      if (document.caretRangeFromPoint) {\n        native = document.caretRangeFromPoint(e.clientX, e.clientY);\n      } else if (document.caretPositionFromPoint) {\n        const position = document.caretPositionFromPoint(e.clientX, e.clientY);\n        native = document.createRange();\n        native.setStart(position.offsetNode, position.offset);\n        native.setEnd(position.offsetNode, position.offset);\n      } else {\n        return;\n      }\n      const normalized = quill.selection.normalizeNative(native);\n      const range = quill.selection.normalizedToRange(normalized);\n      this.upload(range, e.dataTransfer.files);\n    });\n  }\n\n  upload(range, files) {\n    const uploads = [];\n    Array.from(files).forEach(file => {\n      if (file && this.options.mimetypes.includes(file.type)) {\n        uploads.push(file);\n      }\n    });\n    if (uploads.length > 0) {\n      this.options.handler.call(this, range, uploads);\n    }\n  }\n}\n\nUploader.DEFAULTS = {\n  mimetypes: ['image/png', 'image/jpeg'],\n  handler(range, files) {\n    const promises = files.map(file => {\n      return new Promise(resolve => {\n        const reader = new FileReader();\n        reader.onload = e => {\n          resolve(e.target.result);\n        };\n        reader.readAsDataURL(file);\n      });\n    });\n    Promise.all(promises).then(images => {\n      const update = images.reduce((delta, image) => {\n        return delta.insert({ image });\n      }, new _quillDelta2.default().retain(range.index).delete(range.length));\n      this.quill.updateContents(update, _emitter2.default.sources.USER);\n      this.quill.setSelection(range.index + images.length, _emitter2.default.sources.SILENT);\n    });\n  }\n};\n\nexports.default = Uploader;\n\n//# sourceURL=webpack://Quill/./modules/uploader.js?");
            /***/
          },

          /***/
          "./node_modules/clone/clone.js":
          /*!*************************************!*\
            !*** ./node_modules/clone/clone.js ***!
            \*************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("var clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n\n\n//# sourceURL=webpack://Quill/./node_modules/clone/clone.js?");
            /***/
          },

          /***/
          "./node_modules/deep-equal/index.js":
          /*!******************************************!*\
            !*** ./node_modules/deep-equal/index.js ***!
            \******************************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {
            eval("var pSlice = Array.prototype.slice;\nvar objectKeys = __webpack_require__(/*! ./lib/keys.js */ \"./node_modules/deep-equal/lib/keys.js\");\nvar isArguments = __webpack_require__(/*! ./lib/is_arguments.js */ \"./node_modules/deep-equal/lib/is_arguments.js\");\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n\n\n//# sourceURL=webpack://Quill/./node_modules/deep-equal/index.js?");
            /***/
          },

          /***/
          "./node_modules/deep-equal/lib/is_arguments.js":
          /*!*****************************************************!*\
            !*** ./node_modules/deep-equal/lib/is_arguments.js ***!
            \*****************************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n\n\n//# sourceURL=webpack://Quill/./node_modules/deep-equal/lib/is_arguments.js?");
            /***/
          },

          /***/
          "./node_modules/deep-equal/lib/keys.js":
          /*!*********************************************!*\
            !*** ./node_modules/deep-equal/lib/keys.js ***!
            \*********************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n\n\n//# sourceURL=webpack://Quill/./node_modules/deep-equal/lib/keys.js?");
            /***/
          },

          /***/
          "./node_modules/eventemitter3/index.js":
          /*!*********************************************!*\
            !*** ./node_modules/eventemitter3/index.js ***!
            \*********************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://Quill/./node_modules/eventemitter3/index.js?");
            /***/
          },

          /***/
          "./node_modules/extend/index.js":
          /*!**************************************!*\
            !*** ./node_modules/extend/index.js ***!
            \**************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n//# sourceURL=webpack://Quill/./node_modules/extend/index.js?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/attributor/attributor.ts":
          /*!*************************************************************!*\
            !*** ./node_modules/parchment/src/attributor/attributor.ts ***!
            \*************************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Attributor; });\n/* harmony import */ var _scope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scope */ \"./node_modules/parchment/src/scope.ts\");\n\nclass Attributor {\n    static keys(node) {\n        return Array.from(node.attributes).map((item) => item.name);\n    }\n    constructor(attrName, keyName, options = {}) {\n        this.attrName = attrName;\n        this.keyName = keyName;\n        const attributeBit = _scope__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TYPE & _scope__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ATTRIBUTE;\n        this.scope =\n            options.scope != null\n                ? // Ignore type bits, force attribute bit\n                    (options.scope & _scope__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEVEL) | attributeBit\n                : _scope__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ATTRIBUTE;\n        if (options.whitelist != null) {\n            this.whitelist = options.whitelist;\n        }\n    }\n    add(node, value) {\n        if (!this.canAdd(node, value)) {\n            return false;\n        }\n        node.setAttribute(this.keyName, value);\n        return true;\n    }\n    canAdd(_node, value) {\n        if (this.whitelist == null) {\n            return true;\n        }\n        if (typeof value === 'string') {\n            return this.whitelist.indexOf(value.replace(/[\"']/g, '')) > -1;\n        }\n        else {\n            return this.whitelist.indexOf(value) > -1;\n        }\n    }\n    remove(node) {\n        node.removeAttribute(this.keyName);\n    }\n    value(node) {\n        const value = node.getAttribute(this.keyName);\n        if (this.canAdd(node, value) && value) {\n            return value;\n        }\n        return '';\n    }\n}\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/attributor/attributor.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/attributor/class.ts":
          /*!********************************************************!*\
            !*** ./node_modules/parchment/src/attributor/class.ts ***!
            \********************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _attributor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attributor */ \"./node_modules/parchment/src/attributor/attributor.ts\");\n\nfunction match(node, prefix) {\n    const className = node.getAttribute('class') || '';\n    return className\n        .split(/\\s+/)\n        .filter(name => name.indexOf(`${prefix}-`) === 0);\n}\nclass ClassAttributor extends _attributor__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    static keys(node) {\n        return (node.getAttribute('class') || '').split(/\\s+/).map(name => name\n            .split('-')\n            .slice(0, -1)\n            .join('-'));\n    }\n    add(node, value) {\n        if (!this.canAdd(node, value)) {\n            return false;\n        }\n        this.remove(node);\n        node.classList.add(`${this.keyName}-${value}`);\n        return true;\n    }\n    remove(node) {\n        const matches = match(node, this.keyName);\n        matches.forEach(name => {\n            node.classList.remove(name);\n        });\n        if (node.classList.length === 0) {\n            node.removeAttribute('class');\n        }\n    }\n    value(node) {\n        const result = match(node, this.keyName)[0] || '';\n        const value = result.slice(this.keyName.length + 1); // +1 for hyphen\n        return this.canAdd(node, value) ? value : '';\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (ClassAttributor);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/attributor/class.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/attributor/store.ts":
          /*!********************************************************!*\
            !*** ./node_modules/parchment/src/attributor/store.ts ***!
            \********************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ \"./node_modules/parchment/src/registry.ts\");\n/* harmony import */ var _scope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scope */ \"./node_modules/parchment/src/scope.ts\");\n/* harmony import */ var _attributor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attributor */ \"./node_modules/parchment/src/attributor/attributor.ts\");\n/* harmony import */ var _class__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./class */ \"./node_modules/parchment/src/attributor/class.ts\");\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./style */ \"./node_modules/parchment/src/attributor/style.ts\");\n\n\n\n\n\nclass AttributorStore {\n    constructor(domNode) {\n        this.attributes = {};\n        this.domNode = domNode;\n        this.build();\n    }\n    attribute(attribute, value) {\n        // verb\n        if (value) {\n            if (attribute.add(this.domNode, value)) {\n                if (attribute.value(this.domNode) != null) {\n                    this.attributes[attribute.attrName] = attribute;\n                }\n                else {\n                    delete this.attributes[attribute.attrName];\n                }\n            }\n        }\n        else {\n            attribute.remove(this.domNode);\n            delete this.attributes[attribute.attrName];\n        }\n    }\n    build() {\n        this.attributes = {};\n        const blot = _registry__WEBPACK_IMPORTED_MODULE_0__[\"default\"].find(this.domNode);\n        if (blot == null) {\n            return;\n        }\n        const attributes = _attributor__WEBPACK_IMPORTED_MODULE_2__[\"default\"].keys(this.domNode);\n        const classes = _class__WEBPACK_IMPORTED_MODULE_3__[\"default\"].keys(this.domNode);\n        const styles = _style__WEBPACK_IMPORTED_MODULE_4__[\"default\"].keys(this.domNode);\n        attributes\n            .concat(classes)\n            .concat(styles)\n            .forEach(name => {\n            const attr = blot.scroll.query(name, _scope__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ATTRIBUTE);\n            if (attr instanceof _attributor__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) {\n                this.attributes[attr.attrName] = attr;\n            }\n        });\n    }\n    copy(target) {\n        Object.keys(this.attributes).forEach(key => {\n            const value = this.attributes[key].value(this.domNode);\n            target.format(key, value);\n        });\n    }\n    move(target) {\n        this.copy(target);\n        Object.keys(this.attributes).forEach(key => {\n            this.attributes[key].remove(this.domNode);\n        });\n        this.attributes = {};\n    }\n    values() {\n        return Object.keys(this.attributes).reduce((attributes, name) => {\n            attributes[name] = this.attributes[name].value(this.domNode);\n            return attributes;\n        }, {});\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (AttributorStore);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/attributor/store.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/attributor/style.ts":
          /*!********************************************************!*\
            !*** ./node_modules/parchment/src/attributor/style.ts ***!
            \********************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _attributor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attributor */ \"./node_modules/parchment/src/attributor/attributor.ts\");\n\nfunction camelize(name) {\n    const parts = name.split('-');\n    const rest = parts\n        .slice(1)\n        .map((part) => part[0].toUpperCase() + part.slice(1))\n        .join('');\n    return parts[0] + rest;\n}\nclass StyleAttributor extends _attributor__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    static keys(node) {\n        return (node.getAttribute('style') || '').split(';').map(value => {\n            const arr = value.split(':');\n            return arr[0].trim();\n        });\n    }\n    add(node, value) {\n        if (!this.canAdd(node, value)) {\n            return false;\n        }\n        // @ts-ignore\n        node.style[camelize(this.keyName)] = value;\n        return true;\n    }\n    remove(node) {\n        // @ts-ignore\n        node.style[camelize(this.keyName)] = '';\n        if (!node.getAttribute('style')) {\n            node.removeAttribute('style');\n        }\n    }\n    value(node) {\n        // @ts-ignore\n        const value = node.style[camelize(this.keyName)];\n        return this.canAdd(node, value) ? value : '';\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (StyleAttributor);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/attributor/style.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/blot/abstract/container.ts":
          /*!***************************************************************!*\
            !*** ./node_modules/parchment/src/blot/abstract/container.ts ***!
            \***************************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../scope */ \"./node_modules/parchment/src/scope.ts\");\n/* harmony import */ var _parent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parent */ \"./node_modules/parchment/src/blot/abstract/parent.ts\");\n\n\nclass ContainerBlot extends _parent__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    checkMerge() {\n        return (this.next !== null && this.next.statics.blotName === this.statics.blotName);\n    }\n    deleteAt(index, length) {\n        super.deleteAt(index, length);\n        this.enforceAllowedChildren();\n    }\n    formatAt(index, length, name, value) {\n        super.formatAt(index, length, name, value);\n        this.enforceAllowedChildren();\n    }\n    insertAt(index, value, def) {\n        super.insertAt(index, value, def);\n        this.enforceAllowedChildren();\n    }\n    optimize(context) {\n        super.optimize(context);\n        if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n            this.next.moveChildren(this);\n            this.next.remove();\n        }\n    }\n}\nContainerBlot.blotName = 'container';\nContainerBlot.scope = _scope__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_BLOT;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ContainerBlot);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/blot/abstract/container.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/blot/abstract/leaf.ts":
          /*!**********************************************************!*\
            !*** ./node_modules/parchment/src/blot/abstract/leaf.ts ***!
            \**********************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../scope */ \"./node_modules/parchment/src/scope.ts\");\n/* harmony import */ var _shadow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shadow */ \"./node_modules/parchment/src/blot/abstract/shadow.ts\");\n\n\nclass LeafBlot extends _shadow__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    static value(_domNode) {\n        return true;\n    }\n    index(node, offset) {\n        if (this.domNode === node ||\n            this.domNode.compareDocumentPosition(node) &\n                Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            return Math.min(offset, 1);\n        }\n        return -1;\n    }\n    position(index, _inclusive) {\n        const childNodes = Array.from(this.parent.domNode.childNodes);\n        let offset = childNodes.indexOf(this.domNode);\n        if (index > 0) {\n            offset += 1;\n        }\n        return [this.parent.domNode, offset];\n    }\n    value() {\n        return {\n            [this.statics.blotName]: this.statics.value(this.domNode) || true,\n        };\n    }\n}\nLeafBlot.scope = _scope__WEBPACK_IMPORTED_MODULE_0__[\"default\"].INLINE_BLOT;\n/* harmony default export */ __webpack_exports__[\"default\"] = (LeafBlot);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/blot/abstract/leaf.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/blot/abstract/parent.ts":
          /*!************************************************************!*\
            !*** ./node_modules/parchment/src/blot/abstract/parent.ts ***!
            \************************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _collection_linked_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../collection/linked-list */ \"./node_modules/parchment/src/collection/linked-list.ts\");\n/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../error */ \"./node_modules/parchment/src/error.ts\");\n/* harmony import */ var _scope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scope */ \"./node_modules/parchment/src/scope.ts\");\n/* harmony import */ var _shadow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shadow */ \"./node_modules/parchment/src/blot/abstract/shadow.ts\");\n\n\n\n\nclass ParentBlot extends _shadow__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n    constructor(scroll, domNode) {\n        super(scroll, domNode);\n        this.uiNode = null;\n        this.build();\n    }\n    appendChild(other) {\n        this.insertBefore(other);\n    }\n    attach() {\n        super.attach();\n        this.children.forEach(child => {\n            child.attach();\n        });\n    }\n    attachUI(node) {\n        if (this.uiNode != null) {\n            this.uiNode.remove();\n        }\n        this.uiNode = node;\n        if (ParentBlot.uiClass) {\n            this.uiNode.classList.add(ParentBlot.uiClass);\n        }\n        this.uiNode.setAttribute('contenteditable', 'false');\n        this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n    build() {\n        this.children = new _collection_linked_list__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        // Need to be reversed for if DOM nodes already in order\n        Array.from(this.domNode.childNodes)\n            .filter((node) => node !== this.uiNode)\n            .reverse()\n            .forEach((node) => {\n            try {\n                const child = makeAttachedBlot(node, this.scroll);\n                this.insertBefore(child, this.children.head || undefined);\n            }\n            catch (err) {\n                if (err instanceof _error__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n                    return;\n                }\n                else {\n                    throw err;\n                }\n            }\n        });\n    }\n    deleteAt(index, length) {\n        if (index === 0 && length === this.length()) {\n            return this.remove();\n        }\n        this.children.forEachAt(index, length, (child, offset, childLength) => {\n            child.deleteAt(offset, childLength);\n        });\n    }\n    descendant(criteria, index = 0) {\n        const [child, offset] = this.children.find(index);\n        if ((criteria.blotName == null && criteria(child)) ||\n            (criteria.blotName != null && child instanceof criteria)) {\n            return [child, offset];\n        }\n        else if (child instanceof ParentBlot) {\n            return child.descendant(criteria, offset);\n        }\n        else {\n            return [null, -1];\n        }\n    }\n    descendants(criteria, index = 0, length = Number.MAX_VALUE) {\n        let descendants = [];\n        let lengthLeft = length;\n        this.children.forEachAt(index, length, (child, childIndex, childLength) => {\n            if ((criteria.blotName == null && criteria(child)) ||\n                (criteria.blotName != null && child instanceof criteria)) {\n                descendants.push(child);\n            }\n            if (child instanceof ParentBlot) {\n                descendants = descendants.concat(child.descendants(criteria, childIndex, lengthLeft));\n            }\n            lengthLeft -= childLength;\n        });\n        return descendants;\n    }\n    detach() {\n        this.children.forEach(child => {\n            child.detach();\n        });\n        super.detach();\n    }\n    enforceAllowedChildren() {\n        let done = false;\n        this.children.forEach((child) => {\n            if (done) {\n                return;\n            }\n            const allowed = this.statics.allowedChildren.some((def) => child instanceof def);\n            if (allowed) {\n                return;\n            }\n            if (child.statics.scope === _scope__WEBPACK_IMPORTED_MODULE_2__[\"default\"].BLOCK_BLOT) {\n                if (child.next != null) {\n                    this.splitAfter(child);\n                }\n                if (child.prev != null) {\n                    this.splitAfter(child.prev);\n                }\n                child.parent.unwrap();\n                done = true;\n            }\n            else if (child instanceof ParentBlot) {\n                child.unwrap();\n            }\n            else {\n                child.remove();\n            }\n        });\n    }\n    formatAt(index, length, name, value) {\n        this.children.forEachAt(index, length, (child, offset, childLength) => {\n            child.formatAt(offset, childLength, name, value);\n        });\n    }\n    insertAt(index, value, def) {\n        const [child, offset] = this.children.find(index);\n        if (child) {\n            child.insertAt(offset, value, def);\n        }\n        else {\n            const blot = def == null\n                ? this.scroll.create('text', value)\n                : this.scroll.create(value, def);\n            this.appendChild(blot);\n        }\n    }\n    insertBefore(childBlot, refBlot) {\n        if (childBlot.parent != null) {\n            childBlot.parent.children.remove(childBlot);\n        }\n        let refDomNode = null;\n        this.children.insertBefore(childBlot, refBlot || null);\n        if (refBlot != null) {\n            refDomNode = refBlot.domNode;\n        }\n        if (this.domNode.parentNode !== childBlot.domNode ||\n            this.domNode.nextSibling !== refDomNode) {\n            this.domNode.insertBefore(childBlot.domNode, refDomNode);\n        }\n        childBlot.parent = this;\n        childBlot.attach();\n    }\n    length() {\n        return this.children.reduce((memo, child) => {\n            return memo + child.length();\n        }, 0);\n    }\n    moveChildren(targetParent, refNode) {\n        this.children.forEach(child => {\n            targetParent.insertBefore(child, refNode);\n        });\n    }\n    optimize(context) {\n        super.optimize(context);\n        this.enforceAllowedChildren();\n        if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {\n            this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n        }\n        if (this.children.length === 0) {\n            if (this.statics.defaultChild != null) {\n                const child = this.scroll.create(this.statics.defaultChild.blotName);\n                this.appendChild(child);\n                // TODO double check if necessary\n                // child.optimize(context);\n            }\n            else {\n                this.remove();\n            }\n        }\n    }\n    path(index, inclusive = false) {\n        const [child, offset] = this.children.find(index, inclusive);\n        const position = [[this, index]];\n        if (child instanceof ParentBlot) {\n            return position.concat(child.path(offset, inclusive));\n        }\n        else if (child != null) {\n            position.push([child, offset]);\n        }\n        return position;\n    }\n    removeChild(child) {\n        this.children.remove(child);\n    }\n    replaceWith(name, value) {\n        const replacement = typeof name === 'string' ? this.scroll.create(name, value) : name;\n        if (replacement instanceof ParentBlot) {\n            this.moveChildren(replacement);\n        }\n        return super.replaceWith(replacement);\n    }\n    split(index, force = false) {\n        if (!force) {\n            if (index === 0) {\n                return this;\n            }\n            if (index === this.length()) {\n                return this.next;\n            }\n        }\n        const after = this.clone();\n        if (this.parent) {\n            this.parent.insertBefore(after, this.next || undefined);\n        }\n        this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n            const split = child.split(offset, force);\n            if (split != null) {\n                after.appendChild(split);\n            }\n        });\n        return after;\n    }\n    splitAfter(child) {\n        const after = this.clone();\n        while (child.next != null) {\n            after.appendChild(child.next);\n        }\n        if (this.parent) {\n            this.parent.insertBefore(after, this.next || undefined);\n        }\n        return after;\n    }\n    unwrap() {\n        if (this.parent) {\n            this.moveChildren(this.parent, this.next || undefined);\n        }\n        this.remove();\n    }\n    update(mutations, _context) {\n        const addedNodes = [];\n        const removedNodes = [];\n        mutations.forEach(mutation => {\n            if (mutation.target === this.domNode && mutation.type === 'childList') {\n                addedNodes.push.apply(addedNodes, mutation.addedNodes);\n                removedNodes.push.apply(removedNodes, mutation.removedNodes);\n            }\n        });\n        removedNodes.forEach((node) => {\n            // Check node has actually been removed\n            // One exception is Chrome does not immediately remove IFRAMEs\n            // from DOM but MutationRecord is correct in its reported removal\n            if (node.parentNode != null &&\n                // @ts-ignore\n                node.tagName !== 'IFRAME' &&\n                document.body.compareDocumentPosition(node) &\n                    Node.DOCUMENT_POSITION_CONTAINED_BY) {\n                return;\n            }\n            const blot = this.scroll.find(node);\n            if (blot == null) {\n                return;\n            }\n            if (blot.domNode.parentNode == null ||\n                blot.domNode.parentNode === this.domNode) {\n                blot.detach();\n            }\n        });\n        addedNodes\n            .filter(node => {\n            return node.parentNode === this.domNode || node === this.uiNode;\n        })\n            .sort((a, b) => {\n            if (a === b) {\n                return 0;\n            }\n            if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n                return 1;\n            }\n            return -1;\n        })\n            .forEach(node => {\n            let refBlot = null;\n            if (node.nextSibling != null) {\n                refBlot = this.scroll.find(node.nextSibling);\n            }\n            const blot = makeAttachedBlot(node, this.scroll);\n            if (blot.next !== refBlot || blot.next == null) {\n                if (blot.parent != null) {\n                    blot.parent.removeChild(this);\n                }\n                this.insertBefore(blot, refBlot || undefined);\n            }\n        });\n        this.enforceAllowedChildren();\n    }\n}\nParentBlot.uiClass = '';\nfunction makeAttachedBlot(node, scroll) {\n    let blot = scroll.find(node);\n    if (blot == null) {\n        try {\n            blot = scroll.create(node);\n        }\n        catch (e) {\n            blot = scroll.create(_scope__WEBPACK_IMPORTED_MODULE_2__[\"default\"].INLINE);\n            Array.from(node.childNodes).forEach((child) => {\n                // @ts-ignore\n                blot.domNode.appendChild(child);\n            });\n            if (node.parentNode) {\n                node.parentNode.replaceChild(blot.domNode, node);\n            }\n            blot.attach();\n        }\n    }\n    return blot;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (ParentBlot);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/blot/abstract/parent.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/blot/abstract/shadow.ts":
          /*!************************************************************!*\
            !*** ./node_modules/parchment/src/blot/abstract/shadow.ts ***!
            \************************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../error */ \"./node_modules/parchment/src/error.ts\");\n/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../registry */ \"./node_modules/parchment/src/registry.ts\");\n/* harmony import */ var _scope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scope */ \"./node_modules/parchment/src/scope.ts\");\n\n\n\nclass ShadowBlot {\n    constructor(scroll, domNode) {\n        this.scroll = scroll;\n        this.domNode = domNode;\n        _registry__WEBPACK_IMPORTED_MODULE_1__[\"default\"].blots.set(domNode, this);\n        this.prev = null;\n        this.next = null;\n    }\n    static create(value) {\n        if (this.tagName == null) {\n            throw new _error__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('Blot definition missing tagName');\n        }\n        let node;\n        if (Array.isArray(this.tagName)) {\n            if (typeof value === 'string') {\n                value = value.toUpperCase();\n                if (parseInt(value, 10).toString() === value) {\n                    value = parseInt(value, 10);\n                }\n            }\n            if (typeof value === 'number') {\n                node = document.createElement(this.tagName[value - 1]);\n            }\n            else if (this.tagName.indexOf(value) > -1) {\n                node = document.createElement(value);\n            }\n            else {\n                node = document.createElement(this.tagName[0]);\n            }\n        }\n        else {\n            node = document.createElement(this.tagName);\n        }\n        if (this.className) {\n            node.classList.add(this.className);\n        }\n        return node;\n    }\n    // Hack for accessing inherited static methods\n    get statics() {\n        return this.constructor;\n    }\n    attach() {\n        // Nothing to do\n    }\n    clone() {\n        const domNode = this.domNode.cloneNode(false);\n        return this.scroll.create(domNode);\n    }\n    detach() {\n        if (this.parent != null) {\n            this.parent.removeChild(this);\n        }\n        _registry__WEBPACK_IMPORTED_MODULE_1__[\"default\"].blots.delete(this.domNode);\n    }\n    deleteAt(index, length) {\n        const blot = this.isolate(index, length);\n        blot.remove();\n    }\n    formatAt(index, length, name, value) {\n        const blot = this.isolate(index, length);\n        if (this.scroll.query(name, _scope__WEBPACK_IMPORTED_MODULE_2__[\"default\"].BLOT) != null && value) {\n            blot.wrap(name, value);\n        }\n        else if (this.scroll.query(name, _scope__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ATTRIBUTE) != null) {\n            const parent = this.scroll.create(this.statics.scope);\n            blot.wrap(parent);\n            parent.format(name, value);\n        }\n    }\n    insertAt(index, value, def) {\n        const blot = def == null\n            ? this.scroll.create('text', value)\n            : this.scroll.create(value, def);\n        const ref = this.split(index);\n        this.parent.insertBefore(blot, ref || undefined);\n    }\n    isolate(index, length) {\n        const target = this.split(index);\n        if (target == null) {\n            throw new Error('Attempt to isolate at end');\n        }\n        target.split(length);\n        return target;\n    }\n    length() {\n        return 1;\n    }\n    offset(root = this.parent) {\n        if (this.parent == null || this === root) {\n            return 0;\n        }\n        return this.parent.children.offset(this) + this.parent.offset(root);\n    }\n    optimize(_context) {\n        if (this.statics.requiredContainer &&\n            !(this.parent instanceof this.statics.requiredContainer)) {\n            this.wrap(this.statics.requiredContainer.blotName);\n        }\n    }\n    remove() {\n        if (this.domNode.parentNode != null) {\n            this.domNode.parentNode.removeChild(this.domNode);\n        }\n        this.detach();\n    }\n    replaceWith(name, value) {\n        const replacement = typeof name === 'string' ? this.scroll.create(name, value) : name;\n        if (this.parent != null) {\n            this.parent.insertBefore(replacement, this.next || undefined);\n            this.remove();\n        }\n        return replacement;\n    }\n    split(index, _force) {\n        return index === 0 ? this : this.next;\n    }\n    update(_mutations, _context) {\n        // Nothing to do by default\n    }\n    wrap(name, value) {\n        const wrapper = typeof name === 'string'\n            ? this.scroll.create(name, value)\n            : name;\n        if (this.parent != null) {\n            this.parent.insertBefore(wrapper, this.next || undefined);\n        }\n        if (typeof wrapper.appendChild !== 'function') {\n            throw new _error__WEBPACK_IMPORTED_MODULE_0__[\"default\"](`Cannot wrap ${name}`);\n        }\n        wrapper.appendChild(this);\n        return wrapper;\n    }\n}\nShadowBlot.blotName = 'abstract';\n/* harmony default export */ __webpack_exports__[\"default\"] = (ShadowBlot);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/blot/abstract/shadow.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/blot/block.ts":
          /*!**************************************************!*\
            !*** ./node_modules/parchment/src/blot/block.ts ***!
            \**************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _attributor_attributor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../attributor/attributor */ \"./node_modules/parchment/src/attributor/attributor.ts\");\n/* harmony import */ var _attributor_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../attributor/store */ \"./node_modules/parchment/src/attributor/store.ts\");\n/* harmony import */ var _scope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../scope */ \"./node_modules/parchment/src/scope.ts\");\n/* harmony import */ var _abstract_leaf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/leaf */ \"./node_modules/parchment/src/blot/abstract/leaf.ts\");\n/* harmony import */ var _abstract_parent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/parent */ \"./node_modules/parchment/src/blot/abstract/parent.ts\");\n/* harmony import */ var _inline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./inline */ \"./node_modules/parchment/src/blot/inline.ts\");\n\n\n\n\n\n\nclass BlockBlot extends _abstract_parent__WEBPACK_IMPORTED_MODULE_4__[\"default\"] {\n    constructor(scroll, domNode) {\n        super(scroll, domNode);\n        this.attributes = new _attributor_store__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.domNode);\n    }\n    static formats(domNode, scroll) {\n        const match = scroll.query(BlockBlot.blotName);\n        if (match != null &&\n            domNode.tagName === match.tagName) {\n            return undefined;\n        }\n        else if (typeof this.tagName === 'string') {\n            return true;\n        }\n        else if (Array.isArray(this.tagName)) {\n            return domNode.tagName.toLowerCase();\n        }\n    }\n    format(name, value) {\n        const format = this.scroll.query(name, _scope__WEBPACK_IMPORTED_MODULE_2__[\"default\"].BLOCK);\n        if (format == null) {\n            return;\n        }\n        else if (format instanceof _attributor_attributor__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n            this.attributes.attribute(format, value);\n        }\n        else if (name === this.statics.blotName && !value) {\n            this.replaceWith(BlockBlot.blotName);\n        }\n        else if (value &&\n            (name !== this.statics.blotName || this.formats()[name] !== value)) {\n            this.replaceWith(name, value);\n        }\n    }\n    formats() {\n        const formats = this.attributes.values();\n        const format = this.statics.formats(this.domNode, this.scroll);\n        if (format != null) {\n            formats[this.statics.blotName] = format;\n        }\n        return formats;\n    }\n    formatAt(index, length, name, value) {\n        if (this.scroll.query(name, _scope__WEBPACK_IMPORTED_MODULE_2__[\"default\"].BLOCK) != null) {\n            this.format(name, value);\n        }\n        else {\n            super.formatAt(index, length, name, value);\n        }\n    }\n    insertAt(index, value, def) {\n        if (def == null || this.scroll.query(value, _scope__WEBPACK_IMPORTED_MODULE_2__[\"default\"].INLINE) != null) {\n            // Insert text or inline\n            super.insertAt(index, value, def);\n        }\n        else {\n            const after = this.split(index);\n            if (after != null) {\n                const blot = this.scroll.create(value, def);\n                after.parent.insertBefore(blot, after);\n            }\n            else {\n                throw new Error('Attempt to insertAt after block boundaries');\n            }\n        }\n    }\n    replaceWith(name, value) {\n        const replacement = super.replaceWith(name, value);\n        this.attributes.copy(replacement);\n        return replacement;\n    }\n    update(mutations, context) {\n        super.update(mutations, context);\n        const attributeChanged = mutations.some(mutation => mutation.target === this.domNode && mutation.type === 'attributes');\n        if (attributeChanged) {\n            this.attributes.build();\n        }\n    }\n}\nBlockBlot.blotName = 'block';\nBlockBlot.scope = _scope__WEBPACK_IMPORTED_MODULE_2__[\"default\"].BLOCK_BLOT;\nBlockBlot.tagName = 'P';\nBlockBlot.allowedChildren = [\n    _inline__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n    BlockBlot,\n    _abstract_leaf__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n];\n/* harmony default export */ __webpack_exports__[\"default\"] = (BlockBlot);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/blot/block.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/blot/embed.ts":
          /*!**************************************************!*\
            !*** ./node_modules/parchment/src/blot/embed.ts ***!
            \**************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _abstract_leaf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/leaf */ \"./node_modules/parchment/src/blot/abstract/leaf.ts\");\n\nclass EmbedBlot extends _abstract_leaf__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    static formats(_domNode, _scroll) {\n        return undefined;\n    }\n    format(name, value) {\n        // super.formatAt wraps, which is what we want in general,\n        // but this allows subclasses to overwrite for formats\n        // that just apply to particular embeds\n        super.formatAt(0, this.length(), name, value);\n    }\n    formatAt(index, length, name, value) {\n        if (index === 0 && length === this.length()) {\n            this.format(name, value);\n        }\n        else {\n            super.formatAt(index, length, name, value);\n        }\n    }\n    formats() {\n        return this.statics.formats(this.domNode, this.scroll);\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (EmbedBlot);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/blot/embed.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/blot/inline.ts":
          /*!***************************************************!*\
            !*** ./node_modules/parchment/src/blot/inline.ts ***!
            \***************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _attributor_attributor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../attributor/attributor */ \"./node_modules/parchment/src/attributor/attributor.ts\");\n/* harmony import */ var _attributor_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../attributor/store */ \"./node_modules/parchment/src/attributor/store.ts\");\n/* harmony import */ var _scope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../scope */ \"./node_modules/parchment/src/scope.ts\");\n/* harmony import */ var _abstract_leaf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/leaf */ \"./node_modules/parchment/src/blot/abstract/leaf.ts\");\n/* harmony import */ var _abstract_parent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/parent */ \"./node_modules/parchment/src/blot/abstract/parent.ts\");\n\n\n\n\n\n// Shallow object comparison\nfunction isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n        return false;\n    }\n    // @ts-ignore\n    for (const prop in obj1) {\n        // @ts-ignore\n        if (obj1[prop] !== obj2[prop]) {\n            return false;\n        }\n    }\n    return true;\n}\nclass InlineBlot extends _abstract_parent__WEBPACK_IMPORTED_MODULE_4__[\"default\"] {\n    constructor(scroll, domNode) {\n        super(scroll, domNode);\n        this.attributes = new _attributor_store__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.domNode);\n    }\n    static formats(domNode, scroll) {\n        const match = scroll.query(InlineBlot.blotName);\n        if (match != null &&\n            domNode.tagName === match.tagName) {\n            return undefined;\n        }\n        else if (typeof this.tagName === 'string') {\n            return true;\n        }\n        else if (Array.isArray(this.tagName)) {\n            return domNode.tagName.toLowerCase();\n        }\n        return undefined;\n    }\n    format(name, value) {\n        if (name === this.statics.blotName && !value) {\n            this.children.forEach(child => {\n                if (!(child instanceof InlineBlot)) {\n                    child = child.wrap(InlineBlot.blotName, true);\n                }\n                this.attributes.copy(child);\n            });\n            this.unwrap();\n        }\n        else {\n            const format = this.scroll.query(name, _scope__WEBPACK_IMPORTED_MODULE_2__[\"default\"].INLINE);\n            if (format == null) {\n                return;\n            }\n            if (format instanceof _attributor_attributor__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n                this.attributes.attribute(format, value);\n            }\n            else if (value &&\n                (name !== this.statics.blotName || this.formats()[name] !== value)) {\n                this.replaceWith(name, value);\n            }\n        }\n    }\n    formats() {\n        const formats = this.attributes.values();\n        const format = this.statics.formats(this.domNode, this.scroll);\n        if (format != null) {\n            formats[this.statics.blotName] = format;\n        }\n        return formats;\n    }\n    formatAt(index, length, name, value) {\n        if (this.formats()[name] != null ||\n            this.scroll.query(name, _scope__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ATTRIBUTE)) {\n            const blot = this.isolate(index, length);\n            blot.format(name, value);\n        }\n        else {\n            super.formatAt(index, length, name, value);\n        }\n    }\n    optimize(context) {\n        super.optimize(context);\n        const formats = this.formats();\n        if (Object.keys(formats).length === 0) {\n            return this.unwrap(); // unformatted span\n        }\n        const next = this.next;\n        if (next instanceof InlineBlot &&\n            next.prev === this &&\n            isEqual(formats, next.formats())) {\n            next.moveChildren(this);\n            next.remove();\n        }\n    }\n    replaceWith(name, value) {\n        const replacement = super.replaceWith(name, value);\n        this.attributes.copy(replacement);\n        return replacement;\n    }\n    update(mutations, context) {\n        super.update(mutations, context);\n        const attributeChanged = mutations.some(mutation => mutation.target === this.domNode && mutation.type === 'attributes');\n        if (attributeChanged) {\n            this.attributes.build();\n        }\n    }\n    wrap(name, value) {\n        const wrapper = super.wrap(name, value);\n        if (wrapper instanceof InlineBlot) {\n            this.attributes.move(wrapper);\n        }\n        return wrapper;\n    }\n}\nInlineBlot.allowedChildren = [InlineBlot, _abstract_leaf__WEBPACK_IMPORTED_MODULE_3__[\"default\"]];\nInlineBlot.blotName = 'inline';\nInlineBlot.scope = _scope__WEBPACK_IMPORTED_MODULE_2__[\"default\"].INLINE_BLOT;\nInlineBlot.tagName = 'SPAN';\n/* harmony default export */ __webpack_exports__[\"default\"] = (InlineBlot);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/blot/inline.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/blot/scroll.ts":
          /*!***************************************************!*\
            !*** ./node_modules/parchment/src/blot/scroll.ts ***!
            \***************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ \"./node_modules/parchment/src/registry.ts\");\n/* harmony import */ var _scope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scope */ \"./node_modules/parchment/src/scope.ts\");\n/* harmony import */ var _abstract_container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/container */ \"./node_modules/parchment/src/blot/abstract/container.ts\");\n/* harmony import */ var _abstract_parent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/parent */ \"./node_modules/parchment/src/blot/abstract/parent.ts\");\n/* harmony import */ var _block__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./block */ \"./node_modules/parchment/src/blot/block.ts\");\n\n\n\n\n\nconst OBSERVER_CONFIG = {\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n};\nconst MAX_OPTIMIZE_ITERATIONS = 100;\nclass ScrollBlot extends _abstract_parent__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n    constructor(registry, node) {\n        // @ts-ignore\n        super(null, node);\n        this.registry = registry;\n        this.scroll = this;\n        this.build();\n        this.observer = new MutationObserver((mutations) => {\n            this.update(mutations);\n        });\n        this.observer.observe(this.domNode, OBSERVER_CONFIG);\n        this.attach();\n    }\n    create(input, value) {\n        return this.registry.create(this, input, value);\n    }\n    find(node, bubble = false) {\n        return this.registry.find(node, bubble);\n    }\n    query(query, scope = _scope__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ANY) {\n        return this.registry.query(query, scope);\n    }\n    register(...definitions) {\n        return this.registry.register(...definitions);\n    }\n    build() {\n        if (this.scroll == null) {\n            return;\n        }\n        super.build();\n    }\n    detach() {\n        super.detach();\n        this.observer.disconnect();\n    }\n    deleteAt(index, length) {\n        this.update();\n        if (index === 0 && length === this.length()) {\n            this.children.forEach(child => {\n                child.remove();\n            });\n        }\n        else {\n            super.deleteAt(index, length);\n        }\n    }\n    formatAt(index, length, name, value) {\n        this.update();\n        super.formatAt(index, length, name, value);\n    }\n    insertAt(index, value, def) {\n        this.update();\n        super.insertAt(index, value, def);\n    }\n    optimize(mutations = [], context = {}) {\n        super.optimize(context);\n        const mutationsMap = context.mutationsMap || new WeakMap();\n        // We must modify mutations directly, cannot make copy and then modify\n        let records = Array.from(this.observer.takeRecords());\n        // Array.push currently seems to be implemented by a non-tail recursive function\n        // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n        while (records.length > 0) {\n            mutations.push(records.pop());\n        }\n        const mark = (blot, markParent = true) => {\n            if (blot == null || blot === this) {\n                return;\n            }\n            if (blot.domNode.parentNode == null) {\n                return;\n            }\n            if (!mutationsMap.has(blot.domNode)) {\n                mutationsMap.set(blot.domNode, []);\n            }\n            if (markParent) {\n                mark(blot.parent);\n            }\n        };\n        const optimize = (blot) => {\n            // Post-order traversal\n            if (!mutationsMap.has(blot.domNode)) {\n                return;\n            }\n            if (blot instanceof _abstract_parent__WEBPACK_IMPORTED_MODULE_3__[\"default\"]) {\n                blot.children.forEach(optimize);\n            }\n            mutationsMap.delete(blot.domNode);\n            blot.optimize(context);\n        };\n        let remaining = mutations;\n        for (let i = 0; remaining.length > 0; i += 1) {\n            if (i >= MAX_OPTIMIZE_ITERATIONS) {\n                throw new Error('[Parchment] Maximum optimize iterations reached');\n            }\n            remaining.forEach((mutation) => {\n                const blot = this.find(mutation.target, true);\n                if (blot == null) {\n                    return;\n                }\n                if (blot.domNode === mutation.target) {\n                    if (mutation.type === 'childList') {\n                        mark(this.find(mutation.previousSibling, false));\n                        Array.from(mutation.addedNodes).forEach((node) => {\n                            const child = this.find(node, false);\n                            mark(child, false);\n                            if (child instanceof _abstract_parent__WEBPACK_IMPORTED_MODULE_3__[\"default\"]) {\n                                child.children.forEach((grandChild) => {\n                                    mark(grandChild, false);\n                                });\n                            }\n                        });\n                    }\n                    else if (mutation.type === 'attributes') {\n                        mark(blot.prev);\n                    }\n                }\n                mark(blot);\n            });\n            this.children.forEach(optimize);\n            remaining = Array.from(this.observer.takeRecords());\n            records = remaining.slice();\n            while (records.length > 0) {\n                mutations.push(records.pop());\n            }\n        }\n    }\n    update(mutations, context = {}) {\n        mutations = mutations || this.observer.takeRecords();\n        const mutationsMap = new WeakMap();\n        mutations\n            .map((mutation) => {\n            const blot = _registry__WEBPACK_IMPORTED_MODULE_0__[\"default\"].find(mutation.target, true);\n            if (blot == null) {\n                return null;\n            }\n            if (mutationsMap.has(blot.domNode)) {\n                mutationsMap.get(blot.domNode).push(mutation);\n                return null;\n            }\n            else {\n                mutationsMap.set(blot.domNode, [mutation]);\n                return blot;\n            }\n        })\n            .forEach((blot) => {\n            if (blot != null && blot !== this && mutationsMap.has(blot.domNode)) {\n                blot.update(mutationsMap.get(blot.domNode) || [], context);\n            }\n        });\n        context.mutationsMap = mutationsMap;\n        if (mutationsMap.has(this.domNode)) {\n            super.update(mutationsMap.get(this.domNode), context);\n        }\n        this.optimize(mutations, context);\n    }\n}\nScrollBlot.blotName = 'scroll';\nScrollBlot.defaultChild = _block__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\nScrollBlot.allowedChildren = [_block__WEBPACK_IMPORTED_MODULE_4__[\"default\"], _abstract_container__WEBPACK_IMPORTED_MODULE_2__[\"default\"]];\nScrollBlot.scope = _scope__WEBPACK_IMPORTED_MODULE_1__[\"default\"].BLOCK_BLOT;\nScrollBlot.tagName = 'DIV';\n/* harmony default export */ __webpack_exports__[\"default\"] = (ScrollBlot);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/blot/scroll.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/blot/text.ts":
          /*!*************************************************!*\
            !*** ./node_modules/parchment/src/blot/text.ts ***!
            \*************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scope */ \"./node_modules/parchment/src/scope.ts\");\n/* harmony import */ var _abstract_leaf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract/leaf */ \"./node_modules/parchment/src/blot/abstract/leaf.ts\");\n\n\nclass TextBlot extends _abstract_leaf__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    constructor(scroll, node) {\n        super(scroll, node);\n        this.text = this.statics.value(this.domNode);\n    }\n    static create(value) {\n        return document.createTextNode(value);\n    }\n    static value(domNode) {\n        return domNode.data;\n    }\n    deleteAt(index, length) {\n        this.domNode.data = this.text =\n            this.text.slice(0, index) + this.text.slice(index + length);\n    }\n    index(node, offset) {\n        if (this.domNode === node) {\n            return offset;\n        }\n        return -1;\n    }\n    insertAt(index, value, def) {\n        if (def == null) {\n            this.text = this.text.slice(0, index) + value + this.text.slice(index);\n            this.domNode.data = this.text;\n        }\n        else {\n            super.insertAt(index, value, def);\n        }\n    }\n    length() {\n        return this.text.length;\n    }\n    optimize(context) {\n        super.optimize(context);\n        this.text = this.statics.value(this.domNode);\n        if (this.text.length === 0) {\n            this.remove();\n        }\n        else if (this.next instanceof TextBlot && this.next.prev === this) {\n            this.insertAt(this.length(), this.next.value());\n            this.next.remove();\n        }\n    }\n    position(index, _inclusive = false) {\n        return [this.domNode, index];\n    }\n    split(index, force = false) {\n        if (!force) {\n            if (index === 0) {\n                return this;\n            }\n            if (index === this.length()) {\n                return this.next;\n            }\n        }\n        const after = this.scroll.create(this.domNode.splitText(index));\n        this.parent.insertBefore(after, this.next || undefined);\n        this.text = this.statics.value(this.domNode);\n        return after;\n    }\n    update(mutations, _context) {\n        if (mutations.some(mutation => {\n            return (mutation.type === 'characterData' && mutation.target === this.domNode);\n        })) {\n            this.text = this.statics.value(this.domNode);\n        }\n    }\n    value() {\n        return this.text;\n    }\n}\nTextBlot.blotName = 'text';\nTextBlot.scope = _scope__WEBPACK_IMPORTED_MODULE_0__[\"default\"].INLINE_BLOT;\n/* harmony default export */ __webpack_exports__[\"default\"] = (TextBlot);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/blot/text.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/collection/linked-list.ts":
          /*!**************************************************************!*\
            !*** ./node_modules/parchment/src/collection/linked-list.ts ***!
            \**************************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\nclass LinkedList {\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.length = 0;\n    }\n    append(...nodes) {\n        this.insertBefore(nodes[0], null);\n        if (nodes.length > 1) {\n            this.append.apply(this, nodes.slice(1));\n        }\n    }\n    at(index) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur && index > 0) {\n            index -= 1;\n            cur = next();\n        }\n        return cur;\n    }\n    contains(node) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            if (cur === node) {\n                return true;\n            }\n            cur = next();\n        }\n        return false;\n    }\n    indexOf(node) {\n        const next = this.iterator();\n        let cur = next();\n        let index = 0;\n        while (cur) {\n            if (cur === node) {\n                return index;\n            }\n            index += 1;\n            cur = next();\n        }\n        return -1;\n    }\n    insertBefore(node, refNode) {\n        if (node == null) {\n            return;\n        }\n        this.remove(node);\n        node.next = refNode;\n        if (refNode != null) {\n            node.prev = refNode.prev;\n            if (refNode.prev != null) {\n                refNode.prev.next = node;\n            }\n            refNode.prev = node;\n            if (refNode === this.head) {\n                this.head = node;\n            }\n        }\n        else if (this.tail != null) {\n            this.tail.next = node;\n            node.prev = this.tail;\n            this.tail = node;\n        }\n        else {\n            node.prev = null;\n            this.head = this.tail = node;\n        }\n        this.length += 1;\n    }\n    offset(target) {\n        let index = 0;\n        let cur = this.head;\n        while (cur != null) {\n            if (cur === target) {\n                return index;\n            }\n            index += cur.length();\n            cur = cur.next;\n        }\n        return -1;\n    }\n    remove(node) {\n        if (!this.contains(node)) {\n            return;\n        }\n        if (node.prev != null) {\n            node.prev.next = node.next;\n        }\n        if (node.next != null) {\n            node.next.prev = node.prev;\n        }\n        if (node === this.head) {\n            this.head = node.next;\n        }\n        if (node === this.tail) {\n            this.tail = node.prev;\n        }\n        this.length -= 1;\n    }\n    iterator(curNode = this.head) {\n        // TODO use yield when we can\n        return () => {\n            const ret = curNode;\n            if (curNode != null) {\n                curNode = curNode.next;\n            }\n            return ret;\n        };\n    }\n    find(index, inclusive = false) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            const length = cur.length();\n            if (index < length ||\n                (inclusive &&\n                    index === length &&\n                    (cur.next == null || cur.next.length() !== 0))) {\n                return [cur, index];\n            }\n            index -= length;\n            cur = next();\n        }\n        return [null, 0];\n    }\n    forEach(callback) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            callback(cur);\n            cur = next();\n        }\n    }\n    forEachAt(index, length, callback) {\n        if (length <= 0) {\n            return;\n        }\n        const [startNode, offset] = this.find(index);\n        let curIndex = index - offset;\n        const next = this.iterator(startNode);\n        let cur = next();\n        while (cur && curIndex < index + length) {\n            const curLength = cur.length();\n            if (index > curIndex) {\n                callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));\n            }\n            else {\n                callback(cur, 0, Math.min(curLength, index + length - curIndex));\n            }\n            curIndex += curLength;\n            cur = next();\n        }\n    }\n    map(callback) {\n        return this.reduce((memo, cur) => {\n            memo.push(callback(cur));\n            return memo;\n        }, []);\n    }\n    reduce(callback, memo) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            memo = callback(memo, cur);\n            cur = next();\n        }\n        return memo;\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (LinkedList);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/collection/linked-list.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/error.ts":
          /*!*********************************************!*\
            !*** ./node_modules/parchment/src/error.ts ***!
            \*********************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ParchmentError; });\nclass ParchmentError extends Error {\n    constructor(message) {\n        message = '[Parchment] ' + message;\n        super(message);\n        this.message = message;\n        this.name = this.constructor.name;\n    }\n}\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/error.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/parchment.ts":
          /*!*************************************************!*\
            !*** ./node_modules/parchment/src/parchment.ts ***!
            \*************************************************/

          /*! exports provided: ParentBlot, ContainerBlot, LeafBlot, EmbedBlot, ScrollBlot, BlockBlot, InlineBlot, TextBlot, Attributor, ClassAttributor, StyleAttributor, AttributorStore, Registry, Scope */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _blot_abstract_container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blot/abstract/container */ \"./node_modules/parchment/src/blot/abstract/container.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ContainerBlot\", function() { return _blot_abstract_container__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _blot_abstract_leaf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blot/abstract/leaf */ \"./node_modules/parchment/src/blot/abstract/leaf.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LeafBlot\", function() { return _blot_abstract_leaf__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _blot_abstract_parent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blot/abstract/parent */ \"./node_modules/parchment/src/blot/abstract/parent.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ParentBlot\", function() { return _blot_abstract_parent__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _blot_block__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./blot/block */ \"./node_modules/parchment/src/blot/block.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BlockBlot\", function() { return _blot_block__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var _blot_embed__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./blot/embed */ \"./node_modules/parchment/src/blot/embed.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EmbedBlot\", function() { return _blot_embed__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _blot_inline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./blot/inline */ \"./node_modules/parchment/src/blot/inline.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"InlineBlot\", function() { return _blot_inline__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; });\n\n/* harmony import */ var _blot_scroll__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./blot/scroll */ \"./node_modules/parchment/src/blot/scroll.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScrollBlot\", function() { return _blot_scroll__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; });\n\n/* harmony import */ var _blot_text__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./blot/text */ \"./node_modules/parchment/src/blot/text.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TextBlot\", function() { return _blot_text__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; });\n\n/* harmony import */ var _attributor_attributor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./attributor/attributor */ \"./node_modules/parchment/src/attributor/attributor.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Attributor\", function() { return _attributor_attributor__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; });\n\n/* harmony import */ var _attributor_class__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./attributor/class */ \"./node_modules/parchment/src/attributor/class.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ClassAttributor\", function() { return _attributor_class__WEBPACK_IMPORTED_MODULE_9__[\"default\"]; });\n\n/* harmony import */ var _attributor_store__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./attributor/store */ \"./node_modules/parchment/src/attributor/store.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AttributorStore\", function() { return _attributor_store__WEBPACK_IMPORTED_MODULE_10__[\"default\"]; });\n\n/* harmony import */ var _attributor_style__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./attributor/style */ \"./node_modules/parchment/src/attributor/style.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StyleAttributor\", function() { return _attributor_style__WEBPACK_IMPORTED_MODULE_11__[\"default\"]; });\n\n/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./registry */ \"./node_modules/parchment/src/registry.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Registry\", function() { return _registry__WEBPACK_IMPORTED_MODULE_12__[\"default\"]; });\n\n/* harmony import */ var _scope__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./scope */ \"./node_modules/parchment/src/scope.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Scope\", function() { return _scope__WEBPACK_IMPORTED_MODULE_13__[\"default\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/parchment.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/registry.ts":
          /*!************************************************!*\
            !*** ./node_modules/parchment/src/registry.ts ***!
            \************************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Registry; });\n/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./error */ \"./node_modules/parchment/src/error.ts\");\n/* harmony import */ var _scope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scope */ \"./node_modules/parchment/src/scope.ts\");\n\n\nclass Registry {\n    constructor() {\n        this.attributes = {};\n        this.classes = {};\n        this.tags = {};\n        this.types = {};\n    }\n    static find(node, bubble = false) {\n        if (node == null) {\n            return null;\n        }\n        if (this.blots.has(node)) {\n            return this.blots.get(node) || null;\n        }\n        if (bubble) {\n            return this.find(node.parentNode, bubble);\n        }\n        return null;\n    }\n    create(scroll, input, value) {\n        const match = this.query(input);\n        if (match == null) {\n            throw new _error__WEBPACK_IMPORTED_MODULE_0__[\"default\"](`Unable to create ${input} blot`);\n        }\n        const blotClass = match;\n        const node = \n        // @ts-ignore\n        input instanceof Node || input.nodeType === Node.TEXT_NODE\n            ? input\n            : blotClass.create(value);\n        const blot = new blotClass(scroll, node, value);\n        Registry.blots.set(blot.domNode, blot);\n        return blot;\n    }\n    find(node, bubble = false) {\n        return Registry.find(node, bubble);\n    }\n    query(query, scope = _scope__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ANY) {\n        let match;\n        if (typeof query === 'string') {\n            match = this.types[query] || this.attributes[query];\n            // @ts-ignore\n        }\n        else if (query instanceof Text || query.nodeType === Node.TEXT_NODE) {\n            match = this.types.text;\n        }\n        else if (typeof query === 'number') {\n            if (query & _scope__WEBPACK_IMPORTED_MODULE_1__[\"default\"].LEVEL & _scope__WEBPACK_IMPORTED_MODULE_1__[\"default\"].BLOCK) {\n                match = this.types.block;\n            }\n            else if (query & _scope__WEBPACK_IMPORTED_MODULE_1__[\"default\"].LEVEL & _scope__WEBPACK_IMPORTED_MODULE_1__[\"default\"].INLINE) {\n                match = this.types.inline;\n            }\n        }\n        else if (query instanceof HTMLElement) {\n            const names = (query.getAttribute('class') || '').split(/\\s+/);\n            names.some(name => {\n                match = this.classes[name];\n                if (match) {\n                    return true;\n                }\n                return false;\n            });\n            match = match || this.tags[query.tagName];\n        }\n        if (match == null) {\n            return null;\n        }\n        // @ts-ignore\n        if (scope & _scope__WEBPACK_IMPORTED_MODULE_1__[\"default\"].LEVEL & match.scope && scope & _scope__WEBPACK_IMPORTED_MODULE_1__[\"default\"].TYPE & match.scope) {\n            return match;\n        }\n        return null;\n    }\n    register(...definitions) {\n        if (definitions.length > 1) {\n            return definitions.map(d => {\n                return this.register(d);\n            });\n        }\n        const definition = definitions[0];\n        if (typeof definition.blotName !== 'string' &&\n            typeof definition.attrName !== 'string') {\n            throw new _error__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('Invalid definition');\n        }\n        else if (definition.blotName === 'abstract') {\n            throw new _error__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('Cannot register abstract class');\n        }\n        this.types[definition.blotName || definition.attrName] = definition;\n        if (typeof definition.keyName === 'string') {\n            this.attributes[definition.keyName] = definition;\n        }\n        else {\n            if (definition.className != null) {\n                this.classes[definition.className] = definition;\n            }\n            if (definition.tagName != null) {\n                if (Array.isArray(definition.tagName)) {\n                    definition.tagName = definition.tagName.map((tagName) => {\n                        return tagName.toUpperCase();\n                    });\n                }\n                else {\n                    definition.tagName = definition.tagName.toUpperCase();\n                }\n                const tagNames = Array.isArray(definition.tagName)\n                    ? definition.tagName\n                    : [definition.tagName];\n                tagNames.forEach((tag) => {\n                    if (this.tags[tag] == null || definition.className == null) {\n                        this.tags[tag] = definition;\n                    }\n                });\n            }\n        }\n        return definition;\n    }\n}\nRegistry.blots = new WeakMap();\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/registry.ts?");
            /***/
          },

          /***/
          "./node_modules/parchment/src/scope.ts":
          /*!*********************************************!*\
            !*** ./node_modules/parchment/src/scope.ts ***!
            \*********************************************/

          /*! exports provided: default */

          /***/
          function (module, __webpack_exports__, __webpack_require__) {

            eval("__webpack_require__.r(__webpack_exports__);\nvar Scope;\n(function (Scope) {\n    Scope[Scope[\"TYPE\"] = 3] = \"TYPE\";\n    Scope[Scope[\"LEVEL\"] = 12] = \"LEVEL\";\n    Scope[Scope[\"ATTRIBUTE\"] = 13] = \"ATTRIBUTE\";\n    Scope[Scope[\"BLOT\"] = 14] = \"BLOT\";\n    Scope[Scope[\"INLINE\"] = 7] = \"INLINE\";\n    Scope[Scope[\"BLOCK\"] = 11] = \"BLOCK\";\n    Scope[Scope[\"BLOCK_BLOT\"] = 10] = \"BLOCK_BLOT\";\n    Scope[Scope[\"INLINE_BLOT\"] = 6] = \"INLINE_BLOT\";\n    Scope[Scope[\"BLOCK_ATTRIBUTE\"] = 9] = \"BLOCK_ATTRIBUTE\";\n    Scope[Scope[\"INLINE_ATTRIBUTE\"] = 5] = \"INLINE_ATTRIBUTE\";\n    Scope[Scope[\"ANY\"] = 15] = \"ANY\";\n})(Scope || (Scope = {}));\n/* harmony default export */ __webpack_exports__[\"default\"] = (Scope);\n\n\n//# sourceURL=webpack://Quill/./node_modules/parchment/src/scope.ts?");
            /***/
          },

          /***/
          "./node_modules/quill-delta/dist/AttributeMap.js":
          /*!*******************************************************!*\
            !*** ./node_modules/quill-delta/dist/AttributeMap.js ***!
            \*******************************************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar deep_equal_1 = __importDefault(__webpack_require__(/*! deep-equal */ \"./node_modules/deep-equal/index.js\"));\nvar extend_1 = __importDefault(__webpack_require__(/*! extend */ \"./node_modules/extend/index.js\"));\nvar AttributeMap;\n(function (AttributeMap) {\n    function compose(a, b, keepNull) {\n        if (a === void 0) { a = {}; }\n        if (b === void 0) { b = {}; }\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        var attributes = extend_1.default(true, {}, b);\n        if (!keepNull) {\n            attributes = Object.keys(attributes).reduce(function (copy, key) {\n                if (attributes[key] != null) {\n                    copy[key] = attributes[key];\n                }\n                return copy;\n            }, {});\n        }\n        for (var key in a) {\n            if (a[key] !== undefined && b[key] === undefined) {\n                attributes[key] = a[key];\n            }\n        }\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.compose = compose;\n    function diff(a, b) {\n        if (a === void 0) { a = {}; }\n        if (b === void 0) { b = {}; }\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        var attributes = Object.keys(a)\n            .concat(Object.keys(b))\n            .reduce(function (attrs, key) {\n            if (!deep_equal_1.default(a[key], b[key])) {\n                attrs[key] = b[key] === undefined ? null : b[key];\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.diff = diff;\n    function transform(a, b, priority) {\n        if (priority === void 0) { priority = false; }\n        if (typeof a !== 'object') {\n            return b;\n        }\n        if (typeof b !== 'object') {\n            return undefined;\n        }\n        if (!priority) {\n            return b; // b simply overwrites us without priority\n        }\n        var attributes = Object.keys(b).reduce(function (attrs, key) {\n            if (a[key] === undefined) {\n                attrs[key] = b[key]; // null is a valid value\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.transform = transform;\n})(AttributeMap || (AttributeMap = {}));\nexports.default = AttributeMap;\n//# sourceMappingURL=AttributeMap.js.map\n\n//# sourceURL=webpack://Quill/./node_modules/quill-delta/dist/AttributeMap.js?");
            /***/
          },

          /***/
          "./node_modules/quill-delta/dist/Delta.js":
          /*!************************************************!*\
            !*** ./node_modules/quill-delta/dist/Delta.js ***!
            \************************************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar deep_equal_1 = __importDefault(__webpack_require__(/*! deep-equal */ \"./node_modules/deep-equal/index.js\"));\nvar extend_1 = __importDefault(__webpack_require__(/*! extend */ \"./node_modules/extend/index.js\"));\nvar fast_diff_1 = __importDefault(__webpack_require__(/*! fast-diff */ \"./node_modules/quill-delta/node_modules/fast-diff/diff.js\"));\nvar AttributeMap_1 = __importDefault(__webpack_require__(/*! ./AttributeMap */ \"./node_modules/quill-delta/dist/AttributeMap.js\"));\nvar Op_1 = __importDefault(__webpack_require__(/*! ./Op */ \"./node_modules/quill-delta/dist/Op.js\"));\nvar NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\nvar Delta = /** @class */ (function () {\n    function Delta(ops) {\n        // Assume we are given a well formed ops\n        if (Array.isArray(ops)) {\n            this.ops = ops;\n        }\n        else if (ops != null && Array.isArray(ops.ops)) {\n            this.ops = ops.ops;\n        }\n        else {\n            this.ops = [];\n        }\n    }\n    Delta.prototype.insert = function (arg, attributes) {\n        var newOp = {};\n        if (typeof arg === 'string' && arg.length === 0) {\n            return this;\n        }\n        newOp.insert = arg;\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    };\n    Delta.prototype.delete = function (length) {\n        if (length <= 0) {\n            return this;\n        }\n        return this.push({ delete: length });\n    };\n    Delta.prototype.retain = function (length, attributes) {\n        if (length <= 0) {\n            return this;\n        }\n        var newOp = { retain: length };\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    };\n    Delta.prototype.push = function (newOp) {\n        var index = this.ops.length;\n        var lastOp = this.ops[index - 1];\n        newOp = extend_1.default(true, {}, newOp);\n        if (typeof lastOp === 'object') {\n            if (typeof newOp.delete === 'number' &&\n                typeof lastOp.delete === 'number') {\n                this.ops[index - 1] = { delete: lastOp.delete + newOp.delete };\n                return this;\n            }\n            // Since it does not matter if we insert before or after deleting at the same index,\n            // always prefer to insert first\n            if (typeof lastOp.delete === 'number' && newOp.insert != null) {\n                index -= 1;\n                lastOp = this.ops[index - 1];\n                if (typeof lastOp !== 'object') {\n                    this.ops.unshift(newOp);\n                    return this;\n                }\n            }\n            if (deep_equal_1.default(newOp.attributes, lastOp.attributes)) {\n                if (typeof newOp.insert === 'string' &&\n                    typeof lastOp.insert === 'string') {\n                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n                else if (typeof newOp.retain === 'number' &&\n                    typeof lastOp.retain === 'number') {\n                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n            }\n        }\n        if (index === this.ops.length) {\n            this.ops.push(newOp);\n        }\n        else {\n            this.ops.splice(index, 0, newOp);\n        }\n        return this;\n    };\n    Delta.prototype.chop = function () {\n        var lastOp = this.ops[this.ops.length - 1];\n        if (lastOp && lastOp.retain && !lastOp.attributes) {\n            this.ops.pop();\n        }\n        return this;\n    };\n    Delta.prototype.filter = function (predicate) {\n        return this.ops.filter(predicate);\n    };\n    Delta.prototype.forEach = function (predicate) {\n        this.ops.forEach(predicate);\n    };\n    Delta.prototype.map = function (predicate) {\n        return this.ops.map(predicate);\n    };\n    Delta.prototype.partition = function (predicate) {\n        var passed = [];\n        var failed = [];\n        this.forEach(function (op) {\n            var target = predicate(op) ? passed : failed;\n            target.push(op);\n        });\n        return [passed, failed];\n    };\n    Delta.prototype.reduce = function (predicate, initialValue) {\n        return this.ops.reduce(predicate, initialValue);\n    };\n    Delta.prototype.changeLength = function () {\n        return this.reduce(function (length, elem) {\n            if (elem.insert) {\n                return length + Op_1.default.length(elem);\n            }\n            else if (elem.delete) {\n                return length - elem.delete;\n            }\n            return length;\n        }, 0);\n    };\n    Delta.prototype.length = function () {\n        return this.reduce(function (length, elem) {\n            return length + Op_1.default.length(elem);\n        }, 0);\n    };\n    Delta.prototype.slice = function (start, end) {\n        if (start === void 0) { start = 0; }\n        if (end === void 0) { end = Infinity; }\n        var ops = [];\n        var iter = Op_1.default.iterator(this.ops);\n        var index = 0;\n        while (index < end && iter.hasNext()) {\n            var nextOp = void 0;\n            if (index < start) {\n                nextOp = iter.next(start - index);\n            }\n            else {\n                nextOp = iter.next(end - index);\n                ops.push(nextOp);\n            }\n            index += Op_1.default.length(nextOp);\n        }\n        return new Delta(ops);\n    };\n    Delta.prototype.compose = function (other) {\n        var thisIter = Op_1.default.iterator(this.ops);\n        var otherIter = Op_1.default.iterator(other.ops);\n        var ops = [];\n        var firstOther = otherIter.peek();\n        if (firstOther != null &&\n            typeof firstOther.retain === 'number' &&\n            firstOther.attributes == null) {\n            var firstLeft = firstOther.retain;\n            while (thisIter.peekType() === 'insert' &&\n                thisIter.peekLength() <= firstLeft) {\n                firstLeft -= thisIter.peekLength();\n                ops.push(thisIter.next());\n            }\n            if (firstOther.retain - firstLeft > 0) {\n                otherIter.next(firstOther.retain - firstLeft);\n            }\n        }\n        var delta = new Delta(ops);\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else if (thisIter.peekType() === 'delete') {\n                delta.push(thisIter.next());\n            }\n            else {\n                var length_1 = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                var thisOp = thisIter.next(length_1);\n                var otherOp = otherIter.next(length_1);\n                if (typeof otherOp.retain === 'number') {\n                    var newOp = {};\n                    if (typeof thisOp.retain === 'number') {\n                        newOp.retain = length_1;\n                    }\n                    else {\n                        newOp.insert = thisOp.insert;\n                    }\n                    // Preserve null when composing with a retain, otherwise remove it for inserts\n                    var attributes = AttributeMap_1.default.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');\n                    if (attributes) {\n                        newOp.attributes = attributes;\n                    }\n                    delta.push(newOp);\n                    // Optimization if rest of other is just retain\n                    if (!otherIter.hasNext() &&\n                        deep_equal_1.default(delta.ops[delta.ops.length - 1], newOp)) {\n                        var rest = new Delta(thisIter.rest());\n                        return delta.concat(rest).chop();\n                    }\n                    // Other op should be delete, we could be an insert or retain\n                    // Insert + delete cancels out\n                }\n                else if (typeof otherOp.delete === 'number' &&\n                    typeof thisOp.retain === 'number') {\n                    delta.push(otherOp);\n                }\n            }\n        }\n        return delta.chop();\n    };\n    Delta.prototype.concat = function (other) {\n        var delta = new Delta(this.ops.slice());\n        if (other.ops.length > 0) {\n            delta.push(other.ops[0]);\n            delta.ops = delta.ops.concat(other.ops.slice(1));\n        }\n        return delta;\n    };\n    Delta.prototype.diff = function (other, cursor) {\n        if (this.ops === other.ops) {\n            return new Delta();\n        }\n        var strings = [this, other].map(function (delta) {\n            return delta\n                .map(function (op) {\n                if (op.insert != null) {\n                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n                }\n                var prep = delta === other ? 'on' : 'with';\n                throw new Error('diff() called ' + prep + ' non-document');\n            })\n                .join('');\n        });\n        var retDelta = new Delta();\n        var diffResult = fast_diff_1.default(strings[0], strings[1], cursor);\n        var thisIter = Op_1.default.iterator(this.ops);\n        var otherIter = Op_1.default.iterator(other.ops);\n        diffResult.forEach(function (component) {\n            var length = component[1].length;\n            while (length > 0) {\n                var opLength = 0;\n                switch (component[0]) {\n                    case fast_diff_1.default.INSERT:\n                        opLength = Math.min(otherIter.peekLength(), length);\n                        retDelta.push(otherIter.next(opLength));\n                        break;\n                    case fast_diff_1.default.DELETE:\n                        opLength = Math.min(length, thisIter.peekLength());\n                        thisIter.next(opLength);\n                        retDelta.delete(opLength);\n                        break;\n                    case fast_diff_1.default.EQUAL:\n                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n                        var thisOp = thisIter.next(opLength);\n                        var otherOp = otherIter.next(opLength);\n                        if (deep_equal_1.default(thisOp.insert, otherOp.insert)) {\n                            retDelta.retain(opLength, AttributeMap_1.default.diff(thisOp.attributes, otherOp.attributes));\n                        }\n                        else {\n                            retDelta.push(otherOp).delete(opLength);\n                        }\n                        break;\n                }\n                length -= opLength;\n            }\n        });\n        return retDelta.chop();\n    };\n    Delta.prototype.eachLine = function (predicate, newline) {\n        if (newline === void 0) { newline = '\\n'; }\n        var iter = Op_1.default.iterator(this.ops);\n        var line = new Delta();\n        var i = 0;\n        while (iter.hasNext()) {\n            if (iter.peekType() !== 'insert') {\n                return;\n            }\n            var thisOp = iter.peek();\n            var start = Op_1.default.length(thisOp) - iter.peekLength();\n            var index = typeof thisOp.insert === 'string'\n                ? thisOp.insert.indexOf(newline, start) - start\n                : -1;\n            if (index < 0) {\n                line.push(iter.next());\n            }\n            else if (index > 0) {\n                line.push(iter.next(index));\n            }\n            else {\n                if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n                    return;\n                }\n                i += 1;\n                line = new Delta();\n            }\n        }\n        if (line.length() > 0) {\n            predicate(line, {}, i);\n        }\n    };\n    Delta.prototype.transform = function (arg, priority) {\n        if (priority === void 0) { priority = false; }\n        priority = !!priority;\n        if (typeof arg === 'number') {\n            return this.transformPosition(arg, priority);\n        }\n        var other = arg;\n        var thisIter = Op_1.default.iterator(this.ops);\n        var otherIter = Op_1.default.iterator(other.ops);\n        var delta = new Delta();\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (thisIter.peekType() === 'insert' &&\n                (priority || otherIter.peekType() !== 'insert')) {\n                delta.retain(Op_1.default.length(thisIter.next()));\n            }\n            else if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else {\n                var length_2 = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                var thisOp = thisIter.next(length_2);\n                var otherOp = otherIter.next(length_2);\n                if (thisOp.delete) {\n                    // Our delete either makes their delete redundant or removes their retain\n                    continue;\n                }\n                else if (otherOp.delete) {\n                    delta.push(otherOp);\n                }\n                else {\n                    // We retain either their retain or insert\n                    delta.retain(length_2, AttributeMap_1.default.transform(thisOp.attributes, otherOp.attributes, priority));\n                }\n            }\n        }\n        return delta.chop();\n    };\n    Delta.prototype.transformPosition = function (index, priority) {\n        if (priority === void 0) { priority = false; }\n        priority = !!priority;\n        var thisIter = Op_1.default.iterator(this.ops);\n        var offset = 0;\n        while (thisIter.hasNext() && offset <= index) {\n            var length_3 = thisIter.peekLength();\n            var nextType = thisIter.peekType();\n            thisIter.next();\n            if (nextType === 'delete') {\n                index -= Math.min(length_3, index - offset);\n                continue;\n            }\n            else if (nextType === 'insert' && (offset < index || !priority)) {\n                index += length_3;\n            }\n            offset += length_3;\n        }\n        return index;\n    };\n    Delta.Op = Op_1.default;\n    Delta.AttributeMap = AttributeMap_1.default;\n    return Delta;\n}());\nmodule.exports = Delta;\n//# sourceMappingURL=Delta.js.map\n\n//# sourceURL=webpack://Quill/./node_modules/quill-delta/dist/Delta.js?");
            /***/
          },

          /***/
          "./node_modules/quill-delta/dist/Iterator.js":
          /*!***************************************************!*\
            !*** ./node_modules/quill-delta/dist/Iterator.js ***!
            \***************************************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Op_1 = __importDefault(__webpack_require__(/*! ./Op */ \"./node_modules/quill-delta/dist/Op.js\"));\nvar Iterator = /** @class */ (function () {\n    function Iterator(ops) {\n        this.ops = ops;\n        this.index = 0;\n        this.offset = 0;\n    }\n    Iterator.prototype.hasNext = function () {\n        return this.peekLength() < Infinity;\n    };\n    Iterator.prototype.next = function (length) {\n        if (!length) {\n            length = Infinity;\n        }\n        var nextOp = this.ops[this.index];\n        if (nextOp) {\n            var offset = this.offset;\n            var opLength = Op_1.default.length(nextOp);\n            if (length >= opLength - offset) {\n                length = opLength - offset;\n                this.index += 1;\n                this.offset = 0;\n            }\n            else {\n                this.offset += length;\n            }\n            if (typeof nextOp.delete === 'number') {\n                return { delete: length };\n            }\n            else {\n                var retOp = {};\n                if (nextOp.attributes) {\n                    retOp.attributes = nextOp.attributes;\n                }\n                if (typeof nextOp.retain === 'number') {\n                    retOp.retain = length;\n                }\n                else if (typeof nextOp.insert === 'string') {\n                    retOp.insert = nextOp.insert.substr(offset, length);\n                }\n                else {\n                    // offset should === 0, length should === 1\n                    retOp.insert = nextOp.insert;\n                }\n                return retOp;\n            }\n        }\n        else {\n            return { retain: Infinity };\n        }\n    };\n    Iterator.prototype.peek = function () {\n        return this.ops[this.index];\n    };\n    Iterator.prototype.peekLength = function () {\n        if (this.ops[this.index]) {\n            // Should never return 0 if our index is being managed correctly\n            return Op_1.default.length(this.ops[this.index]) - this.offset;\n        }\n        else {\n            return Infinity;\n        }\n    };\n    Iterator.prototype.peekType = function () {\n        if (this.ops[this.index]) {\n            if (typeof this.ops[this.index].delete === 'number') {\n                return 'delete';\n            }\n            else if (typeof this.ops[this.index].retain === 'number') {\n                return 'retain';\n            }\n            else {\n                return 'insert';\n            }\n        }\n        return 'retain';\n    };\n    Iterator.prototype.rest = function () {\n        if (!this.hasNext()) {\n            return [];\n        }\n        else if (this.offset === 0) {\n            return this.ops.slice(this.index);\n        }\n        else {\n            var offset = this.offset;\n            var index = this.index;\n            var next = this.next();\n            var rest = this.ops.slice(this.index);\n            this.offset = offset;\n            this.index = index;\n            return [next].concat(rest);\n        }\n    };\n    return Iterator;\n}());\nexports.default = Iterator;\n//# sourceMappingURL=Iterator.js.map\n\n//# sourceURL=webpack://Quill/./node_modules/quill-delta/dist/Iterator.js?");
            /***/
          },

          /***/
          "./node_modules/quill-delta/dist/Op.js":
          /*!*********************************************!*\
            !*** ./node_modules/quill-delta/dist/Op.js ***!
            \*********************************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Iterator_1 = __importDefault(__webpack_require__(/*! ./Iterator */ \"./node_modules/quill-delta/dist/Iterator.js\"));\nvar Op;\n(function (Op) {\n    function iterator(ops) {\n        return new Iterator_1.default(ops);\n    }\n    Op.iterator = iterator;\n    function length(op) {\n        if (typeof op.delete === 'number') {\n            return op.delete;\n        }\n        else if (typeof op.retain === 'number') {\n            return op.retain;\n        }\n        else {\n            return typeof op.insert === 'string' ? op.insert.length : 1;\n        }\n    }\n    Op.length = length;\n})(Op || (Op = {}));\nexports.default = Op;\n//# sourceMappingURL=Op.js.map\n\n//# sourceURL=webpack://Quill/./node_modules/quill-delta/dist/Op.js?");
            /***/
          },

          /***/
          "./node_modules/quill-delta/node_modules/fast-diff/diff.js":
          /*!*****************************************************************!*\
            !*** ./node_modules/quill-delta/node_modules/fast-diff/diff.js ***!
            \*****************************************************************/

          /*! no static exports found */

          /***/
          function (module, exports) {
            eval("/**\n * This library modifies the diff-patch-match library by Neil Fraser\n * by removing the patch and match functionality and certain advanced\n * options in the diff function. The original license is as follows:\n *\n * ===\n *\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {Int|Object} [cursor_pos] Edit position in text1 or object with more info\n * @return {Array} Array of diff tuples.\n */\nfunction diff_main(text1, text2, cursor_pos, _fix_unicode) {\n  // Check for equality\n  if (text1 === text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (cursor_pos != null) {\n    var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);\n    if (editdiff) {\n      return editdiff;\n    }\n  }\n\n  // Trim off common prefix (speedup).\n  var commonlength = diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = diff_compute_(text1, text2);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  diff_cleanupMerge(diffs, _fix_unicode);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_compute_(text1, text2) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i !== -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [\n      [DIFF_INSERT, longtext.substring(0, i)],\n      [DIFF_EQUAL, shorttext],\n      [DIFF_INSERT, longtext.substring(i + shorttext.length)]\n    ];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length === 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = diff_main(text1_a, text2_a);\n    var diffs_b = diff_main(text1_b, text2_b);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  return diff_bisect_(text1, text2);\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n * @private\n */\nfunction diff_bisect_(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 !== 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 === -d || (k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (\n        x1 < text1_length && y1 < text2_length &&\n        text1.charAt(x1) === text2.charAt(y1)\n      ) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 === -d || (k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (\n        x2 < text1_length && y2 < text2_length &&\n        text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)\n      ) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_bisectSplit_(text1, text2, x, y) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = diff_main(text1a, text2a);\n  var diffsb = diff_main(text1b, text2b);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\nfunction diff_commonPrefix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(pointerstart, pointermid) ==\n      text2.substring(pointerstart, pointermid)\n    ) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {\n    pointermid--;\n  }\n\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\nfunction diff_commonSuffix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n      text2.substring(text2.length - pointermid, text2.length - pointerend)\n    ) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {\n    pointermid--;\n  }\n\n  return pointermid;\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n */\nfunction diff_halfMatch_(text1, text2) {\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {\n      var prefixLength = diff_commonPrefix(\n        longtext.substring(i), shorttext.substring(j));\n      var suffixLength = diff_commonSuffix(\n        longtext.substring(0, i), shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(\n          j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [\n        best_longtext_a, best_longtext_b,\n        best_shorttext_a, best_shorttext_b, best_common\n      ];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {Array} diffs Array of diff tuples.\n * @param {boolean} fix_unicode Whether to normalize to a unicode-correct diff\n */\nfunction diff_cleanupMerge(diffs, fix_unicode) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    if (pointer < diffs.length - 1 && !diffs[pointer][1]) {\n      diffs.splice(pointer, 1);\n      continue;\n    }\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        var previous_equality = pointer - count_insert - count_delete - 1;\n        if (fix_unicode) {\n          // prevent splitting of unicode surrogate pairs.  when fix_unicode is true,\n          // we assume that the old and new text in the diff are complete and correct\n          // unicode-encoded JS strings, but the tuple boundaries may fall between\n          // surrogate pairs.  we fix this by shaving off stray surrogates from the end\n          // of the previous equality and the beginning of this equality.  this may create\n          // empty equalities or a common prefix or suffix.  for example, if AB and AC are\n          // emojis, `[[0, 'A'], [-1, 'BA'], [0, 'C']]` would turn into deleting 'ABAC' and\n          // inserting 'AC', and then the common suffix 'AC' will be eliminated.  in this\n          // particular case, both equalities go away, we absorb any previous inequalities,\n          // and we keep scanning for the next equality before rewriting the tuples.\n          if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {\n            var stray = diffs[previous_equality][1].slice(-1);\n            diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);\n            text_delete = stray + text_delete;\n            text_insert = stray + text_insert;\n            if (!diffs[previous_equality][1]) {\n              // emptied out previous equality, so delete it and include previous delete/insert\n              diffs.splice(previous_equality, 1);\n              pointer--;\n              var k = previous_equality - 1;\n              if (diffs[k] && diffs[k][0] === DIFF_INSERT) {\n                count_insert++;\n                text_insert = diffs[k][1] + text_insert;\n                k--;\n              }\n              if (diffs[k] && diffs[k][0] === DIFF_DELETE) {\n                count_delete++;\n                text_delete = diffs[k][1] + text_delete;\n                k--;\n              }\n              previous_equality = k;\n            }\n          }\n          if (starts_with_pair_end(diffs[pointer][1])) {\n            var stray = diffs[pointer][1].charAt(0);\n            diffs[pointer][1] = diffs[pointer][1].slice(1);\n            text_delete += stray;\n            text_insert += stray;\n          }\n        }\n        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {\n          // for empty equality not at end, wait for next equality\n          diffs.splice(pointer, 1);\n          break;\n        }\n        if (text_delete.length > 0 || text_insert.length > 0) {\n          // note that diff_commonPrefix and diff_commonSuffix are unicode-aware\n          if (text_delete.length > 0 && text_insert.length > 0) {\n            // Factor out any common prefixes.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if (previous_equality >= 0) {\n                diffs[previous_equality][1] += text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixes.\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] =\n                text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length - commonlength);\n              text_delete = text_delete.substring(0, text_delete.length - commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          var n = count_insert + count_delete;\n          if (text_delete.length === 0 && text_insert.length === 0) {\n            diffs.splice(pointer - n, n);\n            pointer = pointer - n;\n          } else if (text_delete.length === 0) {\n            diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);\n            pointer = pointer - n + 1;\n          } else if (text_insert.length === 0) {\n            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);\n            pointer = pointer - n + 1;\n          } else {\n            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);\n            pointer = pointer - n + 2;\n          }\n        }\n        if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL &&\n      diffs[pointer + 1][0] === DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n        diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n          diffs[pointer][1].substring(0, diffs[pointer][1].length -\n            diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n        diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n          diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    diff_cleanupMerge(diffs, fix_unicode);\n  }\n};\n\nfunction is_surrogate_pair_start(charCode) {\n  return charCode >= 0xD800 && charCode <= 0xDBFF;\n}\n\nfunction is_surrogate_pair_end(charCode) {\n  return charCode >= 0xDC00 && charCode <= 0xDFFF;\n}\n\nfunction starts_with_pair_end(str) {\n  return is_surrogate_pair_end(str.charCodeAt(0));\n}\n\nfunction ends_with_pair_start(str) {\n  return is_surrogate_pair_start(str.charCodeAt(str.length - 1));\n}\n\nfunction remove_empty_tuples(tuples) {\n  var ret = [];\n  for (var i = 0; i < tuples.length; i++) {\n    if (tuples[i][1].length > 0) {\n      ret.push(tuples[i]);\n    }\n  }\n  return ret;\n}\n\nfunction make_edit_splice(before, oldMiddle, newMiddle, after) {\n  if (ends_with_pair_start(before) || starts_with_pair_end(after)) {\n    return null;\n  }\n  return remove_empty_tuples([\n    [DIFF_EQUAL, before],\n    [DIFF_DELETE, oldMiddle],\n    [DIFF_INSERT, newMiddle],\n    [DIFF_EQUAL, after]\n  ]);\n}\n\nfunction find_cursor_edit_diff(oldText, newText, cursor_pos) {\n  // note: this runs after equality check has ruled out exact equality\n  var oldRange = typeof cursor_pos === 'number' ?\n    { index: cursor_pos, length: 0 } : cursor_pos.oldRange;\n  var newRange = typeof cursor_pos === 'number' ?\n    null : cursor_pos.newRange;\n  // take into account the old and new selection to generate the best diff\n  // possible for a text edit.  for example, a text change from \"xxx\" to \"xx\"\n  // could be a delete or forwards-delete of any one of the x's, or the\n  // result of selecting two of the x's and typing \"x\".\n  var oldLength = oldText.length;\n  var newLength = newText.length;\n  if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {\n    // see if we have an insert or delete before or after cursor\n    var oldCursor = oldRange.index;\n    var oldBefore = oldText.slice(0, oldCursor);\n    var oldAfter = oldText.slice(oldCursor);\n    var maybeNewCursor = newRange ? newRange.index : null;\n    editBefore: {\n      // is this an insert or delete right before oldCursor?\n      var newCursor = oldCursor + newLength - oldLength;\n      if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {\n        break editBefore;\n      }\n      if (newCursor < 0 || newCursor > newLength) {\n        break editBefore;\n      }\n      var newBefore = newText.slice(0, newCursor);\n      var newAfter = newText.slice(newCursor);\n      if (newAfter !== oldAfter) {\n        break editBefore;\n      }\n      var prefixLength = Math.min(oldCursor, newCursor);\n      var oldPrefix = oldBefore.slice(0, prefixLength);\n      var newPrefix = newBefore.slice(0, prefixLength);\n      if (oldPrefix !== newPrefix) {\n        break editBefore;\n      }\n      var oldMiddle = oldBefore.slice(prefixLength);\n      var newMiddle = newBefore.slice(prefixLength);\n      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);\n    }\n    editAfter: {\n      // is this an insert or delete right after oldCursor?\n      if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {\n        break editAfter;\n      }\n      var cursor = oldCursor;\n      var newBefore = newText.slice(0, cursor);\n      var newAfter = newText.slice(cursor);\n      if (newBefore !== oldBefore) {\n        break editAfter;\n      }\n      var suffixLength = Math.min(oldLength - cursor, newLength - cursor);\n      var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);\n      var newSuffix = newAfter.slice(newAfter.length - suffixLength);\n      if (oldSuffix !== newSuffix) {\n        break editAfter;\n      }\n      var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);\n      var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);\n      return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);\n    }\n  }\n  if (oldRange.length > 0 && newRange && newRange.length === 0) {\n    replaceRange: {\n      // see if diff could be a splice of the old selection range\n      var oldPrefix = oldText.slice(0, oldRange.index);\n      var oldSuffix = oldText.slice(oldRange.index + oldRange.length);\n      var prefixLength = oldPrefix.length;\n      var suffixLength = oldSuffix.length;\n      if (newLength < prefixLength + suffixLength) {\n        break replaceRange;\n      }\n      var newPrefix = newText.slice(0, prefixLength);\n      var newSuffix = newText.slice(newLength - suffixLength);\n      if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {\n        break replaceRange;\n      }\n      var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);\n      var newMiddle = newText.slice(prefixLength, newLength - suffixLength);\n      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);\n    }\n  }\n\n  return null;\n}\n\nfunction diff(text1, text2, cursor_pos) {\n  // only pass fix_unicode=true at the top level, not when diff_main is\n  // recursively invoked\n  return diff_main(text1, text2, cursor_pos, true);\n}\n\ndiff.INSERT = DIFF_INSERT;\ndiff.DELETE = DIFF_DELETE;\ndiff.EQUAL = DIFF_EQUAL;\n\nmodule.exports = diff;\n\n\n//# sourceURL=webpack://Quill/./node_modules/quill-delta/node_modules/fast-diff/diff.js?");
            /***/
          },

          /***/
          "./quill.js":
          /*!******************!*\
            !*** ./quill.js ***!
            \******************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _core = __webpack_require__(/*! ./core */ \"./core.js\");\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _align = __webpack_require__(/*! ./formats/align */ \"./formats/align.js\");\n\nvar _direction = __webpack_require__(/*! ./formats/direction */ \"./formats/direction.js\");\n\nvar _indent = __webpack_require__(/*! ./formats/indent */ \"./formats/indent.js\");\n\nvar _indent2 = _interopRequireDefault(_indent);\n\nvar _blockquote = __webpack_require__(/*! ./formats/blockquote */ \"./formats/blockquote.js\");\n\nvar _blockquote2 = _interopRequireDefault(_blockquote);\n\nvar _header = __webpack_require__(/*! ./formats/header */ \"./formats/header.js\");\n\nvar _header2 = _interopRequireDefault(_header);\n\nvar _list = __webpack_require__(/*! ./formats/list */ \"./formats/list.js\");\n\nvar _list2 = _interopRequireDefault(_list);\n\nvar _background = __webpack_require__(/*! ./formats/background */ \"./formats/background.js\");\n\nvar _color = __webpack_require__(/*! ./formats/color */ \"./formats/color.js\");\n\nvar _font = __webpack_require__(/*! ./formats/font */ \"./formats/font.js\");\n\nvar _size = __webpack_require__(/*! ./formats/size */ \"./formats/size.js\");\n\nvar _bold = __webpack_require__(/*! ./formats/bold */ \"./formats/bold.js\");\n\nvar _bold2 = _interopRequireDefault(_bold);\n\nvar _italic = __webpack_require__(/*! ./formats/italic */ \"./formats/italic.js\");\n\nvar _italic2 = _interopRequireDefault(_italic);\n\nvar _link = __webpack_require__(/*! ./formats/link */ \"./formats/link.js\");\n\nvar _link2 = _interopRequireDefault(_link);\n\nvar _script = __webpack_require__(/*! ./formats/script */ \"./formats/script.js\");\n\nvar _script2 = _interopRequireDefault(_script);\n\nvar _strike = __webpack_require__(/*! ./formats/strike */ \"./formats/strike.js\");\n\nvar _strike2 = _interopRequireDefault(_strike);\n\nvar _underline = __webpack_require__(/*! ./formats/underline */ \"./formats/underline.js\");\n\nvar _underline2 = _interopRequireDefault(_underline);\n\nvar _formula = __webpack_require__(/*! ./formats/formula */ \"./formats/formula.js\");\n\nvar _formula2 = _interopRequireDefault(_formula);\n\nvar _image = __webpack_require__(/*! ./formats/image */ \"./formats/image.js\");\n\nvar _image2 = _interopRequireDefault(_image);\n\nvar _video = __webpack_require__(/*! ./formats/video */ \"./formats/video.js\");\n\nvar _video2 = _interopRequireDefault(_video);\n\nvar _code = __webpack_require__(/*! ./formats/code */ \"./formats/code.js\");\n\nvar _code2 = _interopRequireDefault(_code);\n\nvar _syntax = __webpack_require__(/*! ./modules/syntax */ \"./modules/syntax.js\");\n\nvar _syntax2 = _interopRequireDefault(_syntax);\n\nvar _table = __webpack_require__(/*! ./modules/table */ \"./modules/table.js\");\n\nvar _table2 = _interopRequireDefault(_table);\n\nvar _toolbar = __webpack_require__(/*! ./modules/toolbar */ \"./modules/toolbar.js\");\n\nvar _toolbar2 = _interopRequireDefault(_toolbar);\n\nvar _icons = __webpack_require__(/*! ./ui/icons */ \"./ui/icons.js\");\n\nvar _icons2 = _interopRequireDefault(_icons);\n\nvar _picker = __webpack_require__(/*! ./ui/picker */ \"./ui/picker.js\");\n\nvar _picker2 = _interopRequireDefault(_picker);\n\nvar _colorPicker = __webpack_require__(/*! ./ui/color-picker */ \"./ui/color-picker.js\");\n\nvar _colorPicker2 = _interopRequireDefault(_colorPicker);\n\nvar _iconPicker = __webpack_require__(/*! ./ui/icon-picker */ \"./ui/icon-picker.js\");\n\nvar _iconPicker2 = _interopRequireDefault(_iconPicker);\n\nvar _tooltip = __webpack_require__(/*! ./ui/tooltip */ \"./ui/tooltip.js\");\n\nvar _tooltip2 = _interopRequireDefault(_tooltip);\n\nvar _bubble = __webpack_require__(/*! ./themes/bubble */ \"./themes/bubble.js\");\n\nvar _bubble2 = _interopRequireDefault(_bubble);\n\nvar _snow = __webpack_require__(/*! ./themes/snow */ \"./themes/snow.js\");\n\nvar _snow2 = _interopRequireDefault(_snow);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_core2.default.register({\n  'attributors/attribute/direction': _direction.DirectionAttribute,\n\n  'attributors/class/align': _align.AlignClass,\n  'attributors/class/background': _background.BackgroundClass,\n  'attributors/class/color': _color.ColorClass,\n  'attributors/class/direction': _direction.DirectionClass,\n  'attributors/class/font': _font.FontClass,\n  'attributors/class/size': _size.SizeClass,\n\n  'attributors/style/align': _align.AlignStyle,\n  'attributors/style/background': _background.BackgroundStyle,\n  'attributors/style/color': _color.ColorStyle,\n  'attributors/style/direction': _direction.DirectionStyle,\n  'attributors/style/font': _font.FontStyle,\n  'attributors/style/size': _size.SizeStyle\n}, true);\n\n_core2.default.register({\n  'formats/align': _align.AlignClass,\n  'formats/direction': _direction.DirectionClass,\n  'formats/indent': _indent2.default,\n\n  'formats/background': _background.BackgroundStyle,\n  'formats/color': _color.ColorStyle,\n  'formats/font': _font.FontClass,\n  'formats/size': _size.SizeClass,\n\n  'formats/blockquote': _blockquote2.default,\n  'formats/code-block': _code2.default,\n  'formats/header': _header2.default,\n  'formats/list': _list2.default,\n\n  'formats/bold': _bold2.default,\n  'formats/code': _code.Code,\n  'formats/italic': _italic2.default,\n  'formats/link': _link2.default,\n  'formats/script': _script2.default,\n  'formats/strike': _strike2.default,\n  'formats/underline': _underline2.default,\n\n  'formats/formula': _formula2.default,\n  'formats/image': _image2.default,\n  'formats/video': _video2.default,\n\n  'modules/syntax': _syntax2.default,\n  'modules/table': _table2.default,\n  'modules/toolbar': _toolbar2.default,\n\n  'themes/bubble': _bubble2.default,\n  'themes/snow': _snow2.default,\n\n  'ui/icons': _icons2.default,\n  'ui/picker': _picker2.default,\n  'ui/icon-picker': _iconPicker2.default,\n  'ui/color-picker': _colorPicker2.default,\n  'ui/tooltip': _tooltip2.default\n}, true);\n\nexports.default = _core2.default;\n\n//# sourceURL=webpack://Quill/./quill.js?");
            /***/
          },

          /***/
          "./themes/base.js":
          /*!************************!*\
            !*** ./themes/base.js ***!
            \************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.BaseTooltip = undefined;\n\nvar _extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _emitter = __webpack_require__(/*! ../core/emitter */ \"./core/emitter.js\");\n\nvar _emitter2 = _interopRequireDefault(_emitter);\n\nvar _theme = __webpack_require__(/*! ../core/theme */ \"./core/theme.js\");\n\nvar _theme2 = _interopRequireDefault(_theme);\n\nvar _colorPicker = __webpack_require__(/*! ../ui/color-picker */ \"./ui/color-picker.js\");\n\nvar _colorPicker2 = _interopRequireDefault(_colorPicker);\n\nvar _iconPicker = __webpack_require__(/*! ../ui/icon-picker */ \"./ui/icon-picker.js\");\n\nvar _iconPicker2 = _interopRequireDefault(_iconPicker);\n\nvar _picker = __webpack_require__(/*! ../ui/picker */ \"./ui/picker.js\");\n\nvar _picker2 = _interopRequireDefault(_picker);\n\nvar _tooltip = __webpack_require__(/*! ../ui/tooltip */ \"./ui/tooltip.js\");\n\nvar _tooltip2 = _interopRequireDefault(_tooltip);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst ALIGNS = [false, 'center', 'right', 'justify'];\n\nconst COLORS = ['#000000', '#e60000', '#ff9900', '#ffff00', '#008a00', '#0066cc', '#9933ff', '#ffffff', '#facccc', '#ffebcc', '#ffffcc', '#cce8cc', '#cce0f5', '#ebd6ff', '#bbbbbb', '#f06666', '#ffc266', '#ffff66', '#66b966', '#66a3e0', '#c285ff', '#888888', '#a10000', '#b26b00', '#b2b200', '#006100', '#0047b2', '#6b24b2', '#444444', '#5c0000', '#663d00', '#666600', '#003700', '#002966', '#3d1466'];\n\nconst FONTS = [false, 'serif', 'monospace'];\n\nconst HEADERS = ['1', '2', '3', false];\n\nconst SIZES = ['small', false, 'large', 'huge'];\n\nclass BaseTheme extends _theme2.default {\n  constructor(quill, options) {\n    super(quill, options);\n    const listener = e => {\n      if (!document.body.contains(quill.root)) {\n        document.body.removeEventListener('click', listener);\n        return;\n      }\n      if (this.tooltip != null && !this.tooltip.root.contains(e.target) && document.activeElement !== this.tooltip.textbox && !this.quill.hasFocus()) {\n        this.tooltip.hide();\n      }\n      if (this.pickers != null) {\n        this.pickers.forEach(picker => {\n          if (!picker.container.contains(e.target)) {\n            picker.close();\n          }\n        });\n      }\n    };\n    quill.emitter.listenDOM('click', document.body, listener);\n  }\n\n  addModule(name) {\n    const module = super.addModule(name);\n    if (name === 'toolbar') {\n      this.extendToolbar(module);\n    }\n    return module;\n  }\n\n  buildButtons(buttons, icons) {\n    Array.from(buttons).forEach(button => {\n      const className = button.getAttribute('class') || '';\n      className.split(/\\s+/).forEach(name => {\n        if (!name.startsWith('ql-')) return;\n        name = name.slice('ql-'.length);\n        if (icons[name] == null) return;\n        if (name === 'direction') {\n          button.innerHTML = icons[name][''] + icons[name].rtl;\n        } else if (typeof icons[name] === 'string') {\n          button.innerHTML = icons[name];\n        } else {\n          const value = button.value || '';\n          if (value != null && icons[name][value]) {\n            button.innerHTML = icons[name][value];\n          }\n        }\n      });\n    });\n  }\n\n  buildPickers(selects, icons) {\n    this.pickers = Array.from(selects).map(select => {\n      if (select.classList.contains('ql-align')) {\n        if (select.querySelector('option') == null) {\n          fillSelect(select, ALIGNS);\n        }\n        return new _iconPicker2.default(select, icons.align);\n      }\n      if (select.classList.contains('ql-background') || select.classList.contains('ql-color')) {\n        const format = select.classList.contains('ql-background') ? 'background' : 'color';\n        if (select.querySelector('option') == null) {\n          fillSelect(select, COLORS, format === 'background' ? '#ffffff' : '#000000');\n        }\n        return new _colorPicker2.default(select, icons[format]);\n      }\n      if (select.querySelector('option') == null) {\n        if (select.classList.contains('ql-font')) {\n          fillSelect(select, FONTS);\n        } else if (select.classList.contains('ql-header')) {\n          fillSelect(select, HEADERS);\n        } else if (select.classList.contains('ql-size')) {\n          fillSelect(select, SIZES);\n        }\n      }\n      return new _picker2.default(select);\n    });\n    const update = () => {\n      this.pickers.forEach(picker => {\n        picker.update();\n      });\n    };\n    this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);\n  }\n}\nBaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {\n  modules: {\n    toolbar: {\n      handlers: {\n        formula() {\n          this.quill.theme.tooltip.edit('formula');\n        },\n        image() {\n          let fileInput = this.container.querySelector('input.ql-image[type=file]');\n          if (fileInput == null) {\n            fileInput = document.createElement('input');\n            fileInput.setAttribute('type', 'file');\n            fileInput.setAttribute('accept', this.quill.uploader.options.mimetypes.join(', '));\n            fileInput.classList.add('ql-image');\n            fileInput.addEventListener('change', () => {\n              const range = this.quill.getSelection(true);\n              this.quill.uploader.upload(range, fileInput.files);\n              fileInput.value = '';\n            });\n            this.container.appendChild(fileInput);\n          }\n          fileInput.click();\n        },\n        video() {\n          this.quill.theme.tooltip.edit('video');\n        }\n      }\n    }\n  }\n});\n\nclass BaseTooltip extends _tooltip2.default {\n  constructor(quill, boundsContainer) {\n    super(quill, boundsContainer);\n    this.textbox = this.root.querySelector('input[type=\"text\"]');\n    this.listen();\n  }\n\n  listen() {\n    this.textbox.addEventListener('keydown', event => {\n      if (event.key === 'Enter') {\n        this.save();\n        event.preventDefault();\n      } else if (event.key === 'Escape') {\n        this.cancel();\n        event.preventDefault();\n      }\n    });\n  }\n\n  cancel() {\n    this.hide();\n  }\n\n  edit(mode = 'link', preview = null) {\n    this.root.classList.remove('ql-hidden');\n    this.root.classList.add('ql-editing');\n    if (preview != null) {\n      this.textbox.value = preview;\n    } else if (mode !== this.root.getAttribute('data-mode')) {\n      this.textbox.value = '';\n    }\n    this.position(this.quill.getBounds(this.quill.selection.savedRange));\n    this.textbox.select();\n    this.textbox.setAttribute('placeholder', this.textbox.getAttribute(`data-${mode}`) || '');\n    this.root.setAttribute('data-mode', mode);\n  }\n\n  restoreFocus() {\n    const scrollTop = this.quill.scrollingContainer.scrollTop;\n\n    this.quill.focus();\n    this.quill.scrollingContainer.scrollTop = scrollTop;\n  }\n\n  save() {\n    let value = this.textbox.value;\n\n    switch (this.root.getAttribute('data-mode')) {\n      case 'link':\n        {\n          const scrollTop = this.quill.root.scrollTop;\n\n          if (this.linkRange) {\n            this.quill.formatText(this.linkRange, 'link', value, _emitter2.default.sources.USER);\n            delete this.linkRange;\n          } else {\n            this.restoreFocus();\n            this.quill.format('link', value, _emitter2.default.sources.USER);\n          }\n          this.quill.root.scrollTop = scrollTop;\n          break;\n        }\n      case 'video':\n        {\n          value = extractVideoUrl(value);\n        } // eslint-disable-next-line no-fallthrough\n      case 'formula':\n        {\n          if (!value) break;\n          const range = this.quill.getSelection(true);\n          if (range != null) {\n            const index = range.index + range.length;\n            this.quill.insertEmbed(index, this.root.getAttribute('data-mode'), value, _emitter2.default.sources.USER);\n            if (this.root.getAttribute('data-mode') === 'formula') {\n              this.quill.insertText(index + 1, ' ', _emitter2.default.sources.USER);\n            }\n            this.quill.setSelection(index + 2, _emitter2.default.sources.USER);\n          }\n          break;\n        }\n      default:\n    }\n    this.textbox.value = '';\n    this.hide();\n  }\n}\n\nfunction extractVideoUrl(url) {\n  let match = url.match(/^(?:(https?):\\/\\/)?(?:(?:www|m)\\.)?youtube\\.com\\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\\/\\/)?(?:(?:www|m)\\.)?youtu\\.be\\/([a-zA-Z0-9_-]+)/);\n  if (match) {\n    return `${match[1] || 'https'}://www.youtube.com/embed/${match[2]}?showinfo=0`;\n  }\n  // eslint-disable-next-line no-cond-assign\n  if (match = url.match(/^(?:(https?):\\/\\/)?(?:www\\.)?vimeo\\.com\\/(\\d+)/)) {\n    return `${match[1] || 'https'}://player.vimeo.com/video/${match[2]}/`;\n  }\n  return url;\n}\n\nfunction fillSelect(select, values, defaultValue = false) {\n  values.forEach(value => {\n    const option = document.createElement('option');\n    if (value === defaultValue) {\n      option.setAttribute('selected', 'selected');\n    } else {\n      option.setAttribute('value', value);\n    }\n    select.appendChild(option);\n  });\n}\n\nexports.BaseTooltip = BaseTooltip;\nexports.default = BaseTheme;\n\n//# sourceURL=webpack://Quill/./themes/base.js?");
            /***/
          },

          /***/
          "./themes/bubble.js":
          /*!**************************!*\
            !*** ./themes/bubble.js ***!
            \**************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.BubbleTooltip = undefined;\n\nvar _extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _emitter = __webpack_require__(/*! ../core/emitter */ \"./core/emitter.js\");\n\nvar _emitter2 = _interopRequireDefault(_emitter);\n\nvar _base = __webpack_require__(/*! ./base */ \"./themes/base.js\");\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _selection = __webpack_require__(/*! ../core/selection */ \"./core/selection.js\");\n\nvar _icons = __webpack_require__(/*! ../ui/icons */ \"./ui/icons.js\");\n\nvar _icons2 = _interopRequireDefault(_icons);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst TOOLBAR_CONFIG = [['bold', 'italic', 'link'], [{ header: 1 }, { header: 2 }, 'blockquote']];\n\nclass BubbleTooltip extends _base.BaseTooltip {\n  constructor(quill, bounds) {\n    super(quill, bounds);\n    this.quill.on(_emitter2.default.events.EDITOR_CHANGE, (type, range, oldRange, source) => {\n      if (type !== _emitter2.default.events.SELECTION_CHANGE) return;\n      if (range != null && range.length > 0 && source === _emitter2.default.sources.USER) {\n        this.show();\n        // Lock our width so we will expand beyond our offsetParent boundaries\n        this.root.style.left = '0px';\n        this.root.style.width = '';\n        this.root.style.width = `${this.root.offsetWidth}px`;\n        const lines = this.quill.getLines(range.index, range.length);\n        if (lines.length === 1) {\n          this.position(this.quill.getBounds(range));\n        } else {\n          const lastLine = lines[lines.length - 1];\n          const index = this.quill.getIndex(lastLine);\n          const length = Math.min(lastLine.length() - 1, range.index + range.length - index);\n          const indexBounds = this.quill.getBounds(new _selection.Range(index, length));\n          this.position(indexBounds);\n        }\n      } else if (document.activeElement !== this.textbox && this.quill.hasFocus()) {\n        this.hide();\n      }\n    });\n  }\n\n  listen() {\n    super.listen();\n    this.root.querySelector('.ql-close').addEventListener('click', () => {\n      this.root.classList.remove('ql-editing');\n    });\n    this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, () => {\n      // Let selection be restored by toolbar handlers before repositioning\n      setTimeout(() => {\n        if (this.root.classList.contains('ql-hidden')) return;\n        const range = this.quill.getSelection();\n        if (range != null) {\n          this.position(this.quill.getBounds(range));\n        }\n      }, 1);\n    });\n  }\n\n  cancel() {\n    this.show();\n  }\n\n  position(reference) {\n    const shift = super.position(reference);\n    const arrow = this.root.querySelector('.ql-tooltip-arrow');\n    arrow.style.marginLeft = '';\n    if (shift !== 0) {\n      arrow.style.marginLeft = `${-1 * shift - arrow.offsetWidth / 2}px`;\n    }\n    return shift;\n  }\n}\nBubbleTooltip.TEMPLATE = ['<span class=\"ql-tooltip-arrow\"></span>', '<div class=\"ql-tooltip-editor\">', '<input type=\"text\" data-formula=\"e=mc^2\" data-link=\"https://quilljs.com\" data-video=\"Embed URL\">', '<a class=\"ql-close\"></a>', '</div>'].join('');\n\nclass BubbleTheme extends _base2.default {\n  constructor(quill, options) {\n    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {\n      options.modules.toolbar.container = TOOLBAR_CONFIG;\n    }\n    super(quill, options);\n    this.quill.container.classList.add('ql-bubble');\n  }\n\n  extendToolbar(toolbar) {\n    this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);\n    this.tooltip.root.appendChild(toolbar.container);\n    this.buildButtons(toolbar.container.querySelectorAll('button'), _icons2.default);\n    this.buildPickers(toolbar.container.querySelectorAll('select'), _icons2.default);\n  }\n}\nBubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {\n  modules: {\n    toolbar: {\n      handlers: {\n        link(value) {\n          if (!value) {\n            this.quill.format('link', false);\n          } else {\n            this.quill.theme.tooltip.edit();\n          }\n        }\n      }\n    }\n  }\n});\n\nexports.BubbleTooltip = BubbleTooltip;\nexports.default = BubbleTheme;\n\n//# sourceURL=webpack://Quill/./themes/bubble.js?");
            /***/
          },

          /***/
          "./themes/snow.js":
          /*!************************!*\
            !*** ./themes/snow.js ***!
            \************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _emitter = __webpack_require__(/*! ../core/emitter */ \"./core/emitter.js\");\n\nvar _emitter2 = _interopRequireDefault(_emitter);\n\nvar _base = __webpack_require__(/*! ./base */ \"./themes/base.js\");\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _link = __webpack_require__(/*! ../formats/link */ \"./formats/link.js\");\n\nvar _link2 = _interopRequireDefault(_link);\n\nvar _selection = __webpack_require__(/*! ../core/selection */ \"./core/selection.js\");\n\nvar _icons = __webpack_require__(/*! ../ui/icons */ \"./ui/icons.js\");\n\nvar _icons2 = _interopRequireDefault(_icons);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst TOOLBAR_CONFIG = [[{ header: ['1', '2', '3', false] }], ['bold', 'italic', 'underline', 'link'], [{ list: 'ordered' }, { list: 'bullet' }], ['clean']];\n\nclass SnowTooltip extends _base.BaseTooltip {\n  constructor(quill, bounds) {\n    super(quill, bounds);\n    this.preview = this.root.querySelector('a.ql-preview');\n  }\n\n  listen() {\n    super.listen();\n    this.root.querySelector('a.ql-action').addEventListener('click', event => {\n      if (this.root.classList.contains('ql-editing')) {\n        this.save();\n      } else {\n        this.edit('link', this.preview.textContent);\n      }\n      event.preventDefault();\n    });\n    this.root.querySelector('a.ql-remove').addEventListener('click', event => {\n      if (this.linkRange != null) {\n        const range = this.linkRange;\n        this.restoreFocus();\n        this.quill.formatText(range, 'link', false, _emitter2.default.sources.USER);\n        delete this.linkRange;\n      }\n      event.preventDefault();\n      this.hide();\n    });\n    this.quill.on(_emitter2.default.events.SELECTION_CHANGE, (range, oldRange, source) => {\n      if (range == null) return;\n      if (range.length === 0 && source === _emitter2.default.sources.USER) {\n        var _quill$scroll$descend = this.quill.scroll.descendant(_link2.default, range.index),\n            _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2);\n\n        const link = _quill$scroll$descend2[0],\n              offset = _quill$scroll$descend2[1];\n\n        if (link != null) {\n          this.linkRange = new _selection.Range(range.index - offset, link.length());\n          const preview = _link2.default.formats(link.domNode);\n          this.preview.textContent = preview;\n          this.preview.setAttribute('href', preview);\n          this.show();\n          this.position(this.quill.getBounds(this.linkRange));\n          return;\n        }\n      } else {\n        delete this.linkRange;\n      }\n      this.hide();\n    });\n  }\n\n  show() {\n    super.show();\n    this.root.removeAttribute('data-mode');\n  }\n}\nSnowTooltip.TEMPLATE = ['<a class=\"ql-preview\" target=\"_blank\" href=\"about:blank\"></a>', '<input type=\"text\" data-formula=\"e=mc^2\" data-link=\"https://quilljs.com\" data-video=\"Embed URL\">', '<a class=\"ql-action\"></a>', '<a class=\"ql-remove\"></a>'].join('');\n\nclass SnowTheme extends _base2.default {\n  constructor(quill, options) {\n    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {\n      options.modules.toolbar.container = TOOLBAR_CONFIG;\n    }\n    super(quill, options);\n    this.quill.container.classList.add('ql-snow');\n  }\n\n  extendToolbar(toolbar) {\n    toolbar.container.classList.add('ql-snow');\n    this.buildButtons(toolbar.container.querySelectorAll('button'), _icons2.default);\n    this.buildPickers(toolbar.container.querySelectorAll('select'), _icons2.default);\n    this.tooltip = new SnowTooltip(this.quill, this.options.bounds);\n    if (toolbar.container.querySelector('.ql-link')) {\n      this.quill.keyboard.addBinding({ key: 'k', shortKey: true }, (range, context) => {\n        toolbar.handlers.link.call(toolbar, !context.format.link);\n      });\n    }\n  }\n}\nSnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {\n  modules: {\n    toolbar: {\n      handlers: {\n        link(value) {\n          if (value) {\n            const range = this.quill.getSelection();\n            if (range == null || range.length === 0) return;\n            let preview = this.quill.getText(range);\n            if (/^\\S+@\\S+\\.\\S+$/.test(preview) && preview.indexOf('mailto:') !== 0) {\n              preview = `mailto:${preview}`;\n            }\n            const tooltip = this.quill.theme.tooltip;\n\n            tooltip.edit('link', preview);\n          } else {\n            this.quill.format('link', false);\n          }\n        }\n      }\n    }\n  }\n});\n\nexports.default = SnowTheme;\n\n//# sourceURL=webpack://Quill/./themes/snow.js?");
            /***/
          },

          /***/
          "./ui/color-picker.js":
          /*!****************************!*\
            !*** ./ui/color-picker.js ***!
            \****************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _picker = __webpack_require__(/*! ./picker */ \"./ui/picker.js\");\n\nvar _picker2 = _interopRequireDefault(_picker);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass ColorPicker extends _picker2.default {\n  constructor(select, label) {\n    super(select);\n    this.label.innerHTML = label;\n    this.container.classList.add('ql-color-picker');\n    Array.from(this.container.querySelectorAll('.ql-picker-item')).slice(0, 7).forEach(item => {\n      item.classList.add('ql-primary');\n    });\n  }\n\n  buildItem(option) {\n    const item = super.buildItem(option);\n    item.style.backgroundColor = option.getAttribute('value') || '';\n    return item;\n  }\n\n  selectItem(item, trigger) {\n    super.selectItem(item, trigger);\n    const colorLabel = this.label.querySelector('.ql-color-label');\n    const value = item ? item.getAttribute('data-value') || '' : '';\n    if (colorLabel) {\n      if (colorLabel.tagName === 'line') {\n        colorLabel.style.stroke = value;\n      } else {\n        colorLabel.style.fill = value;\n      }\n    }\n  }\n}\n\nexports.default = ColorPicker;\n\n//# sourceURL=webpack://Quill/./ui/color-picker.js?");
            /***/
          },

          /***/
          "./ui/icon-picker.js":
          /*!***************************!*\
            !*** ./ui/icon-picker.js ***!
            \***************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _picker = __webpack_require__(/*! ./picker */ \"./ui/picker.js\");\n\nvar _picker2 = _interopRequireDefault(_picker);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass IconPicker extends _picker2.default {\n  constructor(select, icons) {\n    super(select);\n    this.container.classList.add('ql-icon-picker');\n    Array.from(this.container.querySelectorAll('.ql-picker-item')).forEach(item => {\n      item.innerHTML = icons[item.getAttribute('data-value') || ''];\n    });\n    this.defaultItem = this.container.querySelector('.ql-selected');\n    this.selectItem(this.defaultItem);\n  }\n\n  selectItem(target, trigger) {\n    super.selectItem(target, trigger);\n    const item = target || this.defaultItem;\n    if (this.label.innerHTML === item.innerHTML) return;\n    this.label.innerHTML = item.innerHTML;\n  }\n}\n\nexports.default = IconPicker;\n\n//# sourceURL=webpack://Quill/./ui/icon-picker.js?");
            /***/
          },

          /***/
          "./ui/icons.js":
          /*!*********************!*\
            !*** ./ui/icons.js ***!
            \*********************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nvar _alignLeft = __webpack_require__(/*! ../assets/icons/align-left.svg */ \"./assets/icons/align-left.svg\");\n\nvar _alignLeft2 = _interopRequireDefault(_alignLeft);\n\nvar _alignCenter = __webpack_require__(/*! ../assets/icons/align-center.svg */ \"./assets/icons/align-center.svg\");\n\nvar _alignCenter2 = _interopRequireDefault(_alignCenter);\n\nvar _alignRight = __webpack_require__(/*! ../assets/icons/align-right.svg */ \"./assets/icons/align-right.svg\");\n\nvar _alignRight2 = _interopRequireDefault(_alignRight);\n\nvar _alignJustify = __webpack_require__(/*! ../assets/icons/align-justify.svg */ \"./assets/icons/align-justify.svg\");\n\nvar _alignJustify2 = _interopRequireDefault(_alignJustify);\n\nvar _background = __webpack_require__(/*! ../assets/icons/background.svg */ \"./assets/icons/background.svg\");\n\nvar _background2 = _interopRequireDefault(_background);\n\nvar _blockquote = __webpack_require__(/*! ../assets/icons/blockquote.svg */ \"./assets/icons/blockquote.svg\");\n\nvar _blockquote2 = _interopRequireDefault(_blockquote);\n\nvar _bold = __webpack_require__(/*! ../assets/icons/bold.svg */ \"./assets/icons/bold.svg\");\n\nvar _bold2 = _interopRequireDefault(_bold);\n\nvar _clean = __webpack_require__(/*! ../assets/icons/clean.svg */ \"./assets/icons/clean.svg\");\n\nvar _clean2 = _interopRequireDefault(_clean);\n\nvar _code = __webpack_require__(/*! ../assets/icons/code.svg */ \"./assets/icons/code.svg\");\n\nvar _code2 = _interopRequireDefault(_code);\n\nvar _color = __webpack_require__(/*! ../assets/icons/color.svg */ \"./assets/icons/color.svg\");\n\nvar _color2 = _interopRequireDefault(_color);\n\nvar _directionLtr = __webpack_require__(/*! ../assets/icons/direction-ltr.svg */ \"./assets/icons/direction-ltr.svg\");\n\nvar _directionLtr2 = _interopRequireDefault(_directionLtr);\n\nvar _directionRtl = __webpack_require__(/*! ../assets/icons/direction-rtl.svg */ \"./assets/icons/direction-rtl.svg\");\n\nvar _directionRtl2 = _interopRequireDefault(_directionRtl);\n\nvar _formula = __webpack_require__(/*! ../assets/icons/formula.svg */ \"./assets/icons/formula.svg\");\n\nvar _formula2 = _interopRequireDefault(_formula);\n\nvar _header = __webpack_require__(/*! ../assets/icons/header.svg */ \"./assets/icons/header.svg\");\n\nvar _header2 = _interopRequireDefault(_header);\n\nvar _header3 = __webpack_require__(/*! ../assets/icons/header-2.svg */ \"./assets/icons/header-2.svg\");\n\nvar _header4 = _interopRequireDefault(_header3);\n\nvar _italic = __webpack_require__(/*! ../assets/icons/italic.svg */ \"./assets/icons/italic.svg\");\n\nvar _italic2 = _interopRequireDefault(_italic);\n\nvar _image = __webpack_require__(/*! ../assets/icons/image.svg */ \"./assets/icons/image.svg\");\n\nvar _image2 = _interopRequireDefault(_image);\n\nvar _indent = __webpack_require__(/*! ../assets/icons/indent.svg */ \"./assets/icons/indent.svg\");\n\nvar _indent2 = _interopRequireDefault(_indent);\n\nvar _outdent = __webpack_require__(/*! ../assets/icons/outdent.svg */ \"./assets/icons/outdent.svg\");\n\nvar _outdent2 = _interopRequireDefault(_outdent);\n\nvar _link = __webpack_require__(/*! ../assets/icons/link.svg */ \"./assets/icons/link.svg\");\n\nvar _link2 = _interopRequireDefault(_link);\n\nvar _listBullet = __webpack_require__(/*! ../assets/icons/list-bullet.svg */ \"./assets/icons/list-bullet.svg\");\n\nvar _listBullet2 = _interopRequireDefault(_listBullet);\n\nvar _listCheck = __webpack_require__(/*! ../assets/icons/list-check.svg */ \"./assets/icons/list-check.svg\");\n\nvar _listCheck2 = _interopRequireDefault(_listCheck);\n\nvar _listOrdered = __webpack_require__(/*! ../assets/icons/list-ordered.svg */ \"./assets/icons/list-ordered.svg\");\n\nvar _listOrdered2 = _interopRequireDefault(_listOrdered);\n\nvar _subscript = __webpack_require__(/*! ../assets/icons/subscript.svg */ \"./assets/icons/subscript.svg\");\n\nvar _subscript2 = _interopRequireDefault(_subscript);\n\nvar _superscript = __webpack_require__(/*! ../assets/icons/superscript.svg */ \"./assets/icons/superscript.svg\");\n\nvar _superscript2 = _interopRequireDefault(_superscript);\n\nvar _strike = __webpack_require__(/*! ../assets/icons/strike.svg */ \"./assets/icons/strike.svg\");\n\nvar _strike2 = _interopRequireDefault(_strike);\n\nvar _table = __webpack_require__(/*! ../assets/icons/table.svg */ \"./assets/icons/table.svg\");\n\nvar _table2 = _interopRequireDefault(_table);\n\nvar _underline = __webpack_require__(/*! ../assets/icons/underline.svg */ \"./assets/icons/underline.svg\");\n\nvar _underline2 = _interopRequireDefault(_underline);\n\nvar _video = __webpack_require__(/*! ../assets/icons/video.svg */ \"./assets/icons/video.svg\");\n\nvar _video2 = _interopRequireDefault(_video);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = {\n  align: {\n    '': _alignLeft2.default,\n    center: _alignCenter2.default,\n    right: _alignRight2.default,\n    justify: _alignJustify2.default\n  },\n  background: _background2.default,\n  blockquote: _blockquote2.default,\n  bold: _bold2.default,\n  clean: _clean2.default,\n  code: _code2.default,\n  'code-block': _code2.default,\n  color: _color2.default,\n  direction: {\n    '': _directionLtr2.default,\n    rtl: _directionRtl2.default\n  },\n  formula: _formula2.default,\n  header: {\n    '1': _header2.default,\n    '2': _header4.default\n  },\n  italic: _italic2.default,\n  image: _image2.default,\n  indent: {\n    '+1': _indent2.default,\n    '-1': _outdent2.default\n  },\n  link: _link2.default,\n  list: {\n    bullet: _listBullet2.default,\n    check: _listCheck2.default,\n    ordered: _listOrdered2.default\n  },\n  script: {\n    sub: _subscript2.default,\n    super: _superscript2.default\n  },\n  strike: _strike2.default,\n  table: _table2.default,\n  underline: _underline2.default,\n  video: _video2.default\n};\n\n//# sourceURL=webpack://Quill/./ui/icons.js?");
            /***/
          },

          /***/
          "./ui/picker.js":
          /*!**********************!*\
            !*** ./ui/picker.js ***!
            \**********************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _dropdown = __webpack_require__(/*! ../assets/icons/dropdown.svg */ \"./assets/icons/dropdown.svg\");\n\nvar _dropdown2 = _interopRequireDefault(_dropdown);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nlet optionsCounter = 0;\n\nfunction toggleAriaAttribute(element, attribute) {\n  element.setAttribute(attribute, !(element.getAttribute(attribute) === 'true'));\n}\n\nclass Picker {\n  constructor(select) {\n    this.select = select;\n    this.container = document.createElement('span');\n    this.buildPicker();\n    this.select.style.display = 'none';\n    this.select.parentNode.insertBefore(this.container, this.select);\n\n    this.label.addEventListener('mousedown', () => {\n      this.togglePicker();\n    });\n    this.label.addEventListener('keydown', event => {\n      switch (event.key) {\n        case 'Enter':\n          this.togglePicker();\n          break;\n        case 'Escape':\n          this.escape();\n          event.preventDefault();\n          break;\n        default:\n      }\n    });\n    this.select.addEventListener('change', this.update.bind(this));\n  }\n\n  togglePicker() {\n    this.container.classList.toggle('ql-expanded');\n    // Toggle aria-expanded and aria-hidden to make the picker accessible\n    toggleAriaAttribute(this.label, 'aria-expanded');\n    toggleAriaAttribute(this.options, 'aria-hidden');\n  }\n\n  buildItem(option) {\n    const item = document.createElement('span');\n    item.tabIndex = '0';\n    item.setAttribute('role', 'button');\n    item.classList.add('ql-picker-item');\n    if (option.hasAttribute('value')) {\n      item.setAttribute('data-value', option.getAttribute('value'));\n    }\n    if (option.textContent) {\n      item.setAttribute('data-label', option.textContent);\n    }\n    item.addEventListener('click', () => {\n      this.selectItem(item, true);\n    });\n    item.addEventListener('keydown', event => {\n      switch (event.key) {\n        case 'Enter':\n          this.selectItem(item, true);\n          event.preventDefault();\n          break;\n        case 'Escape':\n          this.escape();\n          event.preventDefault();\n          break;\n        default:\n      }\n    });\n\n    return item;\n  }\n\n  buildLabel() {\n    const label = document.createElement('span');\n    label.classList.add('ql-picker-label');\n    label.innerHTML = _dropdown2.default;\n    label.tabIndex = '0';\n    label.setAttribute('role', 'button');\n    label.setAttribute('aria-expanded', 'false');\n    this.container.appendChild(label);\n    return label;\n  }\n\n  buildOptions() {\n    const options = document.createElement('span');\n    options.classList.add('ql-picker-options');\n\n    // Don't want screen readers to read this until options are visible\n    options.setAttribute('aria-hidden', 'true');\n    options.tabIndex = '-1';\n\n    // Need a unique id for aria-controls\n    options.id = `ql-picker-options-${optionsCounter}`;\n    optionsCounter += 1;\n    this.label.setAttribute('aria-controls', options.id);\n\n    this.options = options;\n\n    Array.from(this.select.options).forEach(option => {\n      const item = this.buildItem(option);\n      options.appendChild(item);\n      if (option.selected === true) {\n        this.selectItem(item);\n      }\n    });\n    this.container.appendChild(options);\n  }\n\n  buildPicker() {\n    Array.from(this.select.attributes).forEach(item => {\n      this.container.setAttribute(item.name, item.value);\n    });\n    this.container.classList.add('ql-picker');\n    this.label = this.buildLabel();\n    this.buildOptions();\n  }\n\n  escape() {\n    // Close menu and return focus to trigger label\n    this.close();\n    // Need setTimeout for accessibility to ensure that the browser executes\n    // focus on the next process thread and after any DOM content changes\n    setTimeout(() => this.label.focus(), 1);\n  }\n\n  close() {\n    this.container.classList.remove('ql-expanded');\n    this.label.setAttribute('aria-expanded', 'false');\n    this.options.setAttribute('aria-hidden', 'true');\n  }\n\n  selectItem(item, trigger = false) {\n    const selected = this.container.querySelector('.ql-selected');\n    if (item === selected) return;\n    if (selected != null) {\n      selected.classList.remove('ql-selected');\n    }\n    if (item == null) return;\n    item.classList.add('ql-selected');\n    this.select.selectedIndex = Array.from(item.parentNode.children).indexOf(item);\n    if (item.hasAttribute('data-value')) {\n      this.label.setAttribute('data-value', item.getAttribute('data-value'));\n    } else {\n      this.label.removeAttribute('data-value');\n    }\n    if (item.hasAttribute('data-label')) {\n      this.label.setAttribute('data-label', item.getAttribute('data-label'));\n    } else {\n      this.label.removeAttribute('data-label');\n    }\n    if (trigger) {\n      this.select.dispatchEvent(new Event('change'));\n      this.close();\n    }\n  }\n\n  update() {\n    let option;\n    if (this.select.selectedIndex > -1) {\n      const item = this.container.querySelector('.ql-picker-options').children[this.select.selectedIndex];\n      option = this.select.options[this.select.selectedIndex];\n      this.selectItem(item);\n    } else {\n      this.selectItem(null);\n    }\n    const isActive = option != null && option !== this.select.querySelector('option[selected]');\n    this.label.classList.toggle('ql-active', isActive);\n  }\n}\n\nexports.default = Picker;\n\n//# sourceURL=webpack://Quill/./ui/picker.js?");
            /***/
          },

          /***/
          "./ui/tooltip.js":
          /*!***********************!*\
            !*** ./ui/tooltip.js ***!
            \***********************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {

            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass Tooltip {\n  constructor(quill, boundsContainer) {\n    this.quill = quill;\n    this.boundsContainer = boundsContainer || document.body;\n    this.root = quill.addContainer('ql-tooltip');\n    this.root.innerHTML = this.constructor.TEMPLATE;\n    if (this.quill.root === this.quill.scrollingContainer) {\n      this.quill.root.addEventListener('scroll', () => {\n        this.root.style.marginTop = `${-1 * this.quill.root.scrollTop}px`;\n      });\n    }\n    this.hide();\n  }\n\n  hide() {\n    this.root.classList.add('ql-hidden');\n  }\n\n  position(reference) {\n    const left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;\n    // root.scrollTop should be 0 if scrollContainer !== root\n    const top = reference.bottom + this.quill.root.scrollTop;\n    this.root.style.left = `${left}px`;\n    this.root.style.top = `${top}px`;\n    this.root.classList.remove('ql-flip');\n    const containerBounds = this.boundsContainer.getBoundingClientRect();\n    const rootBounds = this.root.getBoundingClientRect();\n    let shift = 0;\n    if (rootBounds.right > containerBounds.right) {\n      shift = containerBounds.right - rootBounds.right;\n      this.root.style.left = `${left + shift}px`;\n    }\n    if (rootBounds.left < containerBounds.left) {\n      shift = containerBounds.left - rootBounds.left;\n      this.root.style.left = `${left + shift}px`;\n    }\n    if (rootBounds.bottom > containerBounds.bottom) {\n      const height = rootBounds.bottom - rootBounds.top;\n      const verticalShift = reference.bottom - reference.top + height;\n      this.root.style.top = `${top - verticalShift}px`;\n      this.root.classList.add('ql-flip');\n    }\n    return shift;\n  }\n\n  show() {\n    this.root.classList.remove('ql-editing');\n    this.root.classList.remove('ql-hidden');\n  }\n}\n\nexports.default = Tooltip;\n\n//# sourceURL=webpack://Quill/./ui/tooltip.js?");
            /***/
          },

          /***/
          0:
          /*!************************!*\
            !*** multi ./quill.js ***!
            \************************/

          /*! no static exports found */

          /***/
          function (module, exports, __webpack_require__) {
            eval("module.exports = __webpack_require__(/*! ./quill.js */\"./quill.js\");\n\n\n//# sourceURL=webpack://Quill/multi_./quill.js?");
            /***/
          }
          /******/

        })["default"]
      );
    });
    });

    var Quill = unwrapExports(quill);

    var quillBetterTable = createCommonjsModule(function (module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
      module.exports = factory(quill);
    })(window, function (__WEBPACK_EXTERNAL_MODULE__0__) {
      return (
        /******/
        function (modules) {
          // webpackBootstrap

          /******/
          function hotDisposeChunk(chunkId) {
            /******/
            delete installedChunks[chunkId];
            /******/
          }
          /******/


          var parentHotUpdateCallback = window["webpackHotUpdatequillBetterTable"];
          /******/

          window["webpackHotUpdatequillBetterTable"] = // eslint-disable-next-line no-unused-vars

          /******/
          function webpackHotUpdateCallback(chunkId, moreModules) {
            /******/
            hotAddUpdateChunk(chunkId, moreModules);
            /******/

            if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
            /******/
          };
          /******/

          /******/
          // eslint-disable-next-line no-unused-vars

          /******/


          function hotDownloadUpdateChunk(chunkId) {
            /******/
            var script = document.createElement("script");
            /******/

            script.charset = "utf-8";
            /******/

            script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
            /******/

            document.head.appendChild(script);
            /******/
          }
          /******/

          /******/
          // eslint-disable-next-line no-unused-vars

          /******/


          function hotDownloadManifest(requestTimeout) {
            /******/
            requestTimeout = requestTimeout || 10000;
            /******/

            return new Promise(function (resolve, reject) {
              /******/
              if (typeof XMLHttpRequest === "undefined") {
                /******/
                return reject(new Error("No browser support"));
                /******/
              }
              /******/


              try {
                /******/
                var request = new XMLHttpRequest();
                /******/

                var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
                /******/

                request.open("GET", requestPath, true);
                /******/

                request.timeout = requestTimeout;
                /******/

                request.send(null);
                /******/
              } catch (err) {
                /******/
                return reject(err);
                /******/
              }
              /******/


              request.onreadystatechange = function () {
                /******/
                if (request.readyState !== 4) return;
                /******/

                if (request.status === 0) {
                  /******/
                  // timeout

                  /******/
                  reject(
                  /******/
                  new Error("Manifest request to " + requestPath + " timed out.")
                  /******/
                  );
                  /******/
                } else if (request.status === 404) {
                  /******/
                  // no update available

                  /******/
                  resolve();
                  /******/
                } else if (request.status !== 200 && request.status !== 304) {
                  /******/
                  // other failure

                  /******/
                  reject(new Error("Manifest request to " + requestPath + " failed."));
                  /******/
                } else {
                  /******/
                  // success

                  /******/
                  try {
                    /******/
                    var update = JSON.parse(request.responseText);
                    /******/
                  } catch (e) {
                    /******/
                    reject(e);
                    /******/

                    return;
                    /******/
                  }
                  /******/


                  resolve(update);
                  /******/
                }
                /******/

              };
              /******/

            });
            /******/
          }
          /******/

          /******/


          var hotApplyOnUpdate = true;
          /******/
          // eslint-disable-next-line no-unused-vars

          /******/

          var hotCurrentHash = "b2ee69a9ed01aab8434c";
          /******/

          var hotRequestTimeout = 10000;
          /******/

          var hotCurrentModuleData = {};
          /******/

          var hotCurrentChildModule;
          /******/
          // eslint-disable-next-line no-unused-vars

          /******/

          var hotCurrentParents = [];
          /******/
          // eslint-disable-next-line no-unused-vars

          /******/

          var hotCurrentParentsTemp = [];
          /******/

          /******/
          // eslint-disable-next-line no-unused-vars

          /******/

          function hotCreateRequire(moduleId) {
            /******/
            var me = installedModules[moduleId];
            /******/

            if (!me) return __webpack_require__;
            /******/

            var fn = function (request) {
              /******/
              if (me.hot.active) {
                /******/
                if (installedModules[request]) {
                  /******/
                  if (installedModules[request].parents.indexOf(moduleId) === -1) {
                    /******/
                    installedModules[request].parents.push(moduleId);
                    /******/
                  }
                  /******/

                } else {
                  /******/
                  hotCurrentParents = [moduleId];
                  /******/

                  hotCurrentChildModule = request;
                  /******/
                }
                /******/


                if (me.children.indexOf(request) === -1) {
                  /******/
                  me.children.push(request);
                  /******/
                }
                /******/

              } else {
                /******/
                console.warn(
                /******/
                "[HMR] unexpected require(" +
                /******/
                request +
                /******/
                ") from disposed module " +
                /******/
                moduleId
                /******/
                );
                /******/

                hotCurrentParents = [];
                /******/
              }
              /******/


              return __webpack_require__(request);
              /******/
            };
            /******/


            var ObjectFactory = function ObjectFactory(name) {
              /******/
              return {
                /******/
                configurable: true,

                /******/
                enumerable: true,

                /******/
                get: function () {
                  /******/
                  return __webpack_require__[name];
                  /******/
                },

                /******/
                set: function (value) {
                  /******/
                  __webpack_require__[name] = value;
                  /******/
                }
                /******/

              };
              /******/
            };
            /******/


            for (var name in __webpack_require__) {
              /******/
              if (
              /******/
              Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
              /******/
              name !== "e" &&
              /******/
              name !== "t"
              /******/
              ) {
                  /******/
                  Object.defineProperty(fn, name, ObjectFactory(name));
                  /******/
                }
              /******/

            }
            /******/


            fn.e = function (chunkId) {
              /******/
              if (hotStatus === "ready") hotSetStatus("prepare");
              /******/

              hotChunksLoading++;
              /******/

              return __webpack_require__.e(chunkId).then(finishChunkLoading, function (err) {
                /******/
                finishChunkLoading();
                /******/

                throw err;
                /******/
              });
              /******/

              /******/

              function finishChunkLoading() {
                /******/
                hotChunksLoading--;
                /******/

                if (hotStatus === "prepare") {
                  /******/
                  if (!hotWaitingFilesMap[chunkId]) {
                    /******/
                    hotEnsureUpdateChunk(chunkId);
                    /******/
                  }
                  /******/


                  if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
                    /******/
                    hotUpdateDownloaded();
                    /******/
                  }
                  /******/

                }
                /******/

              }
              /******/

            };
            /******/


            fn.t = function (value, mode) {
              /******/
              if (mode & 1) value = fn(value);
              /******/

              return __webpack_require__.t(value, mode & ~1);
              /******/
            };
            /******/


            return fn;
            /******/
          }
          /******/

          /******/
          // eslint-disable-next-line no-unused-vars

          /******/


          function hotCreateModule(moduleId) {
            /******/
            var hot = {
              /******/
              // private stuff

              /******/
              _acceptedDependencies: {},

              /******/
              _declinedDependencies: {},

              /******/
              _selfAccepted: false,

              /******/
              _selfDeclined: false,

              /******/
              _disposeHandlers: [],

              /******/
              _main: hotCurrentChildModule !== moduleId,

              /******/

              /******/
              // Module API

              /******/
              active: true,

              /******/
              accept: function (dep, callback) {
                /******/
                if (dep === undefined) hot._selfAccepted = true;
                /******/
                else if (typeof dep === "function") hot._selfAccepted = dep;
                  /******/
                  else if (typeof dep === "object")
                      /******/
                      for (var i = 0; i < dep.length; i++)
                      /******/
                      hot._acceptedDependencies[dep[i]] = callback || function () {};
                      /******/
                    else hot._acceptedDependencies[dep] = callback || function () {};
                /******/
              },

              /******/
              decline: function (dep) {
                /******/
                if (dep === undefined) hot._selfDeclined = true;
                /******/
                else if (typeof dep === "object")
                    /******/
                    for (var i = 0; i < dep.length; i++)
                    /******/
                    hot._declinedDependencies[dep[i]] = true;
                    /******/
                  else hot._declinedDependencies[dep] = true;
                /******/
              },

              /******/
              dispose: function (callback) {
                /******/
                hot._disposeHandlers.push(callback);
                /******/

              },

              /******/
              addDisposeHandler: function (callback) {
                /******/
                hot._disposeHandlers.push(callback);
                /******/

              },

              /******/
              removeDisposeHandler: function (callback) {
                /******/
                var idx = hot._disposeHandlers.indexOf(callback);
                /******/


                if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
                /******/
              },

              /******/

              /******/
              // Management API

              /******/
              check: hotCheck,

              /******/
              apply: hotApply,

              /******/
              status: function (l) {
                /******/
                if (!l) return hotStatus;
                /******/

                hotStatusHandlers.push(l);
                /******/
              },

              /******/
              addStatusHandler: function (l) {
                /******/
                hotStatusHandlers.push(l);
                /******/
              },

              /******/
              removeStatusHandler: function (l) {
                /******/
                var idx = hotStatusHandlers.indexOf(l);
                /******/

                if (idx >= 0) hotStatusHandlers.splice(idx, 1);
                /******/
              },

              /******/

              /******/
              //inherit from previous dispose call

              /******/
              data: hotCurrentModuleData[moduleId]
              /******/

            };
            /******/

            hotCurrentChildModule = undefined;
            /******/

            return hot;
            /******/
          }
          /******/

          /******/


          var hotStatusHandlers = [];
          /******/

          var hotStatus = "idle";
          /******/

          /******/

          function hotSetStatus(newStatus) {
            /******/
            hotStatus = newStatus;
            /******/

            for (var i = 0; i < hotStatusHandlers.length; i++)
            /******/
            hotStatusHandlers[i].call(null, newStatus);
            /******/

          }
          /******/

          /******/
          // while downloading

          /******/


          var hotWaitingFiles = 0;
          /******/

          var hotChunksLoading = 0;
          /******/

          var hotWaitingFilesMap = {};
          /******/

          var hotRequestedFilesMap = {};
          /******/

          var hotAvailableFilesMap = {};
          /******/

          var hotDeferred;
          /******/

          /******/
          // The update info

          /******/

          var hotUpdate, hotUpdateNewHash;
          /******/

          /******/

          function toModuleId(id) {
            /******/
            var isNumber = +id + "" === id;
            /******/

            return isNumber ? +id : id;
            /******/
          }
          /******/

          /******/


          function hotCheck(apply) {
            /******/
            if (hotStatus !== "idle") {
              /******/
              throw new Error("check() is only allowed in idle status");
              /******/
            }
            /******/


            hotApplyOnUpdate = apply;
            /******/

            hotSetStatus("check");
            /******/

            return hotDownloadManifest(hotRequestTimeout).then(function (update) {
              /******/
              if (!update) {
                /******/
                hotSetStatus("idle");
                /******/

                return null;
                /******/
              }
              /******/


              hotRequestedFilesMap = {};
              /******/

              hotWaitingFilesMap = {};
              /******/

              hotAvailableFilesMap = update.c;
              /******/

              hotUpdateNewHash = update.h;
              /******/

              /******/

              hotSetStatus("prepare");
              /******/

              var promise = new Promise(function (resolve, reject) {
                /******/
                hotDeferred = {
                  /******/
                  resolve: resolve,

                  /******/
                  reject: reject
                  /******/

                };
                /******/
              });
              /******/

              hotUpdate = {};
              /******/

              var chunkId = 2;
              /******/
              // eslint-disable-next-line no-lone-blocks

              /******/

              {
                /******/

                /*globals chunkId */

                /******/
                hotEnsureUpdateChunk(chunkId);
                /******/
              }
              /******/

              if (
              /******/
              hotStatus === "prepare" &&
              /******/
              hotChunksLoading === 0 &&
              /******/
              hotWaitingFiles === 0
              /******/
              ) {
                  /******/
                  hotUpdateDownloaded();
                  /******/
                }
              /******/


              return promise;
              /******/
            });
            /******/
          }
          /******/

          /******/
          // eslint-disable-next-line no-unused-vars

          /******/


          function hotAddUpdateChunk(chunkId, moreModules) {
            /******/
            if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
              /******/
              return;
            /******/

            hotRequestedFilesMap[chunkId] = false;
            /******/

            for (var moduleId in moreModules) {
              /******/
              if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
                /******/
                hotUpdate[moduleId] = moreModules[moduleId];
                /******/
              }
              /******/

            }
            /******/


            if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
              /******/
              hotUpdateDownloaded();
              /******/
            }
            /******/

          }
          /******/

          /******/


          function hotEnsureUpdateChunk(chunkId) {
            /******/
            if (!hotAvailableFilesMap[chunkId]) {
              /******/
              hotWaitingFilesMap[chunkId] = true;
              /******/
            } else {
              /******/
              hotRequestedFilesMap[chunkId] = true;
              /******/

              hotWaitingFiles++;
              /******/

              hotDownloadUpdateChunk(chunkId);
              /******/
            }
            /******/

          }
          /******/

          /******/


          function hotUpdateDownloaded() {
            /******/
            hotSetStatus("ready");
            /******/

            var deferred = hotDeferred;
            /******/

            hotDeferred = null;
            /******/

            if (!deferred) return;
            /******/

            if (hotApplyOnUpdate) {
              /******/
              // Wrap deferred object in Promise to mark it as a well-handled Promise to

              /******/
              // avoid triggering uncaught exception warning in Chrome.

              /******/
              // See https://bugs.chromium.org/p/chromium/issues/detail?id=465666

              /******/
              Promise.resolve()
              /******/
              .then(function () {
                /******/
                return hotApply(hotApplyOnUpdate);
                /******/
              })
              /******/
              .then(
              /******/
              function (result) {
                /******/
                deferred.resolve(result);
                /******/
              },
              /******/
              function (err) {
                /******/
                deferred.reject(err);
                /******/
              }
              /******/
              );
              /******/
            } else {
              /******/
              var outdatedModules = [];
              /******/

              for (var id in hotUpdate) {
                /******/
                if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
                  /******/
                  outdatedModules.push(toModuleId(id));
                  /******/
                }
                /******/

              }
              /******/


              deferred.resolve(outdatedModules);
              /******/
            }
            /******/

          }
          /******/

          /******/


          function hotApply(options) {
            /******/
            if (hotStatus !== "ready")
              /******/
              throw new Error("apply() is only allowed in ready status");
            /******/

            options = options || {};
            /******/

            /******/

            var cb;
            /******/

            var i;
            /******/

            var j;
            /******/

            var module;
            /******/

            var moduleId;
            /******/

            /******/

            function getAffectedStuff(updateModuleId) {
              /******/
              var outdatedModules = [updateModuleId];
              /******/

              var outdatedDependencies = {};
              /******/

              /******/

              var queue = outdatedModules.map(function (id) {
                /******/
                return {
                  /******/
                  chain: [id],

                  /******/
                  id: id
                  /******/

                };
                /******/
              });
              /******/

              while (queue.length > 0) {
                /******/
                var queueItem = queue.pop();
                /******/

                var moduleId = queueItem.id;
                /******/

                var chain = queueItem.chain;
                /******/

                module = installedModules[moduleId];
                /******/

                if (!module || module.hot._selfAccepted) continue;
                /******/

                if (module.hot._selfDeclined) {
                  /******/
                  return {
                    /******/
                    type: "self-declined",

                    /******/
                    chain: chain,

                    /******/
                    moduleId: moduleId
                    /******/

                  };
                  /******/
                }
                /******/


                if (module.hot._main) {
                  /******/
                  return {
                    /******/
                    type: "unaccepted",

                    /******/
                    chain: chain,

                    /******/
                    moduleId: moduleId
                    /******/

                  };
                  /******/
                }
                /******/


                for (var i = 0; i < module.parents.length; i++) {
                  /******/
                  var parentId = module.parents[i];
                  /******/

                  var parent = installedModules[parentId];
                  /******/

                  if (!parent) continue;
                  /******/

                  if (parent.hot._declinedDependencies[moduleId]) {
                    /******/
                    return {
                      /******/
                      type: "declined",

                      /******/
                      chain: chain.concat([parentId]),

                      /******/
                      moduleId: moduleId,

                      /******/
                      parentId: parentId
                      /******/

                    };
                    /******/
                  }
                  /******/


                  if (outdatedModules.indexOf(parentId) !== -1) continue;
                  /******/

                  if (parent.hot._acceptedDependencies[moduleId]) {
                    /******/
                    if (!outdatedDependencies[parentId])
                      /******/
                      outdatedDependencies[parentId] = [];
                    /******/

                    addAllToSet(outdatedDependencies[parentId], [moduleId]);
                    /******/

                    continue;
                    /******/
                  }
                  /******/


                  delete outdatedDependencies[parentId];
                  /******/

                  outdatedModules.push(parentId);
                  /******/

                  queue.push({
                    /******/
                    chain: chain.concat([parentId]),

                    /******/
                    id: parentId
                    /******/

                  });
                  /******/
                }
                /******/

              }
              /******/

              /******/


              return {
                /******/
                type: "accepted",

                /******/
                moduleId: updateModuleId,

                /******/
                outdatedModules: outdatedModules,

                /******/
                outdatedDependencies: outdatedDependencies
                /******/

              };
              /******/
            }
            /******/

            /******/


            function addAllToSet(a, b) {
              /******/
              for (var i = 0; i < b.length; i++) {
                /******/
                var item = b[i];
                /******/

                if (a.indexOf(item) === -1) a.push(item);
                /******/
              }
              /******/

            }
            /******/

            /******/
            // at begin all updates modules are outdated

            /******/
            // the "outdated" status can propagate to parents if they don't accept the children

            /******/


            var outdatedDependencies = {};
            /******/

            var outdatedModules = [];
            /******/

            var appliedUpdate = {};
            /******/

            /******/

            var warnUnexpectedRequire = function warnUnexpectedRequire() {
              /******/
              console.warn(
              /******/
              "[HMR] unexpected require(" + result.moduleId + ") to disposed module"
              /******/
              );
              /******/
            };
            /******/

            /******/


            for (var id in hotUpdate) {
              /******/
              if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
                /******/
                moduleId = toModuleId(id);
                /******/

                /** @type {TODO} */

                /******/

                var result;
                /******/

                if (hotUpdate[id]) {
                  /******/
                  result = getAffectedStuff(moduleId);
                  /******/
                } else {
                  /******/
                  result = {
                    /******/
                    type: "disposed",

                    /******/
                    moduleId: id
                    /******/

                  };
                  /******/
                }
                /******/

                /** @type {Error|false} */

                /******/


                var abortError = false;
                /******/

                var doApply = false;
                /******/

                var doDispose = false;
                /******/

                var chainInfo = "";
                /******/

                if (result.chain) {
                  /******/
                  chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
                  /******/
                }
                /******/


                switch (result.type) {
                  /******/
                  case "self-declined":
                    /******/
                    if (options.onDeclined) options.onDeclined(result);
                    /******/

                    if (!options.ignoreDeclined)
                      /******/
                      abortError = new Error(
                      /******/
                      "Aborted because of self decline: " +
                      /******/
                      result.moduleId +
                      /******/
                      chainInfo
                      /******/
                      );
                    /******/

                    break;

                  /******/

                  case "declined":
                    /******/
                    if (options.onDeclined) options.onDeclined(result);
                    /******/

                    if (!options.ignoreDeclined)
                      /******/
                      abortError = new Error(
                      /******/
                      "Aborted because of declined dependency: " +
                      /******/
                      result.moduleId +
                      /******/
                      " in " +
                      /******/
                      result.parentId +
                      /******/
                      chainInfo
                      /******/
                      );
                    /******/

                    break;

                  /******/

                  case "unaccepted":
                    /******/
                    if (options.onUnaccepted) options.onUnaccepted(result);
                    /******/

                    if (!options.ignoreUnaccepted)
                      /******/
                      abortError = new Error(
                      /******/
                      "Aborted because " + moduleId + " is not accepted" + chainInfo
                      /******/
                      );
                    /******/

                    break;

                  /******/

                  case "accepted":
                    /******/
                    if (options.onAccepted) options.onAccepted(result);
                    /******/

                    doApply = true;
                    /******/

                    break;

                  /******/

                  case "disposed":
                    /******/
                    if (options.onDisposed) options.onDisposed(result);
                    /******/

                    doDispose = true;
                    /******/

                    break;

                  /******/

                  default:
                    /******/
                    throw new Error("Unexception type " + result.type);

                  /******/
                }
                /******/


                if (abortError) {
                  /******/
                  hotSetStatus("abort");
                  /******/

                  return Promise.reject(abortError);
                  /******/
                }
                /******/


                if (doApply) {
                  /******/
                  appliedUpdate[moduleId] = hotUpdate[moduleId];
                  /******/

                  addAllToSet(outdatedModules, result.outdatedModules);
                  /******/

                  for (moduleId in result.outdatedDependencies) {
                    /******/
                    if (
                    /******/
                    Object.prototype.hasOwnProperty.call(
                    /******/
                    result.outdatedDependencies,
                    /******/
                    moduleId
                    /******/
                    )
                    /******/
                    ) {
                        /******/
                        if (!outdatedDependencies[moduleId])
                          /******/
                          outdatedDependencies[moduleId] = [];
                        /******/

                        addAllToSet(
                        /******/
                        outdatedDependencies[moduleId],
                        /******/
                        result.outdatedDependencies[moduleId]
                        /******/
                        );
                        /******/
                      }
                    /******/

                  }
                  /******/

                }
                /******/


                if (doDispose) {
                  /******/
                  addAllToSet(outdatedModules, [result.moduleId]);
                  /******/

                  appliedUpdate[moduleId] = warnUnexpectedRequire;
                  /******/
                }
                /******/

              }
              /******/

            }
            /******/

            /******/
            // Store self accepted outdated modules to require them later by the module system

            /******/


            var outdatedSelfAcceptedModules = [];
            /******/

            for (i = 0; i < outdatedModules.length; i++) {
              /******/
              moduleId = outdatedModules[i];
              /******/

              if (
              /******/
              installedModules[moduleId] &&
              /******/
              installedModules[moduleId].hot._selfAccepted &&
              /******/
              // removed self-accepted modules should not be required

              /******/
              appliedUpdate[moduleId] !== warnUnexpectedRequire
              /******/
              ) {
                  /******/
                  outdatedSelfAcceptedModules.push({
                    /******/
                    module: moduleId,

                    /******/
                    errorHandler: installedModules[moduleId].hot._selfAccepted
                    /******/

                  });
                  /******/
                }
              /******/

            }
            /******/

            /******/
            // Now in "dispose" phase

            /******/


            hotSetStatus("dispose");
            /******/

            Object.keys(hotAvailableFilesMap).forEach(function (chunkId) {
              /******/
              if (hotAvailableFilesMap[chunkId] === false) {
                /******/
                hotDisposeChunk(chunkId);
                /******/
              }
              /******/

            });
            /******/

            /******/

            var idx;
            /******/

            var queue = outdatedModules.slice();
            /******/

            while (queue.length > 0) {
              /******/
              moduleId = queue.pop();
              /******/

              module = installedModules[moduleId];
              /******/

              if (!module) continue;
              /******/

              /******/

              var data = {};
              /******/

              /******/
              // Call dispose handlers

              /******/

              var disposeHandlers = module.hot._disposeHandlers;
              /******/

              for (j = 0; j < disposeHandlers.length; j++) {
                /******/
                cb = disposeHandlers[j];
                /******/

                cb(data);
                /******/
              }
              /******/


              hotCurrentModuleData[moduleId] = data;
              /******/

              /******/
              // disable module (this disables requires from this module)

              /******/

              module.hot.active = false;
              /******/

              /******/
              // remove module from cache

              /******/

              delete installedModules[moduleId];
              /******/

              /******/
              // when disposing there is no need to call dispose handler

              /******/

              delete outdatedDependencies[moduleId];
              /******/

              /******/
              // remove "parents" references from all children

              /******/

              for (j = 0; j < module.children.length; j++) {
                /******/
                var child = installedModules[module.children[j]];
                /******/

                if (!child) continue;
                /******/

                idx = child.parents.indexOf(moduleId);
                /******/

                if (idx >= 0) {
                  /******/
                  child.parents.splice(idx, 1);
                  /******/
                }
                /******/

              }
              /******/

            }
            /******/

            /******/
            // remove outdated dependency from module children

            /******/


            var dependency;
            /******/

            var moduleOutdatedDependencies;
            /******/

            for (moduleId in outdatedDependencies) {
              /******/
              if (
              /******/
              Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
              /******/
              ) {
                  /******/
                  module = installedModules[moduleId];
                  /******/

                  if (module) {
                    /******/
                    moduleOutdatedDependencies = outdatedDependencies[moduleId];
                    /******/

                    for (j = 0; j < moduleOutdatedDependencies.length; j++) {
                      /******/
                      dependency = moduleOutdatedDependencies[j];
                      /******/

                      idx = module.children.indexOf(dependency);
                      /******/

                      if (idx >= 0) module.children.splice(idx, 1);
                      /******/
                    }
                    /******/

                  }
                  /******/

                }
              /******/

            }
            /******/

            /******/
            // Now in "apply" phase

            /******/


            hotSetStatus("apply");
            /******/

            /******/

            hotCurrentHash = hotUpdateNewHash;
            /******/

            /******/
            // insert new code

            /******/

            for (moduleId in appliedUpdate) {
              /******/
              if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
                /******/
                modules[moduleId] = appliedUpdate[moduleId];
                /******/
              }
              /******/

            }
            /******/

            /******/
            // call accept handlers

            /******/


            var error = null;
            /******/

            for (moduleId in outdatedDependencies) {
              /******/
              if (
              /******/
              Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
              /******/
              ) {
                  /******/
                  module = installedModules[moduleId];
                  /******/

                  if (module) {
                    /******/
                    moduleOutdatedDependencies = outdatedDependencies[moduleId];
                    /******/

                    var callbacks = [];
                    /******/

                    for (i = 0; i < moduleOutdatedDependencies.length; i++) {
                      /******/
                      dependency = moduleOutdatedDependencies[i];
                      /******/

                      cb = module.hot._acceptedDependencies[dependency];
                      /******/

                      if (cb) {
                        /******/
                        if (callbacks.indexOf(cb) !== -1) continue;
                        /******/

                        callbacks.push(cb);
                        /******/
                      }
                      /******/

                    }
                    /******/


                    for (i = 0; i < callbacks.length; i++) {
                      /******/
                      cb = callbacks[i];
                      /******/

                      try {
                        /******/
                        cb(moduleOutdatedDependencies);
                        /******/
                      } catch (err) {
                        /******/
                        if (options.onErrored) {
                          /******/
                          options.onErrored({
                            /******/
                            type: "accept-errored",

                            /******/
                            moduleId: moduleId,

                            /******/
                            dependencyId: moduleOutdatedDependencies[i],

                            /******/
                            error: err
                            /******/

                          });
                          /******/
                        }
                        /******/


                        if (!options.ignoreErrored) {
                          /******/
                          if (!error) error = err;
                          /******/
                        }
                        /******/

                      }
                      /******/

                    }
                    /******/

                  }
                  /******/

                }
              /******/

            }
            /******/

            /******/
            // Load self accepted modules

            /******/


            for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
              /******/
              var item = outdatedSelfAcceptedModules[i];
              /******/

              moduleId = item.module;
              /******/

              hotCurrentParents = [moduleId];
              /******/

              try {
                /******/
                __webpack_require__(moduleId);
                /******/

              } catch (err) {
                /******/
                if (typeof item.errorHandler === "function") {
                  /******/
                  try {
                    /******/
                    item.errorHandler(err);
                    /******/
                  } catch (err2) {
                    /******/
                    if (options.onErrored) {
                      /******/
                      options.onErrored({
                        /******/
                        type: "self-accept-error-handler-errored",

                        /******/
                        moduleId: moduleId,

                        /******/
                        error: err2,

                        /******/
                        originalError: err
                        /******/

                      });
                      /******/
                    }
                    /******/


                    if (!options.ignoreErrored) {
                      /******/
                      if (!error) error = err2;
                      /******/
                    }
                    /******/


                    if (!error) error = err;
                    /******/
                  }
                  /******/

                } else {
                  /******/
                  if (options.onErrored) {
                    /******/
                    options.onErrored({
                      /******/
                      type: "self-accept-errored",

                      /******/
                      moduleId: moduleId,

                      /******/
                      error: err
                      /******/

                    });
                    /******/
                  }
                  /******/


                  if (!options.ignoreErrored) {
                    /******/
                    if (!error) error = err;
                    /******/
                  }
                  /******/

                }
                /******/

              }
              /******/

            }
            /******/

            /******/
            // handle errors in accept handlers and self accepted module load

            /******/


            if (error) {
              /******/
              hotSetStatus("fail");
              /******/

              return Promise.reject(error);
              /******/
            }
            /******/

            /******/


            hotSetStatus("idle");
            /******/

            return new Promise(function (resolve) {
              /******/
              resolve(outdatedModules);
              /******/
            });
            /******/
          }
          /******/

          /******/
          // The module cache

          /******/


          var installedModules = {};
          /******/

          /******/
          // The require function

          /******/

          function __webpack_require__(moduleId) {
            /******/

            /******/
            // Check if module is in cache

            /******/
            if (installedModules[moduleId]) {
              /******/
              return installedModules[moduleId].exports;
              /******/
            }
            /******/
            // Create a new module (and put it into the cache)

            /******/


            var module = installedModules[moduleId] = {
              /******/
              i: moduleId,

              /******/
              l: false,

              /******/
              exports: {},

              /******/
              hot: hotCreateModule(moduleId),

              /******/
              parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),

              /******/
              children: []
              /******/

            };
            /******/

            /******/
            // Execute the module function

            /******/

            modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
            /******/

            /******/
            // Flag the module as loaded

            /******/

            module.l = true;
            /******/

            /******/
            // Return the exports of the module

            /******/

            return module.exports;
            /******/
          }
          /******/

          /******/

          /******/
          // expose the modules object (__webpack_modules__)

          /******/


          __webpack_require__.m = modules;
          /******/

          /******/
          // expose the module cache

          /******/

          __webpack_require__.c = installedModules;
          /******/

          /******/
          // define getter function for harmony exports

          /******/

          __webpack_require__.d = function (exports, name, getter) {
            /******/
            if (!__webpack_require__.o(exports, name)) {
              /******/
              Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
              });
              /******/
            }
            /******/

          };
          /******/

          /******/
          // define __esModule on exports

          /******/


          __webpack_require__.r = function (exports) {
            /******/
            if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /******/
              Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
              });
              /******/
            }
            /******/


            Object.defineProperty(exports, '__esModule', {
              value: true
            });
            /******/
          };
          /******/

          /******/
          // create a fake namespace object

          /******/
          // mode & 1: value is a module id, require it

          /******/
          // mode & 2: merge all properties of value into the ns

          /******/
          // mode & 4: return value when already ns object

          /******/
          // mode & 8|1: behave like require

          /******/


          __webpack_require__.t = function (value, mode) {
            /******/
            if (mode & 1) value = __webpack_require__(value);
            /******/

            if (mode & 8) return value;
            /******/

            if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
            /******/

            var ns = Object.create(null);
            /******/

            __webpack_require__.r(ns);
            /******/


            Object.defineProperty(ns, 'default', {
              enumerable: true,
              value: value
            });
            /******/

            if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {
              return value[key];
            }.bind(null, key));
            /******/

            return ns;
            /******/
          };
          /******/

          /******/
          // getDefaultExport function for compatibility with non-harmony modules

          /******/


          __webpack_require__.n = function (module) {
            /******/
            var getter = module && module.__esModule ?
            /******/
            function getDefault() {
              return module['default'];
            } :
            /******/
            function getModuleExports() {
              return module;
            };
            /******/

            __webpack_require__.d(getter, 'a', getter);
            /******/


            return getter;
            /******/
          };
          /******/

          /******/
          // Object.prototype.hasOwnProperty.call

          /******/


          __webpack_require__.o = function (object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          /******/

          /******/
          // __webpack_public_path__

          /******/


          __webpack_require__.p = "";
          /******/

          /******/
          // __webpack_hash__

          /******/

          __webpack_require__.h = function () {
            return hotCurrentHash;
          };
          /******/

          /******/

          /******/
          // Load entry module and return exports

          /******/


          return hotCreateRequire(12)(__webpack_require__.s = 12);
          /******/
        }(
        /************************************************************************/

        /******/
        [
        /* 0 */

        /***/
        function (module, exports) {
          module.exports = __WEBPACK_EXTERNAL_MODULE__0__;
          /***/
        },
        /* 1 */

        /***/
        function (module, exports) {
          module.exports = "<?xml version=\"1.0\" standalone=\"no\"?><!doctype html><svg class=icon width=20px height=20px viewBox=\"0 0 1024 1024\" version=1.1 xmlns=http://www.w3.org/2000/svg><path fill=#595959 d=\"M73.142857 336.64h526.628572v43.885714H73.142857zM73.142857 643.657143h526.628572v43.885714H73.142857zM336.457143 117.028571h43.885714v789.942858h-43.885714zM204.8 73.142857h614.4a131.657143 131.657143 0 0 1 131.657143 131.657143v614.4a131.657143 131.657143 0 0 1-131.657143 131.657143H204.8A131.657143 131.657143 0 0 1 73.142857 819.2V204.8A131.84 131.84 0 0 1 204.8 73.142857z m0 43.885714a87.771429 87.771429 0 0 0-87.771429 87.771429v614.4a87.771429 87.771429 0 0 0 87.771429 87.771429h614.4a87.771429 87.771429 0 0 0 87.771429-87.771429V204.8a87.771429 87.771429 0 0 0-87.771429-87.771429zM819.2 73.142857h-219.428571v877.714286h219.428571a131.657143 131.657143 0 0 0 131.657143-131.657143V204.8A131.84 131.84 0 0 0 819.2 73.142857z m44.068571 460.982857h-65.828571v65.828572H753.371429v-65.828572h-65.828572V490.057143h65.828572v-65.828572h44.068571v65.828572h65.828571z\"/></svg>";
          /***/
        },
        /* 2 */

        /***/
        function (module, exports) {
          module.exports = "<?xml version=\"1.0\" standalone=\"no\"?><!doctype html><svg class=icon width=20px height=20.00px viewBox=\"0 0 1024 1024\" version=1.1 xmlns=http://www.w3.org/2000/svg><path fill=#595959 d=\"M380.342857 336.457143h526.811429v43.885714H380.342857z m0 307.2h526.811429v43.885714H380.342857zM643.657143 117.028571h43.885714v789.942858h-43.885714zM204.8 73.142857h614.582857A131.474286 131.474286 0 0 1 950.857143 204.8v614.4a131.657143 131.657143 0 0 1-131.657143 131.657143H204.8A131.657143 131.657143 0 0 1 73.142857 819.2V204.8A131.657143 131.657143 0 0 1 204.8 73.142857z m0 43.885714a87.588571 87.588571 0 0 0-87.588571 87.771429v614.4a87.588571 87.588571 0 0 0 87.588571 87.771429h614.582857a87.771429 87.771429 0 0 0 87.771429-87.771429V204.8a87.771429 87.771429 0 0 0-87.771429-87.771429zM204.8 73.142857A131.657143 131.657143 0 0 0 73.142857 204.8v614.4a131.657143 131.657143 0 0 0 131.657143 131.657143h219.428571V73.142857z m131.84 460.8h-65.828571v65.828572h-43.885715v-65.828572h-65.828571v-43.885714h65.828571v-65.828572h43.885715v65.828572h65.828571z\"/></svg>";
          /***/
        },
        /* 3 */

        /***/
        function (module, exports) {
          module.exports = "<?xml version=\"1.0\" standalone=\"no\"?><!doctype html><svg class=icon width=20px height=20.00px viewBox=\"0 0 1024 1024\" version=1.1 xmlns=http://www.w3.org/2000/svg><path fill=#595959 d=\"M73.142857 599.771429h877.714286v43.885714H73.142857zM336.457143 380.342857h43.885714v526.628572h-43.885714z m307.2 0h43.885714v526.628572h-43.885714zM204.8 73.142857h614.4a131.657143 131.657143 0 0 1 131.657143 131.657143v614.4a131.657143 131.657143 0 0 1-131.657143 131.657143H204.8A131.657143 131.657143 0 0 1 73.142857 819.2V204.8A131.657143 131.657143 0 0 1 204.8 73.142857z m0 43.885714a87.771429 87.771429 0 0 0-87.771429 87.771429v614.4a87.588571 87.588571 0 0 0 87.771429 87.771429h614.4a87.588571 87.588571 0 0 0 87.771429-87.771429V204.8a87.771429 87.771429 0 0 0-87.771429-87.771429zM819.2 73.142857H204.8A131.657143 131.657143 0 0 0 73.142857 204.8v219.428571h877.714286v-219.428571A131.657143 131.657143 0 0 0 819.2 73.142857z m-219.428571 197.485714h-65.828572v65.828572h-43.885714v-65.828572h-65.828572v-43.885714h65.828572V160.914286h43.885714v65.828571h65.828572z\"/></svg>";
          /***/
        },
        /* 4 */

        /***/
        function (module, exports) {
          module.exports = "<?xml version=\"1.0\" standalone=\"no\"?><!doctype html><svg class=icon width=20px height=20.00px viewBox=\"0 0 1024 1024\" version=1.1 xmlns=http://www.w3.org/2000/svg><path fill=#595959 d=\"M204.8 73.142857h614.4a131.657143 131.657143 0 0 1 131.657143 131.657143v614.4a131.657143 131.657143 0 0 1-131.657143 131.657143H204.8A131.657143 131.657143 0 0 1 73.142857 819.2V204.8A131.84 131.84 0 0 1 204.8 73.142857z m0 43.885714a87.771429 87.771429 0 0 0-87.771429 87.771429v614.4a87.771429 87.771429 0 0 0 87.771429 87.771429h614.4a87.771429 87.771429 0 0 0 87.771429-87.771429V204.8a87.771429 87.771429 0 0 0-87.771429-87.771429zM73.142857 336.457143h877.714286v44.068571H73.142857zM336.64 117.028571h43.885714v526.628572h-43.885714z m307.017143 0h44.068571v526.628572H643.657143zM73.142857 599.771429v219.428571a131.657143 131.657143 0 0 0 131.657143 131.657143h614.4a131.657143 131.657143 0 0 0 131.657143-131.657143v-219.428571z m526.628572 197.485714h-65.645715v65.828571H490.057143v-65.828571h-65.828572v-43.885714h65.828572v-65.828572h44.068571v65.828572h65.645715z\"/></svg>";
          /***/
        },
        /* 5 */

        /***/
        function (module, exports) {
          module.exports = "<?xml version=\"1.0\" standalone=\"no\"?><!doctype html><svg class=icon width=20px height=20.00px viewBox=\"0 0 1024 1024\" version=1.1 xmlns=http://www.w3.org/2000/svg><path fill=#595959 d=\"M925.99596 99.038384c-25.470707-25.6-60.121212-39.822222-96.323233-39.822222H194.19798c-36.072727 0-70.723232 14.351515-96.323233 39.822222-25.6 25.6-39.822222 60.121212-39.822222 96.323232v635.474748c0 36.072727 14.351515 70.723232 39.822222 96.323232C123.474747 952.759596 158.125253 967.111111 194.19798 967.111111h635.474747c36.072727 0 70.723232-14.351515 96.323233-39.951515 25.6-25.6 39.951515-60.121212 39.951515-96.323232V195.361616c0-36.072727-14.351515-70.723232-39.951515-96.323232z m-277.850505 5.559596v226.909091H375.725253V104.59798h272.420202zM103.434343 195.361616c0-24.048485 9.567677-47.191919 26.634344-64.129293 17.066667-17.066667 40.080808-26.634343 64.129293-26.634343h136.145454v226.909091H103.434343V195.361616z m90.763637 726.367677c-24.048485 0-47.191919-9.567677-64.129293-26.634344-17.066667-17.066667-26.634343-40.080808-26.634344-64.129292V649.309091h226.909091v272.420202H194.19798z m181.527273 0V649.309091h272.290909v272.420202H375.725253z m544.711111-90.892929c0 24.048485-9.567677 47.191919-26.634344 64.129293-17.066667 17.066667-40.080808 26.634343-64.129293 26.634343H693.527273V649.309091h226.909091v181.527273zM693.527273 331.507071V104.59798h136.145454c24.048485 0 47.191919 9.567677 64.129293 26.634343 17.066667 17.066667 26.634343 40.080808 26.634344 64.129293v136.145455H693.527273z\"/></svg>";
          /***/
        },
        /* 6 */

        /***/
        function (module, exports) {
          module.exports = "<?xml version=\"1.0\" standalone=\"no\"?><!doctype html><svg class=icon width=20px height=20.00px viewBox=\"0 0 1024 1024\" version=1.1 xmlns=http://www.w3.org/2000/svg><path fill=#595959 d=\"M336.457143 73.142857h43.885714v877.714286h-43.885714z m307.382857 0h43.702857v877.714286h-43.702857z m-438.857143 0h614.4A131.657143 131.657143 0 0 1 950.857143 204.8v614.4a131.474286 131.474286 0 0 1-131.474286 131.657143h-614.4A131.657143 131.657143 0 0 1 73.142857 819.2V204.8A131.84 131.84 0 0 1 204.982857 73.142857z m0 43.885714a87.588571 87.588571 0 0 0-87.771428 87.771429v614.4a87.588571 87.588571 0 0 0 87.771428 87.771429h614.4a87.771429 87.771429 0 0 0 87.771429-87.771429V204.8a87.771429 87.771429 0 0 0-87.771429-87.771429zM73.142857 336.457143h877.714286v307.2H73.142857z m292.571429 43.885714v219.428572h292.571428v-219.428572z\"/></svg>";
          /***/
        },
        /* 7 */

        /***/
        function (module, exports) {
          module.exports = "<?xml version=\"1.0\" standalone=\"no\"?><!doctype html><svg class=icon width=20px height=20.00px viewBox=\"0 0 1024 1024\" version=1.1 xmlns=http://www.w3.org/2000/svg><path fill=#595959 d=\"M925.996 99.038c-25.47-25.6-60.121-39.822-96.323-39.822H194.198c-75.12 0.13-136.016 61.026-136.145 136.146v635.345c0 36.073 14.351 70.723 39.822 96.323 25.6 25.73 60.25 40.081 96.323 40.081h635.475c36.072 0 70.723-14.351 96.323-39.951 25.6-25.6 39.951-60.122 39.951-96.324V195.362c0-36.073-14.351-70.724-39.951-96.324z m-365.77 494.287L512 545.228l-48.226 48.097-32.194-31.935 48.355-48.226-48.226-48.097 32.194-32.194L512 480.97l48.097-48.097 32.194 32.194-48.097 48.097 48.226 48.226-32.194 31.935zM103.434 195.362c0-24.049 9.568-47.192 26.635-64.13 17.066-17.066 40.08-26.634 64.129-26.634h136.145v226.91H103.434V195.361z m0 181.656h226.91V649.31h-226.91V377.02z m90.764 544.84c-24.049 0-47.192-9.567-64.13-26.634-17.066-17.066-26.634-40.08-26.634-64.258V694.69h226.91v227.168H194.197z m726.238-90.763c0 24.048-9.438 47.192-26.505 64.259-17.066 17.066-40.21 26.634-64.258 26.505H693.527V694.69h226.91v136.404z m0-181.786H693.527V377.02h226.91v272.29zM693.527 331.507V104.598h136.146c24.048 0 47.192 9.438 64.258 26.505 17.067 17.067 26.635 40.21 26.505 64.259v136.145H693.527z\"/></svg>";
          /***/
        },
        /* 8 */

        /***/
        function (module, exports) {
          module.exports = "<?xml version=\"1.0\" standalone=\"no\"?><!doctype html><svg class=icon width=20px height=20.00px viewBox=\"0 0 1024 1024\" version=1.1 xmlns=http://www.w3.org/2000/svg><path fill=#595959 d=\"M925.99596 99.038384c-25.470707-25.6-60.121212-39.822222-96.323233-39.822222H194.19798c-36.072727 0-70.723232 14.351515-96.323233 39.822222-25.6 25.6-39.822222 60.121212-39.822222 96.323232v635.474748c0 36.072727 14.351515 70.723232 39.822222 96.323232C123.474747 952.759596 158.125253 967.111111 194.19798 967.111111h635.474747c36.072727 0 70.723232-14.351515 96.323233-39.951515 25.6-25.6 39.951515-60.121212 39.951515-96.323232V195.361616c0-36.072727-14.351515-70.723232-39.951515-96.323232z m-550.270707 5.559596h272.290909v227.167677H375.725253V104.59798z m56.242424 360.468687l31.935353-32.19394 48.09697 48.226263 48.09697-48.226263 32.193939 32.19394-48.09697 48.096969 48.226263 48.226263-32.193939 31.935354-48.226263-48.09697-48.226263 48.09697-31.935353-31.935354 48.226262-48.226263-48.096969-48.096969zM103.434343 195.361616c0-24.048485 9.567677-47.191919 26.634344-64.129293 17.066667-17.066667 40.080808-26.634343 64.129293-26.634343h136.145454v227.167677H103.434343V195.361616z m817.002021 635.733333c0 24.048485-9.567677 47.191919-26.634344 64.258586-17.066667 17.066667-40.080808 26.634343-64.129293 26.634344H194.19798c-24.048485 0-47.191919-9.567677-64.258586-26.634344C112.872727 878.157576 103.434343 855.014141 103.434343 830.836364V694.690909h226.909091v226.909091h45.381819V694.690909h272.290909v226.909091h45.381818V694.690909h226.909091v136.40404z m0-499.329292H693.527273V104.59798h136.145454c24.048485 0 47.191919 9.567677 64.129293 26.634343 17.066667 17.066667 26.634343 40.080808 26.634344 64.129293v136.404041z\"/></svg>";
          /***/
        },
        /* 9 */

        /***/
        function (module, exports) {
          module.exports = "<?xml version=\"1.0\" standalone=\"no\"?><!doctype html><svg class=icon width=20px height=20.00px viewBox=\"0 0 1024 1024\" version=1.1 xmlns=http://www.w3.org/2000/svg><path fill=#595959 d=\"M764.42168889 830.5152c0 30.23530667-24.61013333 54.84430222-54.84316444 54.84430222H314.42147555c-30.23416889 0-54.84316445-24.61013333-54.84316444-54.84430222V248.32796445h504.84337778v582.18723555zM369.26577778 149.89084445c0-6.32832 4.92202667-11.25034667 11.25034667-11.25034667H644.18702222c6.32832 0 11.25034667 4.92202667 11.25034667 11.25034667v33.04675555H369.26577778V149.89084445z m559.68768 33.04675555H720.82773333V149.89084445c0-42.1888-34.45191111-76.64071111-76.64071111-76.64071112H380.51612445c-42.1888 0-76.64071111 34.45191111-76.64071112 76.64071112v33.04675555h-208.82773333c-18.28181333 0-33.04789333 14.76608-33.04789333 33.04675555s14.76608 33.04675555 33.04675555 33.04675556h98.43825778v581.48408889c0 66.79779555 54.14001778 120.93781333 120.93667555 120.93781333h395.1570489c66.79665778 0 120.93667555-54.14001778 120.93667555-120.93781333V248.32796445h98.43825778c18.28067555 0 33.04675555-14.76494222 33.04675555-33.04675556s-14.76608-32.34360889-33.04675555-32.34360889zM512 786.21923555c18.28181333 0 33.04675555-14.76608 33.04675555-33.04789333v-351.56195555c0-18.28181333-14.76494222-33.04675555-33.04675555-33.04675556s-33.04675555 14.76494222-33.04675555 33.04675556v351.56195555c0 18.28181333 14.76494222 33.04789333 33.04675555 33.04789333m-153.98456889 0c18.28181333 0 33.04675555-14.76608 33.04675556-33.04789333v-351.56195555c0-18.28181333-14.76494222-33.04675555-33.04675556-33.04675556s-33.04675555 14.76494222-33.04675556 33.04675556v351.56195555c0.70314667 18.28181333 15.46922667 33.04789333 33.04675556 33.04789333m307.96913778 0c18.28067555 0 33.04675555-14.76608 33.04675556-33.04789333v-351.56195555c0-18.28181333-14.76608-33.04675555-33.04675556-33.04675556s-33.04675555 14.76494222-33.04675556 33.04675556v351.56195555c0 18.28181333 14.76494222 33.04789333 33.04675556 33.04789333\"/></svg>";
          /***/
        },
        /* 10 */

        /***/
        function (module, __webpack_exports__, __webpack_require__) {

          __webpack_require__.r(__webpack_exports__); // EXTERNAL MODULE: external {"commonjs":"quill","commonjs2":"quill","amd":"quill","root":"Quill"}


          var external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_ = __webpack_require__(0);

          var external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default =
          /*#__PURE__*/
          __webpack_require__.n(external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_); // CONCATENATED MODULE: ./src/utils/index.js


          function css(domNode, rules) {
            if (typeof rules === 'object') {
              for (let prop in rules) {
                domNode.style[prop] = rules[prop];
              }
            }
          }
          /**
           * getRelativeRect
           * @param  {Object} targetRect  rect data for target element
           * @param  {Element} container  container element
           * @return {Object}             an object with rect data
           */


          function getRelativeRect(targetRect, container) {
            let containerRect = container.getBoundingClientRect();
            return {
              x: targetRect.x - containerRect.x - container.scrollLeft,
              y: targetRect.y - containerRect.y - container.scrollTop,
              x1: targetRect.x - containerRect.x - container.scrollLeft + targetRect.width,
              y1: targetRect.y - containerRect.y - container.scrollTop + targetRect.height,
              width: targetRect.width,
              height: targetRect.height
            };
          }
          /**
           * _omit
           * @param  {Object} obj         target Object
           * @param  {Array} uselessKeys  keys of removed properties
           * @return {Object}             new Object without useless properties
           */


          function _omit(obj, uselessKeys) {
            return obj && Object.keys(obj).reduce((acc, key) => {
              return uselessKeys.includes(key) ? acc : Object.assign({}, acc, {
                [key]: obj[key]
              });
            }, {});
          }
          /**
           * getEventComposedPath
           *  compatibility fixed for Event.path/Event.composedPath
           *  Event.path is only for chrome/opera
           *  Event.composedPath is for Safari, FF
           *  Neither for Micro Edge
           * @param {Event} evt
           * @return {Array} an array of event.path
           */


          function getEventComposedPath(evt) {
            let path; // chrome, opera, safari, firefox

            path = evt.path || evt.composedPath && evt.composedPath(); // other: edge

            if (path == undefined && evt.target) {
              path = [];
              let target = evt.target;
              path.push(target);

              while (target && target.parentNode) {
                target = target.parentNode;
                path.push(target);
              }
            }

            return path;
          }

          function convertToHex(rgb) {
            var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/; // if rgb

            if (/^(rgb|RGB)/.test(rgb)) {
              var color = rgb.toString().match(/\d+/g);
              var hex = "#";

              for (var i = 0; i < 3; i++) {
                hex += ("0" + Number(color[i]).toString(16)).slice(-2);
              }

              return hex;
            } else if (reg.test(rgb)) {
              var aNum = rgb.replace(/#/, "").split("");

              if (aNum.length === 6) {
                return rgb;
              } else if (aNum.length === 3) {
                var numHex = "#";

                for (var i = 0; i < aNum.length; i += 1) {
                  numHex += aNum[i] + aNum[i];
                }

                return numHex;
              }
            }

            return rgb;
          } // CONCATENATED MODULE: ./src/modules/table-column-tool.js


          const COL_TOOL_HEIGHT = 12;
          const COL_TOOL_CELL_HEIGHT = 12;
          const CELL_MIN_WIDTH = 50;
          const PRIMARY_COLOR = '#35A7ED';

          class table_column_tool_TableColumnTool {
            constructor(table, quill, options) {
              if (!table) return null;
              this.table = table;
              this.quill = quill;
              this.options = options;
              this.domNode = null;
              this.initColTool();
            }

            initColTool() {
              const parent = this.quill.root.parentNode;
              const tableRect = this.table.getBoundingClientRect();
              const containerRect = parent.getBoundingClientRect();
              const tableViewRect = this.table.parentNode.getBoundingClientRect();
              this.domNode = document.createElement('div');
              this.domNode.classList.add('qlbt-col-tool');
              this.updateToolCells();
              parent.appendChild(this.domNode);
              css(this.domNode, {
                width: "".concat(tableViewRect.width, "px"),
                height: "".concat(COL_TOOL_HEIGHT, "px"),
                left: "".concat(tableViewRect.left - containerRect.left + parent.scrollLeft, "px"),
                top: "".concat(tableViewRect.top - containerRect.top + parent.scrollTop - COL_TOOL_HEIGHT - 5, "px")
              });
            }

            createToolCell() {
              const toolCell = document.createElement('div');
              toolCell.classList.add('qlbt-col-tool-cell');
              const resizeHolder = document.createElement('div');
              resizeHolder.classList.add('qlbt-col-tool-cell-holder');
              css(toolCell, {
                'height': "".concat(COL_TOOL_CELL_HEIGHT, "px")
              });
              toolCell.appendChild(resizeHolder);
              return toolCell;
            }

            updateToolCells() {
              const tableContainer = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.table);
              const CellsInFirstRow = tableContainer.children.tail.children.head.children;
              const tableCols = tableContainer.colGroup().children;
              const cellsNumber = computeCellsNumber(CellsInFirstRow);
              let existCells = Array.from(this.domNode.querySelectorAll('.qlbt-col-tool-cell'));

              for (let index = 0; index < Math.max(cellsNumber, existCells.length); index++) {
                let col = tableCols.at(index);
                let colWidth = col && parseInt(col.formats()[col.statics.blotName].width, 10); // if cell already exist

                let toolCell = null;

                if (!existCells[index]) {
                  toolCell = this.createToolCell();
                  this.domNode.appendChild(toolCell);
                  this.addColCellHolderHandler(toolCell); // set tool cell min-width

                  css(toolCell, {
                    'min-width': "".concat(colWidth, "px")
                  });
                } else if (existCells[index] && index >= cellsNumber) {
                  existCells[index].remove();
                } else {
                  toolCell = existCells[index]; // set tool cell min-width

                  css(toolCell, {
                    'min-width': "".concat(colWidth, "px")
                  });
                }
              }
            }

            destroy() {
              this.domNode.remove();
              return null;
            }

            addColCellHolderHandler(cell) {
              const tableContainer = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.table);
              const $holder = cell.querySelector(".qlbt-col-tool-cell-holder");
              let dragging = false;
              let x0 = 0;
              let x = 0;
              let delta = 0;
              let width0 = 0; // helpLine relation varrible

              let tableRect = {};
              let cellRect = {};
              let $helpLine = null;

              const handleDrag = e => {
                e.preventDefault();

                if (dragging) {
                  x = e.clientX;

                  if (width0 + x - x0 >= CELL_MIN_WIDTH) {
                    delta = x - x0;
                  } else {
                    delta = CELL_MIN_WIDTH - width0;
                  }

                  css($helpLine, {
                    'left': "".concat(cellRect.left + cellRect.width - 1 + delta, "px")
                  });
                }
              };

              const handleMouseup = e => {
                e.preventDefault();
                const existCells = Array.from(this.domNode.querySelectorAll('.qlbt-col-tool-cell'));
                const colIndex = existCells.indexOf(cell);
                const colBlot = tableContainer.colGroup().children.at(colIndex);

                if (dragging) {
                  colBlot.format('width', width0 + delta);
                  css(cell, {
                    'min-width': "".concat(width0 + delta, "px")
                  });
                  x0 = 0;
                  x = 0;
                  delta = 0;
                  width0 = 0;
                  dragging = false;
                  $holder.classList.remove('dragging');
                }

                document.removeEventListener('mousemove', handleDrag, false);
                document.removeEventListener('mouseup', handleMouseup, false);
                tableRect = {};
                cellRect = {};
                $helpLine.remove();
                $helpLine = null;
                tableContainer.updateTableWidth();
                const tableSelection = this.quill.getModule('better-table').tableSelection;
                tableSelection && tableSelection.clearSelection();
              };

              const handleMousedown = e => {
                document.addEventListener('mousemove', handleDrag, false);
                document.addEventListener('mouseup', handleMouseup, false);
                tableRect = this.table.getBoundingClientRect();
                cellRect = cell.getBoundingClientRect();
                $helpLine = document.createElement('div');
                css($helpLine, {
                  position: 'fixed',
                  top: "".concat(cellRect.top, "px"),
                  left: "".concat(cellRect.left + cellRect.width - 1, "px"),
                  zIndex: '100',
                  height: "".concat(tableRect.height + COL_TOOL_HEIGHT + 4, "px"),
                  width: '1px',
                  backgroundColor: PRIMARY_COLOR
                });
                document.body.appendChild($helpLine);
                dragging = true;
                x0 = e.clientX;
                width0 = cellRect.width;
                $holder.classList.add('dragging');
              };

              $holder.addEventListener('mousedown', handleMousedown, false);
            }

            colToolCells() {
              return Array.from(this.domNode.querySelectorAll('.qlbt-col-tool-cell'));
            }

          }

          function computeCellsNumber(CellsInFirstRow) {
            return CellsInFirstRow.reduce((sum, cell) => {
              const cellColspan = cell.formats().colspan;
              sum = sum + parseInt(cellColspan, 10);
              return sum;
            }, 0);
          } // CONCATENATED MODULE: ./src/formats/header.js


          const Block = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.import("blots/block");

          class header_Header extends Block {
            static create(value) {
              if (typeof value === 'string') {
                value = {
                  value
                };
              }

              const node = super.create(value.value);
              CELL_IDENTITY_KEYS.forEach(key => {
                if (value[key]) node.setAttribute("data-".concat(key), value[key]);
              });
              CELL_ATTRIBUTES.forEach(key => {
                if (value[key]) node.setAttribute("data-".concat(key), value[key]);
              });
              return node;
            }

            static formats(domNode) {
              const formats = {};
              formats.value = this.tagName.indexOf(domNode.tagName) + 1;
              return CELL_ATTRIBUTES.concat(CELL_IDENTITY_KEYS).reduce((formats, attribute) => {
                if (domNode.hasAttribute("data-".concat(attribute))) {
                  formats[attribute] = domNode.getAttribute("data-".concat(attribute)) || undefined;
                }

                return formats;
              }, formats);
            }

            format(name, value) {
              const {
                row,
                cell,
                rowspan,
                colspan
              } = header_Header.formats(this.domNode);

              if (name === header_Header.blotName) {
                if (value) {
                  super.format(name, {
                    value,
                    row,
                    cell,
                    rowspan,
                    colspan
                  });
                } else {
                  if (row) {
                    this.replaceWith(TableCellLine.blotName, {
                      row,
                      cell,
                      rowspan,
                      colspan
                    });
                  } else {
                    super.format(name, value);
                  }
                }
              } else {
                super.format(name, value);
              }
            }

            optimize(context) {
              const {
                row,
                rowspan,
                colspan
              } = header_Header.formats(this.domNode);

              if (row && !(this.parent instanceof TableCell)) {
                this.wrap(TableCell.blotName, {
                  row,
                  colspan,
                  rowspan
                });
              } // ShadowBlot optimize


              this.enforceAllowedChildren();

              if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {
                this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);
              }

              if (this.children.length === 0) {
                if (this.statics.defaultChild != null) {
                  const child = this.scroll.create(this.statics.defaultChild.blotName);
                  this.appendChild(child); // TODO double check if necessary
                  // child.optimize(context);
                } else {
                  this.remove();
                }
              } // Block optimize


              this.cache = {};
            }

          }

          header_Header.blotName = 'header';
          header_Header.tagName = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];
          /* harmony default export */

          var header = header_Header; // CONCATENATED MODULE: ./src/formats/table.js

          const Break = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.import("blots/break");
          const table_Block = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.import("blots/block");
          const Container = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.import("blots/container");
          const COL_ATTRIBUTES = ["width"];
          const COL_DEFAULT = {
            width: 100
          };
          const CELL_IDENTITY_KEYS = ["row", "cell"];
          const CELL_ATTRIBUTES = ["rowspan", "colspan"];
          const CELL_DEFAULT = {
            rowspan: 1,
            colspan: 1
          };
          const ERROR_LIMIT = 5;

          class TableCellLine extends table_Block {
            static create(value) {
              const node = super.create(value);
              CELL_IDENTITY_KEYS.forEach(key => {
                let identityMaker = key === 'row' ? table_rowId : table_cellId;
                node.setAttribute("data-".concat(key), value[key] || identityMaker());
              });
              CELL_ATTRIBUTES.forEach(attrName => {
                node.setAttribute("data-".concat(attrName), value[attrName] || CELL_DEFAULT[attrName]);
              });

              if (value['cell-bg']) {
                node.setAttribute('data-cell-bg', value['cell-bg']);
              }

              return node;
            }

            static formats(domNode) {
              const formats = {};
              return CELL_ATTRIBUTES.concat(CELL_IDENTITY_KEYS).concat(['cell-bg']).reduce((formats, attribute) => {
                if (domNode.hasAttribute("data-".concat(attribute))) {
                  formats[attribute] = domNode.getAttribute("data-".concat(attribute)) || undefined;
                }

                return formats;
              }, formats);
            }

            format(name, value) {
              if (CELL_ATTRIBUTES.concat(CELL_IDENTITY_KEYS).indexOf(name) > -1) {
                if (value) {
                  this.domNode.setAttribute("data-".concat(name), value);
                } else {
                  this.domNode.removeAttribute("data-".concat(name));
                }
              } else if (name === 'cell-bg') {
                if (value) {
                  this.domNode.setAttribute('data-cell-bg', value);
                } else {
                  this.domNode.removeAttribute('data-cell-bg');
                }
              } else if (name === 'header') {
                if (!value) return;
                const {
                  row,
                  cell,
                  rowspan,
                  colspan
                } = TableCellLine.formats(this.domNode);
                super.format(name, {
                  value,
                  row,
                  cell,
                  rowspan,
                  colspan
                });
              } else {
                super.format(name, value);
              }
            }

            optimize(context) {
              // cover shadowBlot's wrap call, pass params parentBlot initialize
              // needed
              const rowId = this.domNode.getAttribute('data-row');
              const rowspan = this.domNode.getAttribute('data-rowspan');
              const colspan = this.domNode.getAttribute('data-colspan');
              const cellBg = this.domNode.getAttribute('data-cell-bg');

              if (this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer)) {
                this.wrap(this.statics.requiredContainer.blotName, {
                  row: rowId,
                  colspan,
                  rowspan,
                  'cell-bg': cellBg
                });
              }

              super.optimize(context);
            }

            tableCell() {
              return this.parent;
            }

          }

          TableCellLine.blotName = "table-cell-line";
          TableCellLine.ClassName = "qlbt-cell-line";
          TableCellLine.tagName = "DIV";

          class TableCell extends Container {
            checkMerge() {
              if (super.checkMerge() && this.next.children.head != null) {
                const thisHead = this.children.head.formats()[this.children.head.statics.blotName];
                const thisTail = this.children.tail.formats()[this.children.tail.statics.blotName];
                const nextHead = this.next.children.head.formats()[this.next.children.head.statics.blotName];
                const nextTail = this.next.children.tail.formats()[this.next.children.tail.statics.blotName];
                return thisHead.cell === thisTail.cell && thisHead.cell === nextHead.cell && thisHead.cell === nextTail.cell;
              }

              return false;
            }

            static create(value) {
              const node = super.create(value);
              node.setAttribute("data-row", value.row);
              CELL_ATTRIBUTES.forEach(attrName => {
                if (value[attrName]) {
                  node.setAttribute(attrName, value[attrName]);
                }
              });

              if (value['cell-bg']) {
                node.setAttribute('data-cell-bg', value['cell-bg']);
                node.style.backgroundColor = value['cell-bg'];
              }

              return node;
            }

            static formats(domNode) {
              const formats = {};

              if (domNode.hasAttribute("data-row")) {
                formats["row"] = domNode.getAttribute("data-row");
              }

              if (domNode.hasAttribute("data-cell-bg")) {
                formats["cell-bg"] = domNode.getAttribute("data-cell-bg");
              }

              return CELL_ATTRIBUTES.reduce((formats, attribute) => {
                if (domNode.hasAttribute(attribute)) {
                  formats[attribute] = domNode.getAttribute(attribute);
                }

                return formats;
              }, formats);
            }

            cellOffset() {
              if (this.parent) {
                return this.parent.children.indexOf(this);
              }

              return -1;
            }

            formats() {
              const formats = {};

              if (this.domNode.hasAttribute("data-row")) {
                formats["row"] = this.domNode.getAttribute("data-row");
              }

              if (this.domNode.hasAttribute("data-cell-bg")) {
                formats["cell-bg"] = this.domNode.getAttribute("data-cell-bg");
              }

              return CELL_ATTRIBUTES.reduce((formats, attribute) => {
                if (this.domNode.hasAttribute(attribute)) {
                  formats[attribute] = this.domNode.getAttribute(attribute);
                }

                return formats;
              }, formats);
            }

            toggleAttribute(name, value) {
              if (value) {
                this.domNode.setAttribute(name, value);
              } else {
                this.domNode.removeAttribute(name);
              }
            }

            formatChildren(name, value) {
              this.children.forEach(child => {
                child.format(name, value);
              });
            }

            format(name, value) {
              if (CELL_ATTRIBUTES.indexOf(name) > -1) {
                this.toggleAttribute(name, value);
                this.formatChildren(name, value);
              } else if (['row'].indexOf(name) > -1) {
                this.toggleAttribute("data-".concat(name), value);
                this.formatChildren(name, value);
              } else if (name === 'cell-bg') {
                this.toggleAttribute('data-cell-bg', value);
                this.formatChildren(name, value);

                if (value) {
                  this.domNode.style.backgroundColor = value;
                } else {
                  this.domNode.style.backgroundColor = 'initial';
                }
              } else {
                super.format(name, value);
              }
            }

            optimize(context) {
              const rowId = this.domNode.getAttribute("data-row");

              if (this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer)) {
                this.wrap(this.statics.requiredContainer.blotName, {
                  row: rowId
                });
              }

              super.optimize(context);
            }

            row() {
              return this.parent;
            }

            rowOffset() {
              if (this.row()) {
                return this.row().rowOffset();
              }

              return -1;
            }

            table() {
              return this.row() && this.row().table();
            }

          }

          TableCell.blotName = "table";
          TableCell.tagName = "TD";

          class TableRow extends Container {
            checkMerge() {
              if (super.checkMerge() && this.next.children.head != null) {
                const thisHead = this.children.head.formats();
                const thisTail = this.children.tail.formats();
                const nextHead = this.next.children.head.formats();
                const nextTail = this.next.children.tail.formats();
                return thisHead.row === thisTail.row && thisHead.row === nextHead.row && thisHead.row === nextTail.row;
              }

              return false;
            }

            static create(value) {
              const node = super.create(value);
              node.setAttribute("data-row", value.row);
              return node;
            }

            formats() {
              return ["row"].reduce((formats, attrName) => {
                if (this.domNode.hasAttribute("data-".concat(attrName))) {
                  formats[attrName] = this.domNode.getAttribute("data-".concat(attrName));
                }

                return formats;
              }, {});
            }

            optimize(context) {
              // optimize function of ShadowBlot
              if (this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer)) {
                this.wrap(this.statics.requiredContainer.blotName);
              } // optimize function of ParentBlot
              // note: modified this optimize function because
              // TableRow should not be removed when the length of its children was 0


              this.enforceAllowedChildren();

              if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {
                this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);
              } // optimize function of ContainerBlot


              if (this.children.length > 0 && this.next != null && this.checkMerge()) {
                this.next.moveChildren(this);
                this.next.remove();
              }
            }

            rowOffset() {
              if (this.parent) {
                return this.parent.children.indexOf(this);
              }

              return -1;
            }

            table() {
              return this.parent && this.parent.parent;
            }

          }

          TableRow.blotName = "table-row";
          TableRow.tagName = "TR";

          class TableBody extends Container {}

          TableBody.blotName = "table-body";
          TableBody.tagName = "TBODY";

          class TableCol extends table_Block {
            static create(value) {
              let node = super.create(value);
              COL_ATTRIBUTES.forEach(attrName => {
                node.setAttribute("".concat(attrName), value[attrName] || COL_DEFAULT[attrName]);
              });
              return node;
            }

            static formats(domNode) {
              return COL_ATTRIBUTES.reduce((formats, attribute) => {
                if (domNode.hasAttribute("".concat(attribute))) {
                  formats[attribute] = domNode.getAttribute("".concat(attribute)) || undefined;
                }

                return formats;
              }, {});
            }

            format(name, value) {
              if (COL_ATTRIBUTES.indexOf(name) > -1) {
                this.domNode.setAttribute("".concat(name), value || COL_DEFAULT[name]);
              } else {
                super.format(name, value);
              }
            }

            html() {
              return this.domNode.outerHTML;
            }

          }

          TableCol.blotName = "table-col";
          TableCol.tagName = "col";

          class TableColGroup extends Container {}

          TableColGroup.blotName = "table-col-group";
          TableColGroup.tagName = "colgroup";

          class table_TableContainer extends Container {
            static create() {
              let node = super.create();
              return node;
            }

            constructor(scroll, domNode) {
              super(scroll, domNode);
              this.updateTableWidth();
            }

            updateTableWidth() {
              setTimeout(() => {
                const colGroup = this.colGroup();
                if (!colGroup) return;
                const tableWidth = colGroup.children.reduce((sumWidth, col) => {
                  sumWidth = sumWidth + parseInt(col.formats()[TableCol.blotName].width, 10);
                  return sumWidth;
                }, 0);
                this.domNode.style.width = "".concat(tableWidth, "px");
              }, 0);
            }

            cells(column) {
              return this.rows().map(row => row.children.at(column));
            }

            colGroup() {
              return this.children.head;
            }

            deleteColumns(compareRect) {
              let delIndexes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
              let editorWrapper = arguments.length > 2 ? arguments[2] : undefined;
              const [body] = this.descendants(TableBody);
              if (body == null || body.children.head == null) return;
              const tableCells = this.descendants(TableCell);
              const removedCells = [];
              const modifiedCells = [];
              tableCells.forEach(cell => {
                const cellRect = getRelativeRect(cell.domNode.getBoundingClientRect(), editorWrapper);

                if (cellRect.x + ERROR_LIMIT > compareRect.x && cellRect.x1 - ERROR_LIMIT < compareRect.x1) {
                  removedCells.push(cell);
                } else if (cellRect.x < compareRect.x + ERROR_LIMIT && cellRect.x1 > compareRect.x1 - ERROR_LIMIT) {
                  modifiedCells.push(cell);
                }
              });

              if (removedCells.length === tableCells.length) {
                this.tableDestroy();
                return true;
              } // remove the matches column tool cell


              delIndexes.forEach(delIndex => {
                this.colGroup().children.at(delIndexes[0]).remove();
              });
              removedCells.forEach(cell => {
                cell.remove();
              });
              modifiedCells.forEach(cell => {
                const cellColspan = parseInt(cell.formats().colspan, 10);
                const cellWidth = parseInt(cell.formats().width, 10);
                cell.format('colspan', cellColspan - delIndexes.length);
              });
              this.updateTableWidth();
            }

            deleteRow(compareRect, editorWrapper) {
              const [body] = this.descendants(TableBody);
              if (body == null || body.children.head == null) return;
              const tableCells = this.descendants(TableCell);
              const tableRows = this.descendants(TableRow);
              const removedCells = []; // cells to be removed

              const modifiedCells = []; // cells to be modified

              const fallCells = []; // cells to fall into next row
              // compute rows to remove
              // bugfix: #21 There will be a empty tr left if delete the last row of a table

              const removedRows = tableRows.filter(row => {
                const rowRect = getRelativeRect(row.domNode.getBoundingClientRect(), editorWrapper);
                return rowRect.y > compareRect.y - ERROR_LIMIT && rowRect.y1 < compareRect.y1 + ERROR_LIMIT;
              });
              tableCells.forEach(cell => {
                const cellRect = getRelativeRect(cell.domNode.getBoundingClientRect(), editorWrapper);

                if (cellRect.y > compareRect.y - ERROR_LIMIT && cellRect.y1 < compareRect.y1 + ERROR_LIMIT) {
                  removedCells.push(cell);
                } else if (cellRect.y < compareRect.y + ERROR_LIMIT && cellRect.y1 > compareRect.y1 - ERROR_LIMIT) {
                  modifiedCells.push(cell);

                  if (Math.abs(cellRect.y - compareRect.y) < ERROR_LIMIT) {
                    fallCells.push(cell);
                  }
                }
              });

              if (removedCells.length === tableCells.length) {
                this.tableDestroy();
                return;
              } // compute length of removed rows


              const removedRowsLength = this.rows().reduce((sum, row) => {
                let rowRect = getRelativeRect(row.domNode.getBoundingClientRect(), editorWrapper);

                if (rowRect.y > compareRect.y - ERROR_LIMIT && rowRect.y1 < compareRect.y1 + ERROR_LIMIT) {
                  sum += 1;
                }

                return sum;
              }, 0); // it must excute before the table layout changed with other operation

              fallCells.forEach(cell => {
                const cellRect = getRelativeRect(cell.domNode.getBoundingClientRect(), editorWrapper);
                const nextRow = cell.parent.next;
                const cellsInNextRow = nextRow.children;
                const refCell = cellsInNextRow.reduce((ref, compareCell) => {
                  const compareRect = getRelativeRect(compareCell.domNode.getBoundingClientRect(), editorWrapper);

                  if (Math.abs(cellRect.x1 - compareRect.x) < ERROR_LIMIT) {
                    ref = compareCell;
                  }

                  return ref;
                }, null);
                nextRow.insertBefore(cell, refCell);
                cell.format('row', nextRow.formats().row);
              });
              removedCells.forEach(cell => {
                cell.remove();
              });
              modifiedCells.forEach(cell => {
                const cellRowspan = parseInt(cell.formats().rowspan, 10);
                cell.format("rowspan", cellRowspan - removedRowsLength);
              }); // remove selected rows

              removedRows.forEach(row => row.remove());
            }

            tableDestroy() {
              const quill = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.scroll.domNode.parentNode);
              const tableModule = quill.getModule("better-table");
              this.remove();
              tableModule.hideTableTools();
              quill.update(external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
            }

            insertCell(tableRow, ref) {
              const id = table_cellId();
              const rId = tableRow.formats().row;
              const tableCell = this.scroll.create(TableCell.blotName, Object.assign({}, CELL_DEFAULT, {
                row: rId
              }));
              const cellLine = this.scroll.create(TableCellLine.blotName, {
                row: rId,
                cell: id
              });
              tableCell.appendChild(cellLine);

              if (ref) {
                tableRow.insertBefore(tableCell, ref);
              } else {
                tableRow.appendChild(tableCell);
              }
            }

            insertColumn(compareRect, colIndex) {
              let isRight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
              let editorWrapper = arguments.length > 3 ? arguments[3] : undefined;
              const [body] = this.descendants(TableBody);
              const [tableColGroup] = this.descendants(TableColGroup);
              const tableCols = this.descendants(TableCol);
              let addAsideCells = [];
              let modifiedCells = [];
              let affectedCells = [];
              if (body == null || body.children.head == null) return;
              const tableCells = this.descendants(TableCell);
              tableCells.forEach(cell => {
                const cellRect = getRelativeRect(cell.domNode.getBoundingClientRect(), editorWrapper);

                if (isRight) {
                  if (Math.abs(cellRect.x1 - compareRect.x1) < ERROR_LIMIT) {
                    // the right of selected boundary equal to the right of table cell,
                    // add a new table cell right aside this table cell
                    addAsideCells.push(cell);
                  } else if (compareRect.x1 - cellRect.x > ERROR_LIMIT && compareRect.x1 - cellRect.x1 < -ERROR_LIMIT) {
                    // the right of selected boundary is inside this table cell
                    // colspan of this table cell will increase 1
                    modifiedCells.push(cell);
                  }
                } else {
                  if (Math.abs(cellRect.x - compareRect.x) < ERROR_LIMIT) {
                    // left of selected boundary equal to left of table cell,
                    // add a new table cell left aside this table cell
                    addAsideCells.push(cell);
                  } else if (compareRect.x - cellRect.x > ERROR_LIMIT && compareRect.x - cellRect.x1 < -ERROR_LIMIT) {
                    // the left of selected boundary is inside this table cell
                    // colspan of this table cell will increase 1
                    modifiedCells.push(cell);
                  }
                }
              });
              addAsideCells.forEach(cell => {
                const ref = isRight ? cell.next : cell;
                const id = table_cellId();
                const tableRow = cell.parent;
                const rId = tableRow.formats().row;
                const cellFormats = cell.formats();
                const tableCell = this.scroll.create(TableCell.blotName, Object.assign({}, CELL_DEFAULT, {
                  row: rId,
                  rowspan: cellFormats.rowspan
                }));
                const cellLine = this.scroll.create(TableCellLine.blotName, {
                  row: rId,
                  cell: id,
                  rowspan: cellFormats.rowspan
                });
                tableCell.appendChild(cellLine);

                if (ref) {
                  tableRow.insertBefore(tableCell, ref);
                } else {
                  tableRow.appendChild(tableCell);
                }

                affectedCells.push(tableCell);
              }); // insert new tableCol

              const tableCol = this.scroll.create(TableCol.blotName, true);
              let colRef = isRight ? tableCols[colIndex].next : tableCols[colIndex];

              if (colRef) {
                tableColGroup.insertBefore(tableCol, colRef);
              } else {
                tableColGroup.appendChild(tableCol);
              }

              modifiedCells.forEach(cell => {
                const cellColspan = cell.formats().colspan;
                cell.format('colspan', parseInt(cellColspan, 10) + 1);
                affectedCells.push(cell);
              });
              affectedCells.sort((cellA, cellB) => {
                let y1 = cellA.domNode.getBoundingClientRect().y;
                let y2 = cellB.domNode.getBoundingClientRect().y;
                return y1 - y2;
              });
              this.updateTableWidth();
              return affectedCells;
            }

            insertRow(compareRect, isDown, editorWrapper) {
              const [body] = this.descendants(TableBody);
              if (body == null || body.children.head == null) return;
              const tableCells = this.descendants(TableCell);
              const rId = table_rowId();
              const newRow = this.scroll.create(TableRow.blotName, {
                row: rId
              });
              let addBelowCells = [];
              let modifiedCells = [];
              let affectedCells = [];
              tableCells.forEach(cell => {
                const cellRect = getRelativeRect(cell.domNode.getBoundingClientRect(), editorWrapper);

                if (isDown) {
                  if (Math.abs(cellRect.y1 - compareRect.y1) < ERROR_LIMIT) {
                    addBelowCells.push(cell);
                  } else if (compareRect.y1 - cellRect.y > ERROR_LIMIT && compareRect.y1 - cellRect.y1 < -ERROR_LIMIT) {
                    modifiedCells.push(cell);
                  }
                } else {
                  if (Math.abs(cellRect.y - compareRect.y) < ERROR_LIMIT) {
                    addBelowCells.push(cell);
                  } else if (compareRect.y - cellRect.y > ERROR_LIMIT && compareRect.y - cellRect.y1 < -ERROR_LIMIT) {
                    modifiedCells.push(cell);
                  }
                }
              }); // ordered table cells with rect.x, fix error for inserting
              // new table cell in complicated table with wrong order.

              const sortFunc = (cellA, cellB) => {
                let x1 = cellA.domNode.getBoundingClientRect().x;
                let x2 = cellB.domNode.getBoundingClientRect().x;
                return x1 - x2;
              };

              addBelowCells.sort(sortFunc);
              addBelowCells.forEach(cell => {
                const cId = table_cellId();
                const cellFormats = cell.formats();
                const tableCell = this.scroll.create(TableCell.blotName, Object.assign({}, CELL_DEFAULT, {
                  row: rId,
                  colspan: cellFormats.colspan
                }));
                const cellLine = this.scroll.create(TableCellLine.blotName, {
                  row: rId,
                  cell: cId,
                  colspan: cellFormats.colspan
                });
                const empty = this.scroll.create(Break.blotName);
                cellLine.appendChild(empty);
                tableCell.appendChild(cellLine);
                newRow.appendChild(tableCell);
                affectedCells.push(tableCell);
              });
              modifiedCells.forEach(cell => {
                const cellRowspan = parseInt(cell.formats().rowspan, 10);
                cell.format("rowspan", cellRowspan + 1);
                affectedCells.push(cell);
              });
              const refRow = this.rows().find(row => {
                let rowRect = getRelativeRect(row.domNode.getBoundingClientRect(), editorWrapper);

                if (isDown) {
                  return Math.abs(rowRect.y - compareRect.y - compareRect.height) < ERROR_LIMIT;
                } else {
                  return Math.abs(rowRect.y - compareRect.y) < ERROR_LIMIT;
                }
              });
              body.insertBefore(newRow, refRow); // reordering affectedCells

              affectedCells.sort(sortFunc);
              return affectedCells;
            }

            mergeCells(compareRect, mergingCells, rowspan, colspan, editorWrapper) {
              const mergedCell = mergingCells.reduce((result, tableCell, index) => {
                if (index !== 0) {
                  result && tableCell.moveChildren(result);
                  tableCell.remove();
                } else {
                  tableCell.format('colspan', colspan);
                  tableCell.format('rowspan', rowspan);
                  result = tableCell;
                }

                return result;
              }, null);
              let rowId = mergedCell.domNode.getAttribute('data-row');
              let cellId = mergedCell.children.head.domNode.getAttribute('data-cell');
              mergedCell.children.forEach(cellLine => {
                cellLine.format('cell', cellId);
                cellLine.format('row', rowId);
                cellLine.format('colspan', colspan);
                cellLine.format('rowspan', rowspan);
              });
              return mergedCell;
            }

            unmergeCells(unmergingCells, editorWrapper) {
              let cellFormats = {};
              let cellRowspan = 1;
              let cellColspan = 1;
              unmergingCells.forEach(tableCell => {
                cellFormats = tableCell.formats();
                cellRowspan = cellFormats.rowspan;
                cellColspan = cellFormats.colspan;

                if (cellColspan > 1) {
                  let ref = tableCell.next;
                  let row = tableCell.row();
                  tableCell.format('colspan', 1);

                  for (let i = cellColspan; i > 1; i--) {
                    this.insertCell(row, ref);
                  }
                }

                if (cellRowspan > 1) {
                  let i = cellRowspan;
                  let nextRow = tableCell.row().next;

                  while (i > 1) {
                    let refInNextRow = nextRow.children.reduce((result, cell) => {
                      let compareRect = getRelativeRect(tableCell.domNode.getBoundingClientRect(), editorWrapper);
                      let cellRect = getRelativeRect(cell.domNode.getBoundingClientRect(), editorWrapper);

                      if (Math.abs(compareRect.x1 - cellRect.x) < ERROR_LIMIT) {
                        result = cell;
                      }

                      return result;
                    }, null);

                    for (let i = cellColspan; i > 0; i--) {
                      this.insertCell(nextRow, refInNextRow);
                    }

                    i -= 1;
                    nextRow = nextRow.next;
                  }

                  tableCell.format('rowspan', 1);
                }
              });
            }

            rows() {
              const body = this.children.tail;
              if (body == null) return [];
              return body.children.map(row => row);
            }

          }

          table_TableContainer.blotName = "table-container";
          table_TableContainer.className = "quill-better-table";
          table_TableContainer.tagName = "TABLE";

          class table_TableViewWrapper extends Container {
            constructor(scroll, domNode) {
              super(scroll, domNode);
              const quill = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(scroll.domNode.parentNode);
              domNode.addEventListener('scroll', e => {
                const tableModule = quill.getModule('better-table');

                if (tableModule.columnTool) {
                  tableModule.columnTool.domNode.scrollLeft = e.target.scrollLeft;
                }

                if (tableModule.tableSelection && tableModule.tableSelection.selectedTds.length > 0) {
                  tableModule.tableSelection.repositionHelpLines();
                }
              }, false);
            }

            table() {
              return this.children.head;
            }

          }

          table_TableViewWrapper.blotName = "table-view";
          table_TableViewWrapper.className = "quill-better-table-wrapper";
          table_TableViewWrapper.tagName = "DIV";
          table_TableViewWrapper.allowedChildren = [table_TableContainer];
          table_TableContainer.requiredContainer = table_TableViewWrapper;
          table_TableContainer.allowedChildren = [TableBody, TableColGroup];
          TableBody.requiredContainer = table_TableContainer;
          TableBody.allowedChildren = [TableRow];
          TableRow.requiredContainer = TableBody;
          TableRow.allowedChildren = [TableCell];
          TableCell.requiredContainer = TableRow;
          TableCell.allowedChildren = [TableCellLine, header];
          TableCellLine.requiredContainer = TableCell;
          TableColGroup.allowedChildren = [TableCol];
          TableColGroup.requiredContainer = table_TableContainer;
          TableCol.requiredContainer = TableColGroup;

          function table_rowId() {
            const id = Math.random().toString(36).slice(2, 6);
            return "row-".concat(id);
          }

          function table_cellId() {
            const id = Math.random().toString(36).slice(2, 6);
            return "cell-".concat(id);
          } // CONCATENATED MODULE: ./src/modules/table-selection.js


          const table_selection_PRIMARY_COLOR = '#0589f3';
          const LINE_POSITIONS = ['left', 'right', 'top', 'bottom'];
          const table_selection_ERROR_LIMIT = 2;

          class table_selection_TableSelection {
            constructor(table, quill, options) {
              if (!table) return null;
              this.table = table;
              this.quill = quill;
              this.options = options;
              this.boundary = {}; // params for selected square

              this.selectedTds = []; // array for selected table-cells

              this.dragging = false;
              this.selectingHandler = this.mouseDownHandler.bind(this);
              this.clearSelectionHanler = this.clearSelection.bind(this);
              this.helpLinesInitial();
              this.quill.root.addEventListener('mousedown', this.selectingHandler, false);
              this.quill.on('text-change', this.clearSelectionHanler);
            }

            helpLinesInitial() {
              let parent = this.quill.root.parentNode;
              LINE_POSITIONS.forEach(direction => {
                this[direction] = document.createElement('div');
                this[direction].classList.add('qlbt-selection-line');
                this[direction].classList.add('qlbt-selection-line-' + direction);
                css(this[direction], {
                  position: 'absolute',
                  display: 'none',
                  'background-color': table_selection_PRIMARY_COLOR
                });
                parent.appendChild(this[direction]);
              });
            }

            mouseDownHandler(e) {
              if (e.button !== 0 || !e.target.closest(".quill-better-table")) return;
              this.quill.root.addEventListener('mousemove', mouseMoveHandler, false);
              this.quill.root.addEventListener('mouseup', mouseUpHandler, false);
              const self = this;
              const startTd = e.target.closest('td[data-row]');
              const startTdRect = getRelativeRect(startTd.getBoundingClientRect(), this.quill.root.parentNode);
              this.dragging = true;
              this.boundary = computeBoundaryFromRects(startTdRect, startTdRect);
              this.correctBoundary();
              this.selectedTds = this.computeSelectedTds();
              this.repositionHelpLines();

              function mouseMoveHandler(e) {
                if (e.button !== 0 || !e.target.closest(".quill-better-table")) return;
                const endTd = e.target.closest('td[data-row]');
                const endTdRect = getRelativeRect(endTd.getBoundingClientRect(), self.quill.root.parentNode);
                self.boundary = computeBoundaryFromRects(startTdRect, endTdRect);
                self.correctBoundary();
                self.selectedTds = self.computeSelectedTds();
                self.repositionHelpLines(); // avoid select text in multiple table-cell

                if (startTd !== endTd) {
                  self.quill.blur();
                }
              }

              function mouseUpHandler(e) {
                self.quill.root.removeEventListener('mousemove', mouseMoveHandler, false);
                self.quill.root.removeEventListener('mouseup', mouseUpHandler, false);
                self.dragging = false;
              }
            }

            correctBoundary() {
              const tableContainer = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.table);
              const tableCells = tableContainer.descendants(TableCell);
              tableCells.forEach(tableCell => {
                let {
                  x,
                  y,
                  width,
                  height
                } = getRelativeRect(tableCell.domNode.getBoundingClientRect(), this.quill.root.parentNode);
                let isCellIntersected = (x + table_selection_ERROR_LIMIT >= this.boundary.x && x + table_selection_ERROR_LIMIT <= this.boundary.x1 || x - table_selection_ERROR_LIMIT + width >= this.boundary.x && x - table_selection_ERROR_LIMIT + width <= this.boundary.x1) && (y + table_selection_ERROR_LIMIT >= this.boundary.y && y + table_selection_ERROR_LIMIT <= this.boundary.y1 || y - table_selection_ERROR_LIMIT + height >= this.boundary.y && y - table_selection_ERROR_LIMIT + height <= this.boundary.y1);

                if (isCellIntersected) {
                  this.boundary = computeBoundaryFromRects(this.boundary, {
                    x,
                    y,
                    width,
                    height
                  });
                }
              });
            }

            computeSelectedTds() {
              const tableContainer = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.table);
              const tableCells = tableContainer.descendants(TableCell);
              return tableCells.reduce((selectedCells, tableCell) => {
                let {
                  x,
                  y,
                  width,
                  height
                } = getRelativeRect(tableCell.domNode.getBoundingClientRect(), this.quill.root.parentNode);
                let isCellIncluded = x + table_selection_ERROR_LIMIT >= this.boundary.x && x - table_selection_ERROR_LIMIT + width <= this.boundary.x1 && y + table_selection_ERROR_LIMIT >= this.boundary.y && y - table_selection_ERROR_LIMIT + height <= this.boundary.y1;

                if (isCellIncluded) {
                  selectedCells.push(tableCell);
                }

                return selectedCells;
              }, []);
            }

            repositionHelpLines() {
              const tableViewScrollLeft = this.table.parentNode.scrollLeft;
              css(this.left, {
                display: 'block',
                left: "".concat(this.boundary.x - tableViewScrollLeft - 1, "px"),
                top: "".concat(this.boundary.y, "px"),
                height: "".concat(this.boundary.height + 1, "px"),
                width: '1px'
              });
              css(this.right, {
                display: 'block',
                left: "".concat(this.boundary.x1 - tableViewScrollLeft, "px"),
                top: "".concat(this.boundary.y, "px"),
                height: "".concat(this.boundary.height + 1, "px"),
                width: '1px'
              });
              css(this.top, {
                display: 'block',
                left: "".concat(this.boundary.x - 1 - tableViewScrollLeft, "px"),
                top: "".concat(this.boundary.y, "px"),
                width: "".concat(this.boundary.width + 1, "px"),
                height: '1px'
              });
              css(this.bottom, {
                display: 'block',
                left: "".concat(this.boundary.x - 1 - tableViewScrollLeft, "px"),
                top: "".concat(this.boundary.y1 + 1, "px"),
                width: "".concat(this.boundary.width + 1, "px"),
                height: '1px'
              });
            } // based on selectedTds compute positions of help lines
            // It is useful when selectedTds are not changed


            refreshHelpLinesPosition() {
              const startRect = getRelativeRect(this.selectedTds[0].domNode.getBoundingClientRect(), this.quill.root.parentNode);
              const endRect = getRelativeRect(this.selectedTds[this.selectedTds.length - 1].domNode.getBoundingClientRect(), this.quill.root.parentNode);
              this.boundary = computeBoundaryFromRects(startRect, endRect);
              this.repositionHelpLines();
            }

            destroy() {
              LINE_POSITIONS.forEach(direction => {
                this[direction].remove();
                this[direction] = null;
              });
              this.quill.root.removeEventListener('mousedown', this.selectingHandler, false);
              this.quill.off('text-change', this.clearSelectionHanler);
              return null;
            }

            setSelection(startRect, endRect) {
              this.boundary = computeBoundaryFromRects(getRelativeRect(startRect, this.quill.root.parentNode), getRelativeRect(endRect, this.quill.root.parentNode));
              this.correctBoundary();
              this.selectedTds = this.computeSelectedTds();
              this.repositionHelpLines();
            }

            clearSelection() {
              this.boundary = {};
              this.selectedTds = [];
              LINE_POSITIONS.forEach(direction => {
                this[direction] && css(this[direction], {
                  display: 'none'
                });
              });
            }

          }

          function computeBoundaryFromRects(startRect, endRect) {
            let x = Math.min(startRect.x, endRect.x, startRect.x + startRect.width - 1, endRect.x + endRect.width - 1);
            let x1 = Math.max(startRect.x, endRect.x, startRect.x + startRect.width - 1, endRect.x + endRect.width - 1);
            let y = Math.min(startRect.y, endRect.y, startRect.y + startRect.height - 1, endRect.y + endRect.height - 1);
            let y1 = Math.max(startRect.y, endRect.y, startRect.y + startRect.height - 1, endRect.y + endRect.height - 1);
            let width = x1 - x;
            let height = y1 - y;
            return {
              x,
              x1,
              y,
              y1,
              width,
              height
            };
          } // EXTERNAL MODULE: ./src/assets/icons/icon_operation_1.svg


          var icon_operation_1 = __webpack_require__(1);

          var icon_operation_1_default =
          /*#__PURE__*/
          __webpack_require__.n(icon_operation_1); // EXTERNAL MODULE: ./src/assets/icons/icon_operation_2.svg


          var icon_operation_2 = __webpack_require__(2);

          var icon_operation_2_default =
          /*#__PURE__*/
          __webpack_require__.n(icon_operation_2); // EXTERNAL MODULE: ./src/assets/icons/icon_operation_3.svg


          var icon_operation_3 = __webpack_require__(3);

          var icon_operation_3_default =
          /*#__PURE__*/
          __webpack_require__.n(icon_operation_3); // EXTERNAL MODULE: ./src/assets/icons/icon_operation_4.svg


          var icon_operation_4 = __webpack_require__(4);

          var icon_operation_4_default =
          /*#__PURE__*/
          __webpack_require__.n(icon_operation_4); // EXTERNAL MODULE: ./src/assets/icons/icon_operation_5.svg


          var icon_operation_5 = __webpack_require__(5);

          var icon_operation_5_default =
          /*#__PURE__*/
          __webpack_require__.n(icon_operation_5); // EXTERNAL MODULE: ./src/assets/icons/icon_operation_6.svg


          var icon_operation_6 = __webpack_require__(6);

          var icon_operation_6_default =
          /*#__PURE__*/
          __webpack_require__.n(icon_operation_6); // EXTERNAL MODULE: ./src/assets/icons/icon_operation_7.svg


          var icon_operation_7 = __webpack_require__(7);

          var icon_operation_7_default =
          /*#__PURE__*/
          __webpack_require__.n(icon_operation_7); // EXTERNAL MODULE: ./src/assets/icons/icon_operation_8.svg


          var icon_operation_8 = __webpack_require__(8);

          var icon_operation_8_default =
          /*#__PURE__*/
          __webpack_require__.n(icon_operation_8); // EXTERNAL MODULE: ./src/assets/icons/icon_operation_9.svg


          var icon_operation_9 = __webpack_require__(9);

          var icon_operation_9_default =
          /*#__PURE__*/
          __webpack_require__.n(icon_operation_9); // CONCATENATED MODULE: ./src/modules/table-operation-menu.js
          // svg icons


          const MENU_MIN_HEIHGT = 150;
          const MENU_WIDTH = 200;
          const table_operation_menu_ERROR_LIMIT = 5;
          const DEFAULT_CELL_COLORS = ['white', 'red', 'yellow', 'blue'];
          const DEFAULT_COLOR_SUBTITLE = 'Background Colors';
          const MENU_ITEMS_DEFAULT = {
            insertColumnRight: {
              text: 'Insert column right',
              iconSrc: icon_operation_1_default.a,

              handler() {
                const tableContainer = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.table);
                let colIndex = getColToolCellIndexByBoundary(this.columnToolCells, this.boundary, (cellRect, boundary) => {
                  return Math.abs(cellRect.x + cellRect.width - boundary.x1) <= table_operation_menu_ERROR_LIMIT;
                }, this.quill.root.parentNode);
                const newColumn = tableContainer.insertColumn(this.boundary, colIndex, true, this.quill.root.parentNode);
                this.tableColumnTool.updateToolCells();
                this.quill.update(external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                this.quill.setSelection(this.quill.getIndex(newColumn[0]), 0, external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.SILENT);
                this.tableSelection.setSelection(newColumn[0].domNode.getBoundingClientRect(), newColumn[0].domNode.getBoundingClientRect());
              }

            },
            insertColumnLeft: {
              text: 'Insert column left',
              iconSrc: icon_operation_2_default.a,

              handler() {
                const tableContainer = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.table);
                let colIndex = getColToolCellIndexByBoundary(this.columnToolCells, this.boundary, (cellRect, boundary) => {
                  return Math.abs(cellRect.x - boundary.x) <= table_operation_menu_ERROR_LIMIT;
                }, this.quill.root.parentNode);
                const newColumn = tableContainer.insertColumn(this.boundary, colIndex, false, this.quill.root.parentNode);
                this.tableColumnTool.updateToolCells();
                this.quill.update(external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                this.quill.setSelection(this.quill.getIndex(newColumn[0]), 0, external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.SILENT);
                this.tableSelection.setSelection(newColumn[0].domNode.getBoundingClientRect(), newColumn[0].domNode.getBoundingClientRect());
              }

            },
            insertRowUp: {
              text: 'Insert row up',
              iconSrc: icon_operation_3_default.a,

              handler() {
                const tableContainer = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.table);
                const affectedCells = tableContainer.insertRow(this.boundary, false, this.quill.root.parentNode);
                this.quill.update(external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                this.quill.setSelection(this.quill.getIndex(affectedCells[0]), 0, external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.SILENT);
                this.tableSelection.setSelection(affectedCells[0].domNode.getBoundingClientRect(), affectedCells[0].domNode.getBoundingClientRect());
              }

            },
            insertRowDown: {
              text: 'Insert row down',
              iconSrc: icon_operation_4_default.a,

              handler() {
                const tableContainer = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.table);
                const affectedCells = tableContainer.insertRow(this.boundary, true, this.quill.root.parentNode);
                this.quill.update(external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                this.quill.setSelection(this.quill.getIndex(affectedCells[0]), 0, external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.SILENT);
                this.tableSelection.setSelection(affectedCells[0].domNode.getBoundingClientRect(), affectedCells[0].domNode.getBoundingClientRect());
              }

            },
            mergeCells: {
              text: 'Merge selected cells',
              iconSrc: icon_operation_5_default.a,

              handler() {
                const tableContainer = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.table); // compute merged Cell rowspan, equal to length of selected rows

                const rowspan = tableContainer.rows().reduce((sum, row) => {
                  let rowRect = getRelativeRect(row.domNode.getBoundingClientRect(), this.quill.root.parentNode);

                  if (rowRect.y > this.boundary.y - table_operation_menu_ERROR_LIMIT && rowRect.y + rowRect.height < this.boundary.y + this.boundary.height + table_operation_menu_ERROR_LIMIT) {
                    sum += 1;
                  }

                  return sum;
                }, 0); // compute merged cell colspan, equal to length of selected cols

                const colspan = this.columnToolCells.reduce((sum, cell) => {
                  let cellRect = getRelativeRect(cell.getBoundingClientRect(), this.quill.root.parentNode);

                  if (cellRect.x > this.boundary.x - table_operation_menu_ERROR_LIMIT && cellRect.x + cellRect.width < this.boundary.x + this.boundary.width + table_operation_menu_ERROR_LIMIT) {
                    sum += 1;
                  }

                  return sum;
                }, 0);
                const mergedCell = tableContainer.mergeCells(this.boundary, this.selectedTds, rowspan, colspan, this.quill.root.parentNode);
                this.quill.update(external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                this.tableSelection.setSelection(mergedCell.domNode.getBoundingClientRect(), mergedCell.domNode.getBoundingClientRect());
              }

            },
            unmergeCells: {
              text: 'Unmerge cells',
              iconSrc: icon_operation_6_default.a,

              handler() {
                const tableContainer = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.table);
                tableContainer.unmergeCells(this.selectedTds, this.quill.root.parentNode);
                this.quill.update(external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                this.tableSelection.clearSelection();
              }

            },
            deleteColumn: {
              text: 'Delete selected columns',
              iconSrc: icon_operation_7_default.a,

              handler() {
                const tableContainer = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.table);
                let colIndexes = getColToolCellIndexesByBoundary(this.columnToolCells, this.boundary, (cellRect, boundary) => {
                  return cellRect.x + table_operation_menu_ERROR_LIMIT > boundary.x && cellRect.x + cellRect.width - table_operation_menu_ERROR_LIMIT < boundary.x1;
                }, this.quill.root.parentNode);
                let isDeleteTable = tableContainer.deleteColumns(this.boundary, colIndexes, this.quill.root.parentNode);

                if (!isDeleteTable) {
                  this.tableColumnTool.updateToolCells();
                  this.quill.update(external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                  this.tableSelection.clearSelection();
                }
              }

            },
            deleteRow: {
              text: 'Delete selected rows',
              iconSrc: icon_operation_8_default.a,

              handler() {
                const tableContainer = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.table);
                tableContainer.deleteRow(this.boundary, this.quill.root.parentNode);
                this.quill.update(external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                this.tableSelection.clearSelection();
              }

            },
            deleteTable: {
              text: 'Delete table',
              iconSrc: icon_operation_9_default.a,

              handler() {
                const betterTableModule = this.quill.getModule('better-table');
                const tableContainer = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.find(this.table);
                betterTableModule.hideTableTools();
                tableContainer.remove();
                this.quill.update(external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
              }

            }
          };

          class table_operation_menu_TableOperationMenu {
            constructor(params, quill, options) {
              const betterTableModule = quill.getModule('better-table');
              this.tableSelection = betterTableModule.tableSelection;
              this.table = params.table;
              this.quill = quill;
              this.options = options;
              this.menuItems = Object.assign({}, MENU_ITEMS_DEFAULT, options.items);
              this.tableColumnTool = betterTableModule.columnTool;
              this.boundary = this.tableSelection.boundary;
              this.selectedTds = this.tableSelection.selectedTds;
              this.destroyHanlder = this.destroy.bind(this);
              this.columnToolCells = this.tableColumnTool.colToolCells();
              this.colorSubTitle = options.color && options.color.text ? options.color.text : DEFAULT_COLOR_SUBTITLE;
              this.cellColors = options.color && options.color.colors ? options.color.colors : DEFAULT_CELL_COLORS;
              this.menuInitial(params);
              this.mount();
              document.addEventListener("click", this.destroyHanlder, false);
            }

            mount() {
              document.body.appendChild(this.domNode);
            }

            destroy() {
              this.domNode.remove();
              document.removeEventListener("click", this.destroyHanlder, false);
              return null;
            }

            menuInitial(_ref) {
              let {
                table,
                left,
                top
              } = _ref;
              this.domNode = document.createElement('div');
              this.domNode.classList.add('qlbt-operation-menu');
              css(this.domNode, {
                position: 'absolute',
                left: "".concat(left, "px"),
                top: "".concat(top, "px"),
                'min-height': "".concat(MENU_MIN_HEIHGT, "px"),
                width: "".concat(MENU_WIDTH, "px")
              });

              for (let name in this.menuItems) {
                if (this.menuItems[name]) {
                  this.domNode.appendChild(this.menuItemCreator(Object.assign({}, MENU_ITEMS_DEFAULT[name], this.menuItems[name])));

                  if (['insertRowDown', 'unmergeCells'].indexOf(name) > -1) {
                    this.domNode.appendChild(dividingCreator());
                  }
                }
              } // if colors option is false, disabled bg color


              if (this.options.color && this.options.color !== false) {
                this.domNode.appendChild(dividingCreator());
                this.domNode.appendChild(subTitleCreator(this.colorSubTitle));
                this.domNode.appendChild(this.colorsItemCreator(this.cellColors));
              } // create dividing line


              function dividingCreator() {
                const dividing = document.createElement('div');
                dividing.classList.add('qlbt-operation-menu-dividing');
                return dividing;
              } // create subtitle for menu


              function subTitleCreator(title) {
                const subTitle = document.createElement('div');
                subTitle.classList.add('qlbt-operation-menu-subtitle');
                subTitle.innerText = title;
                return subTitle;
              }
            }

            colorsItemCreator(colors) {
              const self = this;
              const node = document.createElement('div');
              node.classList.add('qlbt-operation-color-picker');
              colors.forEach(color => {
                let colorBox = colorBoxCreator(color);
                node.appendChild(colorBox);
              });

              function colorBoxCreator(color) {
                const box = document.createElement('div');
                box.classList.add('qlbt-operation-color-picker-item');
                box.setAttribute('data-color', color);
                box.style.backgroundColor = color;
                box.addEventListener('click', function () {
                  const selectedTds = self.tableSelection.selectedTds;

                  if (selectedTds && selectedTds.length > 0) {
                    selectedTds.forEach(tableCell => {
                      tableCell.format('cell-bg', color);
                    });
                  }
                }, false);
                return box;
              }

              return node;
            }

            menuItemCreator(_ref2) {
              let {
                text,
                iconSrc,
                handler
              } = _ref2;
              const node = document.createElement('div');
              node.classList.add('qlbt-operation-menu-item');
              const iconSpan = document.createElement('span');
              iconSpan.classList.add('qlbt-operation-menu-icon');
              iconSpan.innerHTML = iconSrc;
              const textSpan = document.createElement('span');
              textSpan.classList.add('qlbt-operation-menu-text');
              textSpan.innerText = text;
              node.appendChild(iconSpan);
              node.appendChild(textSpan);
              node.addEventListener('click', handler.bind(this), false);
              return node;
            }

          }

          function getColToolCellIndexByBoundary(cells, boundary, conditionFn, container) {
            return cells.reduce((findIndex, cell) => {
              let cellRect = getRelativeRect(cell.getBoundingClientRect(), container);

              if (conditionFn(cellRect, boundary)) {
                findIndex = cells.indexOf(cell);
              }

              return findIndex;
            }, false);
          }

          function getColToolCellIndexesByBoundary(cells, boundary, conditionFn, container) {
            return cells.reduce((findIndexes, cell) => {
              let cellRect = getRelativeRect(cell.getBoundingClientRect(), container);

              if (conditionFn(cellRect, boundary)) {
                findIndexes.push(cells.indexOf(cell));
              }

              return findIndexes;
            }, []);
          } // CONCATENATED MODULE: ./src/utils/node-matchers.js


          const Delta = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.import('delta'); // rebuild delta

          function matchTableCell(node, delta, scroll) {
            const row = node.parentNode;
            const table = row.parentNode.tagName === 'TABLE' ? row.parentNode : row.parentNode.parentNode;
            const rows = Array.from(table.querySelectorAll('tr'));
            const cells = Array.from(row.querySelectorAll('td'));
            const rowId = rows.indexOf(row) + 1;
            const cellId = cells.indexOf(node) + 1;
            const colspan = node.getAttribute('colspan') || false;
            const rowspan = node.getAttribute('rowspan') || false;
            const cellBg = node.getAttribute('data-cell-bg') || node.style.backgroundColor; // The td from external table has no 'data-cell-bg' 
            // bugfix: empty table cells copied from other place will be removed unexpectedly

            if (delta.length() === 0) {
              delta = new Delta().insert('\n', {
                'table-cell-line': {
                  row: rowId,
                  cell: cellId,
                  rowspan,
                  colspan
                }
              });
              return delta;
            }

            delta = delta.reduce((newDelta, op) => {
              if (op.insert && typeof op.insert === 'string') {
                const lines = [];
                let insertStr = op.insert;
                let start = 0;

                for (let i = 0; i < op.insert.length; i++) {
                  if (insertStr.charAt(i) === '\n') {
                    if (i === 0) {
                      lines.push('\n');
                    } else {
                      lines.push(insertStr.substring(start, i));
                      lines.push('\n');
                    }

                    start = i + 1;
                  }
                }

                const tailStr = insertStr.substring(start);
                if (tailStr) lines.push(tailStr);
                lines.forEach(text => {
                  text === '\n' ? newDelta.insert('\n', op.attributes) : newDelta.insert(text, _omit(op.attributes, ['table', 'table-cell-line']));
                });
              } else {
                newDelta.insert(op.insert, op.attributes);
              }

              return newDelta;
            }, new Delta());
            return delta.reduce((newDelta, op) => {
              if (op.insert && typeof op.insert === 'string' && op.insert.startsWith('\n')) {
                newDelta.insert(op.insert, Object.assign({}, Object.assign({}, {
                  row: rowId
                }, op.attributes.table), {
                  'table-cell-line': {
                    row: rowId,
                    cell: cellId,
                    rowspan,
                    colspan,
                    'cell-bg': cellBg
                  }
                }, _omit(op.attributes, ['table'])));
              } else {
                // bugfix: remove background attr from the delta of table cell
                //         to prevent unexcepted background attr append.
                if (op.attributes && op.attributes.background && op.attributes.background === convertToHex(cellBg)) {
                  newDelta.insert(op.insert, Object.assign({}, _omit(op.attributes, ['table', 'table-cell-line', 'background'])));
                } else {
                  newDelta.insert(op.insert, Object.assign({}, _omit(op.attributes, ['table', 'table-cell-line'])));
                }
              }

              return newDelta;
            }, new Delta());
          } // replace th tag with td tag


          function matchTableHeader(node, delta, scroll) {
            const row = node.parentNode;
            const table = row.parentNode.tagName === 'TABLE' ? row.parentNode : row.parentNode.parentNode;
            const rows = Array.from(table.querySelectorAll('tr'));
            const cells = Array.from(row.querySelectorAll('th'));
            const rowId = rows.indexOf(row) + 1;
            const cellId = cells.indexOf(node) + 1;
            const colspan = node.getAttribute('colspan') || false;
            const rowspan = node.getAttribute('rowspan') || false; // bugfix: empty table cells copied from other place will be removed unexpectedly

            if (delta.length() === 0) {
              delta = new Delta().insert('\n', {
                'table-cell-line': {
                  row: rowId,
                  cell: cellId,
                  rowspan,
                  colspan
                }
              });
              return delta;
            }

            delta = delta.reduce((newDelta, op) => {
              if (op.insert && typeof op.insert === 'string') {
                const lines = [];
                let insertStr = op.insert;
                let start = 0;

                for (let i = 0; i < op.insert.length; i++) {
                  if (insertStr.charAt(i) === '\n') {
                    if (i === 0) {
                      lines.push('\n');
                    } else {
                      lines.push(insertStr.substring(start, i));
                      lines.push('\n');
                    }

                    start = i + 1;
                  }
                }

                const tailStr = insertStr.substring(start);
                if (tailStr) lines.push(tailStr); // bugfix: no '\n' in op.insert, push a '\n' to lines

                if (lines.indexOf('\n') < 0) {
                  lines.push('\n');
                }

                lines.forEach(text => {
                  text === '\n' ? newDelta.insert('\n', {
                    'table-cell-line': {
                      row: rowId,
                      cell: cellId,
                      rowspan,
                      colspan
                    }
                  }) : newDelta.insert(text, op.attributes);
                });
              } else {
                newDelta.insert(op.insert, op.attributes);
              }

              return newDelta;
            }, new Delta());
            return delta.reduce((newDelta, op) => {
              if (op.insert && typeof op.insert === 'string' && op.insert.startsWith('\n')) {
                newDelta.insert(op.insert, Object.assign({}, {
                  'table-cell-line': {
                    row: rowId,
                    cell: cellId,
                    rowspan,
                    colspan
                  }
                }));
              } else {
                newDelta.insert(op.insert, Object.assign({}, _omit(op.attributes, ['table', 'table-cell-line'])));
              }

              return newDelta;
            }, new Delta());
          } // supplement colgroup and col


          function matchTable(node, delta, scroll) {
            let newColDelta = new Delta();
            const topRow = node.querySelector('tr'); // bugfix: empty table will return empty delta

            if (topRow === null) return newColDelta;
            const cellsInTopRow = Array.from(topRow.querySelectorAll('td')).concat(Array.from(topRow.querySelectorAll('th')));
            const maxCellsNumber = cellsInTopRow.reduce((sum, cell) => {
              const cellColspan = cell.getAttribute('colspan') || 1;
              sum = sum + parseInt(cellColspan, 10);
              return sum;
            }, 0);
            const colsNumber = node.querySelectorAll('col').length; // issue #2
            // bugfix: the table copied from Excel had some default col tags missing
            //         add missing col tags

            if (colsNumber === maxCellsNumber) {
              return delta;
            } else {
              for (let i = 0; i < maxCellsNumber - colsNumber; i++) {
                newColDelta.insert('\n', {
                  'table-col': true
                });
              }

              if (colsNumber === 0) return newColDelta.concat(delta);
              let lastNumber = 0;
              return delta.reduce((finalDelta, op) => {
                finalDelta.insert(op.insert, op.attributes);

                if (op.attributes && op.attributes['table-col']) {
                  lastNumber += op.insert.length;

                  if (lastNumber === colsNumber) {
                    finalDelta = finalDelta.concat(newColDelta);
                  }
                }

                return finalDelta;
              }, new Delta());
            }
          } // CONCATENATED MODULE: ./src/quill-better-table.js
          // import table node matchers


          const Module = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.import('core/module');
          const quill_better_table_Delta = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.import('delta');

          class quill_better_table_BetterTable extends Module {
            static register() {
              external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.register(TableCol, true);
              external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.register(TableColGroup, true);
              external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.register(TableCellLine, true);
              external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.register(TableCell, true);
              external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.register(TableRow, true);
              external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.register(TableBody, true);
              external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.register(table_TableContainer, true);
              external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.register(table_TableViewWrapper, true);
              external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.register(table_TableViewWrapper, true); // register customized Header，overwriting quill built-in Header
              // Quill.register('formats/header', Header, true);
            }

            constructor(quill, options) {
              super(quill, options); // handle click on quill-better-table

              this.quill.root.addEventListener('click', evt => {
                // bugfix: evt.path is undefined in Safari, FF, Micro Edge
                const path = getEventComposedPath(evt);
                if (!path || path.length <= 0) return;
                const tableNode = path.filter(node => {
                  return node.tagName && node.tagName.toUpperCase() === 'TABLE' && node.classList.contains('quill-better-table');
                })[0];

                if (tableNode) {
                  // current table clicked
                  if (this.table === tableNode) return; // other table clicked

                  if (this.table) this.hideTableTools();
                  this.showTableTools(tableNode, quill, options);
                } else if (this.table) {
                  // other clicked
                  this.hideTableTools();
                }
              }, false); // handle right click on quill-better-table

              this.quill.root.addEventListener('contextmenu', evt => {
                if (!this.table) return true;
                evt.preventDefault(); // bugfix: evt.path is undefined in Safari, FF, Micro Edge

                const path = getEventComposedPath(evt);
                if (!path || path.length <= 0) return;
                const tableNode = path.filter(node => {
                  return node.tagName && node.tagName.toUpperCase() === 'TABLE' && node.classList.contains('quill-better-table');
                })[0];
                const rowNode = path.filter(node => {
                  return node.tagName && node.tagName.toUpperCase() === 'TR' && node.getAttribute('data-row');
                })[0];
                const cellNode = path.filter(node => {
                  return node.tagName && node.tagName.toUpperCase() === 'TD' && node.getAttribute('data-row');
                })[0];
                let isTargetCellSelected = this.tableSelection.selectedTds.map(tableCell => tableCell.domNode).includes(cellNode);

                if (this.tableSelection.selectedTds.length <= 0 || !isTargetCellSelected) {
                  this.tableSelection.setSelection(cellNode.getBoundingClientRect(), cellNode.getBoundingClientRect());
                }

                if (this.tableOperationMenu) this.tableOperationMenu = this.tableOperationMenu.destroy();

                if (tableNode) {
                  this.tableOperationMenu = new table_operation_menu_TableOperationMenu({
                    table: tableNode,
                    row: rowNode,
                    cell: cellNode,
                    left: evt.pageX,
                    top: evt.pageY
                  }, quill, options.operationMenu);
                }
              }, false); // add keyboard binding：Backspace
              // prevent user hits backspace to delete table cell

              const KeyBoard = quill.getModule('keyboard');
              quill.keyboard.addBinding({
                key: 'Backspace'
              }, {}, function (range, context) {
                if (range.index === 0 || this.quill.getLength() <= 1) return true;
                const [line] = this.quill.getLine(range.index);

                if (context.offset === 0) {
                  const [prev] = this.quill.getLine(range.index - 1);

                  if (prev != null) {
                    if (prev.statics.blotName === 'table-cell-line' && line.statics.blotName !== 'table-cell-line') return false;
                  }
                }

                return true;
              }); // since only one matched bindings callback will excute.
              // expected my binding callback excute first
              // I changed the order of binding callbacks

              let thisBinding = quill.keyboard.bindings['Backspace'].pop();
              quill.keyboard.bindings['Backspace'].splice(0, 1, thisBinding); // add Matchers to match and render quill-better-table for initialization
              // or pasting

              quill.clipboard.addMatcher('td', matchTableCell);
              quill.clipboard.addMatcher('th', matchTableHeader);
              quill.clipboard.addMatcher('table', matchTable); // quill.clipboard.addMatcher('h1, h2, h3, h4, h5, h6', matchHeader)
              // remove matcher for tr tag

              quill.clipboard.matchers = quill.clipboard.matchers.filter(matcher => {
                return matcher[0] !== 'tr';
              });
            }

            getTable() {
              let range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.quill.getSelection();
              if (range == null) return [null, null, null, -1];
              const [cellLine, offset] = this.quill.getLine(range.index);

              if (cellLine == null || cellLine.statics.blotName !== TableCellLine.blotName) {
                return [null, null, null, -1];
              }

              const cell = cellLine.tableCell();
              const row = cell.row();
              const table = row.table();
              return [table, row, cell, offset];
            }

            insertTable(rows, columns) {
              const range = this.quill.getSelection(true);
              if (range == null) return;
              let currentBlot = this.quill.getLeaf(range.index)[0];
              let delta = new quill_better_table_Delta().retain(range.index);

              if (isInTableCell(currentBlot)) {
                console.warn("Can not insert table into a table cell.");
                return;
              }

              delta.insert('\n'); // insert table column

              delta = new Array(columns).fill('\n').reduce((memo, text) => {
                memo.insert(text, {
                  'table-col': true
                });
                return memo;
              }, delta); // insert table cell line with empty line

              delta = new Array(rows).fill(0).reduce(memo => {
                let tableRowId = table_rowId();
                return new Array(columns).fill('\n').reduce((memo, text) => {
                  memo.insert(text, {
                    'table-cell-line': {
                      row: tableRowId,
                      cell: table_cellId()
                    }
                  });
                  return memo;
                }, memo);
              }, delta);
              this.quill.updateContents(delta, external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
              this.quill.setSelection(range.index + columns + 1, external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.API);
            }

            showTableTools(table, quill, options) {
              this.table = table;
              this.columnTool = new table_column_tool_TableColumnTool(table, quill, options);
              this.tableSelection = new table_selection_TableSelection(table, quill, options);
            }

            hideTableTools() {
              this.columnTool && this.columnTool.destroy();
              this.tableSelection && this.tableSelection.destroy();
              this.tableOperationMenu && this.tableOperationMenu.destroy();
              this.columnTool = null;
              this.tableSelection = null;
              this.tableOperationMenu = null;
              this.table = null;
            }

          }

          quill_better_table_BetterTable.keyboardBindings = {
            'table-cell-line backspace': {
              key: 'Backspace',
              format: ['table-cell-line'],
              collapsed: true,
              offset: 0,

              handler(range, context) {
                const [line, offset] = this.quill.getLine(range.index);

                if (!line.prev || line.prev.statics.blotName !== 'table-cell-line') {
                  return false;
                }

                return true;
              }

            },
            'table-cell-line delete': {
              key: 'Delete',
              format: ['table-cell-line'],
              collapsed: true,
              suffix: /^$/,

              handler() {}

            },
            'table-cell-line enter': {
              key: 'Enter',
              shiftKey: null,
              format: ['table-cell-line'],

              handler(range, context) {
                // bugfix: a unexpected new line inserted when user compositionend with hitting Enter
                if (this.quill.selection && this.quill.selection.composing) return;
                const Scope = external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.imports.parchment.Scope;

                if (range.length > 0) {
                  this.quill.scroll.deleteAt(range.index, range.length); // So we do not trigger text-change
                }

                const lineFormats = Object.keys(context.format).reduce((formats, format) => {
                  if (this.quill.scroll.query(format, Scope.BLOCK) && !Array.isArray(context.format[format])) {
                    formats[format] = context.format[format];
                  }

                  return formats;
                }, {}); // insert new cellLine with lineFormats

                this.quill.insertText(range.index, '\n', lineFormats['table-cell-line'], external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER); // Earlier scroll.deleteAt might have messed up our selection,
                // so insertText's built in selection preservation is not reliable

                this.quill.setSelection(range.index + 1, external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.SILENT);
                this.quill.focus();
                Object.keys(context.format).forEach(name => {
                  if (lineFormats[name] != null) return;
                  if (Array.isArray(context.format[name])) return;
                  if (name === 'link') return;
                  this.quill.format(name, context.format[name], external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                });
              }

            },
            'table-cell-line up': makeTableArrowHandler(true),
            'table-cell-line down': makeTableArrowHandler(false),
            'down-to-table': {
              key: 'ArrowDown',
              collapsed: true,

              handler(range, context) {
                const target = context.line.next;

                if (target && target.statics.blotName === 'table-view') {
                  const targetCell = target.table().rows()[0].children.head;
                  const targetLine = targetCell.children.head;
                  this.quill.setSelection(targetLine.offset(this.quill.scroll), 0, external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                  return false;
                }

                return true;
              }

            },
            'up-to-table': {
              key: 'ArrowUp',
              collapsed: true,

              handler(range, context) {
                const target = context.line.prev;

                if (target && target.statics.blotName === 'table-view') {
                  const rows = target.table().rows();
                  const targetCell = rows[rows.length - 1].children.head;
                  const targetLine = targetCell.children.head;
                  this.quill.setSelection(targetLine.offset(this.quill.scroll), 0, external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                  return false;
                }

                return true;
              }

            }
          };

          function makeTableArrowHandler(up) {
            return {
              key: up ? 'ArrowUp' : 'ArrowDown',
              collapsed: true,
              format: ['table-cell-line'],

              handler(range, context) {
                // TODO move to table module
                const key = up ? 'prev' : 'next';
                const targetLine = context.line[key];
                if (targetLine != null) return true;
                const cell = context.line.parent;
                const targetRow = cell.parent[key];

                if (targetRow != null && targetRow.statics.blotName === 'table-row') {
                  let targetCell = targetRow.children.head;
                  let totalColspanOfTargetCell = parseInt(targetCell.formats()['colspan'], 10);
                  let cur = cell;
                  let totalColspanOfCur = parseInt(cur.formats()['colspan'], 10); // get targetCell above current cell depends on colspan

                  while (cur.prev != null) {
                    cur = cur.prev;
                    totalColspanOfCur += parseInt(cur.formats()['colspan'], 10);
                  }

                  while (targetCell.next != null && totalColspanOfTargetCell < totalColspanOfCur) {
                    targetCell = targetCell.next;
                    totalColspanOfTargetCell += parseInt(targetCell.formats()['colspan'], 10);
                  }

                  const index = targetCell.offset(this.quill.scroll);
                  this.quill.setSelection(index, 0, external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                } else {
                  const targetLine = cell.table().parent[key];

                  if (targetLine != null) {
                    if (up) {
                      this.quill.setSelection(targetLine.offset(this.quill.scroll) + targetLine.length() - 1, 0, external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                    } else {
                      this.quill.setSelection(targetLine.offset(this.quill.scroll), 0, external_commonjs_quill_commonjs2_quill_amd_quill_root_Quill_default.a.sources.USER);
                    }
                  }
                }

                return false;
              }

            };
          }

          function isTableCell(blot) {
            return blot.statics.blotName === TableCell.blotName;
          }

          function isInTableCell(current) {
            return current && current.parent ? isTableCell(current.parent) ? true : isInTableCell(current.parent) : false;
          }
          /* harmony default export */


          var quill_better_table = __webpack_exports__["default"] = quill_better_table_BetterTable;
          /***/
        },,
        /* 11 */

        /* 12 */

        /***/
        function (module, exports, __webpack_require__) {
          module.exports = __webpack_require__(10);
          /***/
        }
        /******/
        ])["default"]
      );
    });
    });

    var QuillBetterTable = unwrapExports(quillBetterTable);

    /* src\PDF.svelte generated by Svelte v3.17.1 */
    const file$c = "src\\PDF.svelte"; // (140:42) 

    function create_if_block_1$5(ctx) {
      let p;
      const block = {
        c: function create() {
          p = element("p");
          p.textContent = "The footer appears at the bottom of each page.";
          add_location(p, file$c, 140, 4, 6397);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$5.name,
        type: "if",
        source: "(140:42) ",
        ctx
      });
      return block;
    } // (138:0) {#if pdfSettings.editing == 'header'}


    function create_if_block$7(ctx) {
      let p;
      const block = {
        c: function create() {
          p = element("p");
          p.textContent = "The header appears at the top of each page.";
          add_location(p, file$c, 138, 4, 6297);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$7.name,
        type: "if",
        source: "(138:0) {#if pdfSettings.editing == 'header'}",
        ctx
      });
      return block;
    }

    function create_fragment$c(ctx) {
      let h3;
      let t0;
      let t1_value =
      /*pdfSettings*/
      ctx[0].editing + "";
      let t1;
      let t2;
      let t3;
      let t4;
      let div2;
      let div0;
      let select;
      let t5;
      let span0;
      let button0;
      let t6;
      let button1;
      let t7;
      let button2;
      let t8;
      let button3;
      let t9;
      let span1;
      let button4;
      let t10;
      let button5;
      let t11;
      let button6;
      let t12;
      let span2;
      let button7;
      let svg;
      let g;
      let path0;
      let path1;
      let path2;
      let t13;
      let button8;
      let t14;
      let button9;
      let t15;
      let div1;
      let t16;
      let div3;
      let button10;
      let t18;
      let button11;
      let t20;
      let div4;
      let button12;
      let dispose;

      function select_block_type(ctx, dirty) {
        if (
        /*pdfSettings*/
        ctx[0].editing == "header") return create_if_block$7;
        if (
        /*pdfSettings*/
        ctx[0].editing == "footer") return create_if_block_1$5;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type && current_block_type(ctx);
      const block = {
        c: function create() {
          h3 = element("h3");
          t0 = text("Editing \"");
          t1 = text(t1_value);
          t2 = text("\"");
          t3 = space();
          if (if_block) if_block.c();
          t4 = space();
          div2 = element("div");
          div0 = element("div");
          select = element("select");
          t5 = space();
          span0 = element("span");
          button0 = element("button");
          t6 = space();
          button1 = element("button");
          t7 = space();
          button2 = element("button");
          t8 = space();
          button3 = element("button");
          t9 = space();
          span1 = element("span");
          button4 = element("button");
          t10 = space();
          button5 = element("button");
          t11 = space();
          button6 = element("button");
          t12 = space();
          span2 = element("span");
          button7 = element("button");
          svg = svg_element("svg");
          g = svg_element("g");
          path0 = svg_element("path");
          path1 = svg_element("path");
          path2 = svg_element("path");
          t13 = space();
          button8 = element("button");
          t14 = space();
          button9 = element("button");
          t15 = space();
          div1 = element("div");
          t16 = space();
          div3 = element("div");
          button10 = element("button");
          button10.textContent = "Save";
          t18 = space();
          button11 = element("button");
          button11.textContent = "Cancel";
          t20 = space();
          div4 = element("div");
          button12 = element("button");
          button12.textContent = "Clear";
          add_location(h3, file$c, 136, 0, 6212);
          attr_dev(select, "class", "ql-header toolbar-block svelte-tuwaa3");
          add_location(select, file$c, 145, 8, 6525);
          attr_dev(button0, "class", "ql-list");
          button0.value = "ordered";
          add_location(button0, file$c, 147, 12, 6637);
          attr_dev(button1, "class", "ql-list");
          button1.value = "bullet";
          add_location(button1, file$c, 148, 12, 6693);
          attr_dev(button2, "class", "ql-indent");
          button2.value = "-1";
          add_location(button2, file$c, 149, 12, 6748);
          attr_dev(button3, "class", "ql-indent");
          button3.value = "+1";
          add_location(button3, file$c, 150, 12, 6801);
          attr_dev(span0, "class", "ql-formats toolbar-block svelte-tuwaa3");
          add_location(span0, file$c, 146, 8, 6584);
          attr_dev(button4, "class", "ql-bold");
          attr_dev(button4, "data-toggle", "tooltip");
          attr_dev(button4, "data-placement", "bottom");
          attr_dev(button4, "title", "Bold");
          add_location(button4, file$c, 153, 12, 6909);
          attr_dev(button5, "class", "ql-italic");
          attr_dev(button5, "data-toggle", "tooltip");
          attr_dev(button5, "data-placement", "bottom");
          attr_dev(button5, "title", "Italic");
          add_location(button5, file$c, 154, 12, 7007);
          attr_dev(button6, "class", "ql-underline");
          attr_dev(button6, "data-toggle", "tooltip");
          attr_dev(button6, "data-placement", "bottom");
          attr_dev(button6, "title", "Underline");
          add_location(button6, file$c, 155, 12, 7109);
          attr_dev(span1, "class", "toolbar-block svelte-tuwaa3");
          add_location(span1, file$c, 152, 8, 6867);
          attr_dev(path0, "class", "ql-stroke");
          attr_dev(path0, "d", "m15.214 288.31v-7.1582h-9.5247l-3.2559 3.7008v3.4573");
          attr_dev(path0, "stroke-linejoin", "round");
          add_location(path0, file$c, 161, 24, 7455);
          attr_dev(path1, "class", "ql-stroke");
          attr_dev(path1, "d", "m2.4588 285.6h4.0524v-4.3986");
          attr_dev(path1, "stroke-linejoin", "round");
          add_location(path1, file$c, 162, 24, 7587);
          attr_dev(path2, "class", "ql-stroke");
          attr_dev(path2, "d", "m1.9054 292.61 13.856-0.0539");
          attr_dev(path2, "stroke-dasharray", "1, 3");
          attr_dev(path2, "stroke-dashoffset", "3.6");
          add_location(path2, file$c, 163, 24, 7695);
          attr_dev(g, "transform", "translate(0,-279)");
          attr_dev(g, "fill", "none");
          add_location(g, file$c, 160, 20, 7384);
          attr_dev(svg, "viewBox", "0 0 18 18");
          add_location(svg, file$c, 159, 16, 7337);
          attr_dev(button7, "class", "ql-pagebreak");
          button7.value = "pagebreak";
          add_location(button7, file$c, 158, 12, 7272);
          add_location(button8, file$c, 167, 12, 7888);
          add_location(button9, file$c, 168, 12, 7919);
          attr_dev(span2, "class", "toolbar-block svelte-tuwaa3");
          add_location(span2, file$c, 157, 8, 7230);
          attr_dev(div0, "id", "toolbar-container");
          add_location(div0, file$c, 144, 4, 6487);
          attr_dev(div1, "id", "editor");
          attr_dev(div1, "class", "svelte-tuwaa3");
          add_location(div1, file$c, 172, 4, 7973);
          attr_dev(div2, "id", "container");
          attr_dev(div2, "class", "svelte-tuwaa3");
          add_location(div2, file$c, 143, 0, 6461);
          attr_dev(button10, "class", "blue svelte-tuwaa3");
          attr_dev(button10, "type", "submit");
          add_location(button10, file$c, 176, 4, 8039);
          attr_dev(button11, "type", "submit");
          attr_dev(button11, "class", "svelte-tuwaa3");
          add_location(button11, file$c, 177, 4, 8190);
          attr_dev(div3, "class", "align-right svelte-tuwaa3");
          add_location(div3, file$c, 175, 0, 8008);
          attr_dev(button12, "type", "submit");
          attr_dev(button12, "class", "svelte-tuwaa3");
          add_location(button12, file$c, 180, 4, 8325);
          attr_dev(div4, "class", "align-right svelte-tuwaa3");
          add_location(div4, file$c, 179, 0, 8294);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          append_dev(h3, t0);
          append_dev(h3, t1);
          append_dev(h3, t2);
          insert_dev(target, t3, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, t4, anchor);
          insert_dev(target, div2, anchor);
          append_dev(div2, div0);
          append_dev(div0, select);
          append_dev(div0, t5);
          append_dev(div0, span0);
          append_dev(span0, button0);
          append_dev(span0, t6);
          append_dev(span0, button1);
          append_dev(span0, t7);
          append_dev(span0, button2);
          append_dev(span0, t8);
          append_dev(span0, button3);
          append_dev(div0, t9);
          append_dev(div0, span1);
          append_dev(span1, button4);
          append_dev(span1, t10);
          append_dev(span1, button5);
          append_dev(span1, t11);
          append_dev(span1, button6);
          append_dev(div0, t12);
          append_dev(div0, span2);
          append_dev(span2, button7);
          append_dev(button7, svg);
          append_dev(svg, g);
          append_dev(g, path0);
          append_dev(g, path1);
          append_dev(g, path2);
          append_dev(span2, t13);
          append_dev(span2, button8);
          append_dev(span2, t14);
          append_dev(span2, button9);
          append_dev(div2, t15);
          append_dev(div2, div1);
          insert_dev(target, t16, anchor);
          insert_dev(target, div3, anchor);
          append_dev(div3, button10);
          append_dev(div3, t18);
          append_dev(div3, button11);
          insert_dev(target, t20, anchor);
          insert_dev(target, div4, anchor);
          append_dev(div4, button12);
          dispose = [listen_dev(button10, "click", prevent_default(
          /*click_handler*/
          ctx[10]), false, true, false), listen_dev(button11, "click", prevent_default(
          /*click_handler_1*/
          ctx[11]), false, true, false), listen_dev(button12, "click", prevent_default(
          /*clearData*/
          ctx[3]), false, true, false)];
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*pdfSettings*/
          1 && t1_value !== (t1_value =
          /*pdfSettings*/
          ctx[0].editing + "")) set_data_dev(t1, t1_value);

          if (current_block_type !== (current_block_type = select_block_type(ctx))) {
            if (if_block) if_block.d(1);
            if_block = current_block_type && current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(t4.parentNode, t4);
            }
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t3);

          if (if_block) {
            if_block.d(detaching);
          }

          if (detaching) detach_dev(t4);
          if (detaching) detach_dev(div2);
          if (detaching) detach_dev(t16);
          if (detaching) detach_dev(div3);
          if (detaching) detach_dev(t20);
          if (detaching) detach_dev(div4);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$c.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
      let $settings;
      validate_store(settings, "settings");
      component_subscribe($$self, settings, $$value => $$invalidate(7, $settings = $$value));
      const dispatch = createEventDispatcher();
      let {
        pdfSettings
      } = $$props;
      let {
        content
      } = $$props;
      let variablesList = [];

      if (pdfSettings.editing == "body") {
        variablesList = ["First name", "Last name", "Date issued", formatText($settings.services, true, true), formatText($settings.students, false, true) + " notes", "Current page"];
      } else if (pdfSettings.editing == "header" || pdfSettings.editing == "footer") {
        variablesList = ["First name", "Last name", "Date issued", "Current page"];
      }

      Quill.register({
        "modules/better-table": QuillBetterTable
      }, true);
      let quillOptions = {
        modules: {
          table: false,
          "better-table": {
            operationMenu: {
              "insertColumnRight": true
            },
            keyboard: {
              bindings: QuillBetterTable.keyboardBindings
            }
          },
          toolbar: {
            container: "#toolbar-container"
          }
        },
        placeholder: pdfSettings.placeholder,
        theme: "snow"
      };

      let clearData = () => {
        document.querySelector(".ql-editor").innerHTML = "";
        $$invalidate(4, content = "");
      };

      let editor;
      let table;
      let addTable;
      onMount(() => {
        $$invalidate(1, editor = new Quill("#editor", quillOptions));
        table = editor.getModule("better-table");
        const tablePickerItems = Array.prototype.slice.call(document.querySelectorAll(".ql-table .ql-picker-item"));
        tablePickerItems.forEach(item => item.textContent = item.dataset.value);
        const variableItems = Array.prototype.slice.call(document.querySelectorAll(".ql-variables .ql-picker-item"));
        variableItems.forEach(item => item.textContent = item.dataset.value);
        document.querySelector("style").innerHTML += ".ql-table .ql-picker-label:before, .ql-variables .ql-picker-label:before, .ql-table { content: 'Grid'; display: inline-block; line-height: 22px; margin-right: 2.5em; } .ql-variables .ql-picker-label:before { content: 'Variables' } .qlbt-col-tool { z-index: initial; } .quill-better-table-wrapper { max-width: 100%; }";
        document.querySelector(".ql-editor").addEventListener("click", () => {
          let tds = document.querySelectorAll(".ql-editor td");
          tds.forEach(td => {
            td.style = "border-color: gray; border-width: 1px; border-style: dotted;";
          });
        });
        editor.setContents(content);
      });
      const writable_props = ["pdfSettings", "content"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PDF> was created with unknown prop '${key}'`);
      });

      const click_handler = () => {
        dispatch("save", editor.getContents());
        dispatch("forceClose");
      };

      const click_handler_1 = () => {
        dispatch("forceClose");
      };

      $$self.$set = $$props => {
        if ("pdfSettings" in $$props) $$invalidate(0, pdfSettings = $$props.pdfSettings);
        if ("content" in $$props) $$invalidate(4, content = $$props.content);
      };

      $$self.$capture_state = () => {
        return {
          pdfSettings,
          content,
          variablesList,
          quillOptions,
          clearData,
          editor,
          table,
          addTable,
          $settings
        };
      };

      $$self.$inject_state = $$props => {
        if ("pdfSettings" in $$props) $$invalidate(0, pdfSettings = $$props.pdfSettings);
        if ("content" in $$props) $$invalidate(4, content = $$props.content);
        if ("variablesList" in $$props) variablesList = $$props.variablesList;
        if ("quillOptions" in $$props) quillOptions = $$props.quillOptions;
        if ("clearData" in $$props) $$invalidate(3, clearData = $$props.clearData);
        if ("editor" in $$props) $$invalidate(1, editor = $$props.editor);
        if ("table" in $$props) table = $$props.table;
        if ("addTable" in $$props) addTable = $$props.addTable;
        if ("$settings" in $$props) settings.set($settings = $$props.$settings);
      };

      return [pdfSettings, editor, dispatch, clearData, content, variablesList, table, $settings, quillOptions, addTable, click_handler, click_handler_1];
    }

    class PDF extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$c, create_fragment$c, safe_not_equal, {
          pdfSettings: 0,
          content: 4
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "PDF",
          options,
          id: create_fragment$c.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*pdfSettings*/
        ctx[0] === undefined && !("pdfSettings" in props)) {
          console.warn("<PDF> was created without expected prop 'pdfSettings'");
        }

        if (
        /*content*/
        ctx[4] === undefined && !("content" in props)) {
          console.warn("<PDF> was created without expected prop 'content'");
        }
      }

      get pdfSettings() {
        throw new Error("<PDF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set pdfSettings(value) {
        throw new Error("<PDF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get content() {
        throw new Error("<PDF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set content(value) {
        throw new Error("<PDF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\LOATemplate.svelte generated by Svelte v3.17.1 */
    const file$d = "src\\LOATemplate.svelte"; // (94:0) {#if pdfHeaderModalOpen}

    function create_if_block_4$3(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_4$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_1*/
      ctx[22]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty &
          /*$$scope, headerData, pdfHeaderModalOpen*/
          1073741857) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$3.name,
        type: "if",
        source: "(94:0) {#if pdfHeaderModalOpen}",
        ctx
      });
      return block;
    } // (95:4) <Modal on:forceClose={()=>{ pdfHeaderModalOpen = false }}>


    function create_default_slot_4$1(ctx) {
      let current;
      const pdf = new PDF({
        props: {
          pdfSettings: {
            editing: "header",
            placeholder: "Your header here..."
          },
          content:
          /*headerData*/
          ctx[5]
        },
        $$inline: true
      });
      pdf.$on("forceClose",
      /*forceClose_handler*/
      ctx[21]);
      pdf.$on("save",
      /*saveHeader*/
      ctx[10]);
      const block = {
        c: function create() {
          create_component(pdf.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(pdf, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const pdf_changes = {};
          if (dirty &
          /*headerData*/
          32) pdf_changes.content =
          /*headerData*/
          ctx[5];
          pdf.$set(pdf_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(pdf.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(pdf.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(pdf, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$1.name,
        type: "slot",
        source: "(95:4) <Modal on:forceClose={()=>{ pdfHeaderModalOpen = false }}>",
        ctx
      });
      return block;
    } // (99:0) {#if pdfBodyModalOpen}


    function create_if_block_3$4(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_3$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_3*/
      ctx[24]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty &
          /*$$scope, bodyData, pdfBodyModalOpen*/
          1073741890) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$4.name,
        type: "if",
        source: "(99:0) {#if pdfBodyModalOpen}",
        ctx
      });
      return block;
    } // (100:4) <Modal on:forceClose={()=>{ pdfBodyModalOpen = false }}>


    function create_default_slot_3$1(ctx) {
      let current;
      const pdf = new PDF({
        props: {
          pdfSettings: {
            editing: "body",
            placeholder: "Write your document here!"
          },
          content:
          /*bodyData*/
          ctx[6]
        },
        $$inline: true
      });
      pdf.$on("forceClose",
      /*forceClose_handler_2*/
      ctx[23]);
      pdf.$on("save",
      /*saveBody*/
      ctx[11]);
      const block = {
        c: function create() {
          create_component(pdf.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(pdf, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const pdf_changes = {};
          if (dirty &
          /*bodyData*/
          64) pdf_changes.content =
          /*bodyData*/
          ctx[6];
          pdf.$set(pdf_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(pdf.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(pdf.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(pdf, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$1.name,
        type: "slot",
        source: "(100:4) <Modal on:forceClose={()=>{ pdfBodyModalOpen = false }}>",
        ctx
      });
      return block;
    } // (104:0) {#if pdfFooterModalOpen}


    function create_if_block_2$4(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_2$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_5*/
      ctx[26]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty &
          /*$$scope, footerData, pdfFooterModalOpen*/
          1073741956) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$4.name,
        type: "if",
        source: "(104:0) {#if pdfFooterModalOpen}",
        ctx
      });
      return block;
    } // (105:4) <Modal on:forceClose={()=>{ pdfFooterModalOpen = false }}>


    function create_default_slot_2$3(ctx) {
      let current;
      const pdf = new PDF({
        props: {
          pdfSettings: {
            editing: "footer",
            placeholder: "Your footer here..."
          },
          content:
          /*footerData*/
          ctx[7]
        },
        $$inline: true
      });
      pdf.$on("forceClose",
      /*forceClose_handler_4*/
      ctx[25]);
      pdf.$on("save",
      /*saveFooter*/
      ctx[12]);
      const block = {
        c: function create() {
          create_component(pdf.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(pdf, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const pdf_changes = {};
          if (dirty &
          /*footerData*/
          128) pdf_changes.content =
          /*footerData*/
          ctx[7];
          pdf.$set(pdf_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(pdf.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(pdf.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(pdf, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$3.name,
        type: "slot",
        source: "(105:4) <Modal on:forceClose={()=>{ pdfFooterModalOpen = false }}>",
        ctx
      });
      return block;
    } // (109:0) {#if previewModalOpen}


    function create_if_block_1$6(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_1$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_6*/
      ctx[27]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty &
          /*$$scope*/
          1073741824) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$6.name,
        type: "if",
        source: "(109:0) {#if previewModalOpen}",
        ctx
      });
      return block;
    } // (110:4) <Modal on:forceClose={()=>{ previewModalOpen = false }}>


    function create_default_slot_1$3(ctx) {
      let h3;
      let t1;
      let p;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "Building PDF";
          t1 = space();
          p = element("p");
          p.textContent = "Your preview will be available shortly!";
          add_location(h3, file$d, 110, 8, 4719);
          add_location(p, file$d, 111, 8, 4750);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, p, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$3.name,
        type: "slot",
        source: "(110:4) <Modal on:forceClose={()=>{ previewModalOpen = false }}>",
        ctx
      });
      return block;
    } // (115:0) {#if docErrorModalOpen}


    function create_if_block$8(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot$6]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_7*/
      ctx[29]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty &
          /*$$scope, docErrorModalOpen*/
          1073741840) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$8.name,
        type: "if",
        source: "(115:0) {#if docErrorModalOpen}",
        ctx
      });
      return block;
    } // (116:4) <Modal on:forceClose={()=>{ docErrorModalOpen = false }}>


    function create_default_slot$6(ctx) {
      let h3;
      let t1;
      let p;
      let t3;
      let button;
      let dispose;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "Whoops!";
          t1 = space();
          p = element("p");
          p.textContent = "There was an error opening your preview. Make sure the document is not already open, and close it if it is.";
          t3 = space();
          button = element("button");
          button.textContent = "OK";
          add_location(h3, file$d, 116, 8, 4915);
          add_location(p, file$d, 117, 8, 4941);
          attr_dev(button, "type", "submit");
          attr_dev(button, "class", "centered blue");
          add_location(button, file$d, 118, 8, 5065);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, p, anchor);
          insert_dev(target, t3, anchor);
          insert_dev(target, button, anchor);
          dispose = listen_dev(button, "click", prevent_default(
          /*click_handler_3*/
          ctx[28]), false, true, false);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(p);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(button);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$6.name,
        type: "slot",
        source: "(116:4) <Modal on:forceClose={()=>{ docErrorModalOpen = false }}>",
        ctx
      });
      return block;
    }

    function create_fragment$d(ctx) {
      let div;
      let h2;
      let t0_value = formatText(
      /*$settings*/
      ctx[8].abbrev, false, false, true) + "";
      let t0;
      let t1;
      let t2;
      let p0;
      let t3;
      let t4_value = formatText(
      /*$settings*/
      ctx[8].abbrev, false, false, true) + "";
      let t4;
      let t5;
      let t6;
      let h30;
      let t8;
      let ul0;
      let li0;
      let a0;
      let t10;
      let t11;
      let li1;
      let a1;
      let t13;
      let t14;
      let li2;
      let a2;
      let t16;
      let t17;
      let button;
      let t19;
      let h31;
      let t21;
      let p1;
      let t23;
      let ul1;
      let li3;
      let t24;
      let li4;
      let t25;
      let li5;
      let t26;
      let li6;
      let t27;
      let li7;
      let div_intro;
      let div_outro;
      let t28;
      let t29;
      let t30;
      let t31;
      let t32;
      let if_block4_anchor;
      let current;
      let dispose;
      let if_block0 =
      /*pdfHeaderModalOpen*/
      ctx[0] && create_if_block_4$3(ctx);
      let if_block1 =
      /*pdfBodyModalOpen*/
      ctx[1] && create_if_block_3$4(ctx);
      let if_block2 =
      /*pdfFooterModalOpen*/
      ctx[2] && create_if_block_2$4(ctx);
      let if_block3 =
      /*previewModalOpen*/
      ctx[3] && create_if_block_1$6(ctx);
      let if_block4 =
      /*docErrorModalOpen*/
      ctx[4] && create_if_block$8(ctx);
      const block = {
        c: function create() {
          div = element("div");
          h2 = element("h2");
          t0 = text(t0_value);
          t1 = text(" Template");
          t2 = space();
          p0 = element("p");
          t3 = text("Set up your ");
          t4 = text(t4_value);
          t5 = text(" template below.");
          t6 = space();
          h30 = element("h3");
          h30.textContent = "Edit Sections";
          t8 = space();
          ul0 = element("ul");
          li0 = element("li");
          a0 = element("a");
          a0.textContent = "Header";
          t10 = text(" - The header appears at the top of every page.");
          t11 = space();
          li1 = element("li");
          a1 = element("a");
          a1.textContent = "Body";
          t13 = text(" - The body makes up the majority of your document, and may span multiple pages.");
          t14 = space();
          li2 = element("li");
          a2 = element("a");
          a2.textContent = "Footer";
          t16 = text(" - The footer appears at the bottom of each page.");
          t17 = space();
          button = element("button");
          button.textContent = "Preview";
          t19 = space();
          h31 = element("h3");
          h31.textContent = "Tips";
          t21 = space();
          p1 = element("p");
          p1.textContent = "Here are some things to consider as you create your template:";
          t23 = space();
          ul1 = element("ul");
          li3 = element("li");
          t24 = space();
          li4 = element("li");
          t25 = space();
          li5 = element("li");
          t26 = space();
          li6 = element("li");
          t27 = space();
          li7 = element("li");
          t28 = space();
          if (if_block0) if_block0.c();
          t29 = space();
          if (if_block1) if_block1.c();
          t30 = space();
          if (if_block2) if_block2.c();
          t31 = space();
          if (if_block3) if_block3.c();
          t32 = space();
          if (if_block4) if_block4.c();
          if_block4_anchor = empty();
          add_location(h2, file$d, 71, 4, 2749);
          add_location(p0, file$d, 72, 4, 2823);
          add_location(h30, file$d, 74, 4, 2916);
          attr_dev(a0, "href", "heading");
          add_location(a0, file$d, 76, 12, 2962);
          add_location(li0, file$d, 76, 8, 2958);
          attr_dev(a1, "href", "body");
          add_location(a1, file$d, 77, 12, 3114);
          add_location(li1, file$d, 77, 8, 3110);
          attr_dev(a2, "href", "footer");
          add_location(a2, file$d, 78, 12, 3292);
          add_location(li2, file$d, 78, 8, 3288);
          add_location(ul0, file$d, 75, 4, 2944);
          attr_dev(button, "type", "submit");
          add_location(button, file$d, 80, 4, 3448);
          add_location(h31, file$d, 82, 4, 3528);
          add_location(p1, file$d, 83, 4, 3547);
          add_location(li3, file$d, 85, 8, 3635);
          add_location(li4, file$d, 86, 8, 3654);
          add_location(li5, file$d, 87, 8, 3673);
          add_location(li6, file$d, 88, 8, 3692);
          add_location(li7, file$d, 89, 8, 3711);
          add_location(ul1, file$d, 84, 4, 3621);
          set_style(div, "position", "relative");
          add_location(div, file$d, 70, 0, 2661);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, h2);
          append_dev(h2, t0);
          append_dev(h2, t1);
          append_dev(div, t2);
          append_dev(div, p0);
          append_dev(p0, t3);
          append_dev(p0, t4);
          append_dev(p0, t5);
          append_dev(div, t6);
          append_dev(div, h30);
          append_dev(div, t8);
          append_dev(div, ul0);
          append_dev(ul0, li0);
          append_dev(li0, a0);
          append_dev(li0, t10);
          append_dev(ul0, t11);
          append_dev(ul0, li1);
          append_dev(li1, a1);
          append_dev(li1, t13);
          append_dev(ul0, t14);
          append_dev(ul0, li2);
          append_dev(li2, a2);
          append_dev(li2, t16);
          append_dev(div, t17);
          append_dev(div, button);
          append_dev(div, t19);
          append_dev(div, h31);
          append_dev(div, t21);
          append_dev(div, p1);
          append_dev(div, t23);
          append_dev(div, ul1);
          append_dev(ul1, li3);
          append_dev(ul1, t24);
          append_dev(ul1, li4);
          append_dev(ul1, t25);
          append_dev(ul1, li5);
          append_dev(ul1, t26);
          append_dev(ul1, li6);
          append_dev(ul1, t27);
          append_dev(ul1, li7);
          insert_dev(target, t28, anchor);
          if (if_block0) if_block0.m(target, anchor);
          insert_dev(target, t29, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert_dev(target, t30, anchor);
          if (if_block2) if_block2.m(target, anchor);
          insert_dev(target, t31, anchor);
          if (if_block3) if_block3.m(target, anchor);
          insert_dev(target, t32, anchor);
          if (if_block4) if_block4.m(target, anchor);
          insert_dev(target, if_block4_anchor, anchor);
          current = true;
          dispose = [listen_dev(a0, "click", prevent_default(
          /*click_handler*/
          ctx[18]), false, true, false), listen_dev(a1, "click", prevent_default(
          /*click_handler_1*/
          ctx[19]), false, true, false), listen_dev(a2, "click", prevent_default(
          /*click_handler_2*/
          ctx[20]), false, true, false), listen_dev(button, "click", prevent_default(
          /*preview*/
          ctx[9]), false, true, false)];
        },
        p: function update(ctx, [dirty]) {
          if ((!current || dirty &
          /*$settings*/
          256) && t0_value !== (t0_value = formatText(
          /*$settings*/
          ctx[8].abbrev, false, false, true) + "")) set_data_dev(t0, t0_value);
          if ((!current || dirty &
          /*$settings*/
          256) && t4_value !== (t4_value = formatText(
          /*$settings*/
          ctx[8].abbrev, false, false, true) + "")) set_data_dev(t4, t4_value);

          if (
          /*pdfHeaderModalOpen*/
          ctx[0]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
              transition_in(if_block0, 1);
            } else {
              if_block0 = create_if_block_4$3(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(t29.parentNode, t29);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*pdfBodyModalOpen*/
          ctx[1]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
              transition_in(if_block1, 1);
            } else {
              if_block1 = create_if_block_3$4(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(t30.parentNode, t30);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (
          /*pdfFooterModalOpen*/
          ctx[2]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);
              transition_in(if_block2, 1);
            } else {
              if_block2 = create_if_block_2$4(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(t31.parentNode, t31);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          if (
          /*previewModalOpen*/
          ctx[3]) {
            if (if_block3) {
              if_block3.p(ctx, dirty);
              transition_in(if_block3, 1);
            } else {
              if_block3 = create_if_block_1$6(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(t32.parentNode, t32);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }

          if (
          /*docErrorModalOpen*/
          ctx[4]) {
            if (if_block4) {
              if_block4.p(ctx, dirty);
              transition_in(if_block4, 1);
            } else {
              if_block4 = create_if_block$8(ctx);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (div_outro) div_outro.end(1);
            if (!div_intro) div_intro = create_in_transition(div, fly, {
              x: 100,
              delay: 500
            });
            div_intro.start();
          });
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(if_block3);
          transition_in(if_block4);
          current = true;
        },
        o: function outro(local) {
          if (div_intro) div_intro.invalidate();
          div_outro = create_out_transition(div, fly, {
            x: 100
          });
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(if_block3);
          transition_out(if_block4);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching && div_outro) div_outro.end();
          if (detaching) detach_dev(t28);
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach_dev(t29);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach_dev(t30);
          if (if_block2) if_block2.d(detaching);
          if (detaching) detach_dev(t31);
          if (if_block3) if_block3.d(detaching);
          if (detaching) detach_dev(t32);
          if (if_block4) if_block4.d(detaching);
          if (detaching) detach_dev(if_block4_anchor);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$d.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
      let $settings;
      validate_store(settings, "settings");
      component_subscribe($$self, settings, $$value => $$invalidate(8, $settings = $$value));

      const cp = require("child_process");

      const fs = require("fs");

      const app = require("electron").remote.app;

      const root = app.getAppPath();
      let pdfHeaderModalOpen = false;
      let pdfBodyModalOpen = false;
      let pdfFooterModalOpen = false;
      let previewModalOpen = false;
      let docErrorModalOpen = false;
      let headerData = fs.existsSync(root + "/appdata/header.json") ? JSON.parse(fs.readFileSync(root + "/appdata/header.json")) : [];
      let bodyData = fs.existsSync(root + "/appdata/body.json") ? JSON.parse(fs.readFileSync(root + "/appdata/body.json")) : [];
      let footerData = fs.existsSync(root + "/appdata/footer.json") ? JSON.parse(fs.readFileSync(root + "/appdata/footer.json")) : [];
      let sampleData = {
        fname: "Sample",
        lname: "Person"
      };

      let preview = () => {
        $$invalidate(3, previewModalOpen = true);
        printPDF(headerData, bodyData, footerData).then(() => {
          $$invalidate(3, previewModalOpen = false);
          cp.exec(root + "/appdata/newerpdf.pdf");
        }).catch(() => {
          $$invalidate(3, previewModalOpen = false);
          $$invalidate(4, docErrorModalOpen = true);
        });
      };

      let saveHeader = e => {
        fs.writeFileSync(root + "/appdata/header.json", JSON.stringify(e.detail));
        $$invalidate(5, headerData = e.detail);
      };

      let saveBody = e => {
        fs.writeFileSync(root + "/appdata/body.json", JSON.stringify(e.detail));
        $$invalidate(6, bodyData = e.detail);
      };

      let saveFooter = e => {
        fs.writeFileSync(root + "/appdata/footer.json", JSON.stringify(e.detail));
        $$invalidate(7, footerData = e.detail);
      };

      const click_handler = () => {
        $$invalidate(0, pdfHeaderModalOpen = true);
      };

      const click_handler_1 = () => {
        $$invalidate(1, pdfBodyModalOpen = true);
      };

      const click_handler_2 = () => {
        $$invalidate(2, pdfFooterModalOpen = true);
      };

      const forceClose_handler = () => {
        $$invalidate(0, pdfHeaderModalOpen = false);
      };

      const forceClose_handler_1 = () => {
        $$invalidate(0, pdfHeaderModalOpen = false);
      };

      const forceClose_handler_2 = () => {
        $$invalidate(1, pdfBodyModalOpen = false);
      };

      const forceClose_handler_3 = () => {
        $$invalidate(1, pdfBodyModalOpen = false);
      };

      const forceClose_handler_4 = () => {
        $$invalidate(2, pdfFooterModalOpen = false);
      };

      const forceClose_handler_5 = () => {
        $$invalidate(2, pdfFooterModalOpen = false);
      };

      const forceClose_handler_6 = () => {
        $$invalidate(3, previewModalOpen = false);
      };

      const click_handler_3 = () => {
        $$invalidate(4, docErrorModalOpen = false);
      };

      const forceClose_handler_7 = () => {
        $$invalidate(4, docErrorModalOpen = false);
      };

      $$self.$capture_state = () => {
        return {};
      };

      $$self.$inject_state = $$props => {
        if ("pdfHeaderModalOpen" in $$props) $$invalidate(0, pdfHeaderModalOpen = $$props.pdfHeaderModalOpen);
        if ("pdfBodyModalOpen" in $$props) $$invalidate(1, pdfBodyModalOpen = $$props.pdfBodyModalOpen);
        if ("pdfFooterModalOpen" in $$props) $$invalidate(2, pdfFooterModalOpen = $$props.pdfFooterModalOpen);
        if ("previewModalOpen" in $$props) $$invalidate(3, previewModalOpen = $$props.previewModalOpen);
        if ("docErrorModalOpen" in $$props) $$invalidate(4, docErrorModalOpen = $$props.docErrorModalOpen);
        if ("headerData" in $$props) $$invalidate(5, headerData = $$props.headerData);
        if ("bodyData" in $$props) $$invalidate(6, bodyData = $$props.bodyData);
        if ("footerData" in $$props) $$invalidate(7, footerData = $$props.footerData);
        if ("sampleData" in $$props) sampleData = $$props.sampleData;
        if ("preview" in $$props) $$invalidate(9, preview = $$props.preview);
        if ("saveHeader" in $$props) $$invalidate(10, saveHeader = $$props.saveHeader);
        if ("saveBody" in $$props) $$invalidate(11, saveBody = $$props.saveBody);
        if ("saveFooter" in $$props) $$invalidate(12, saveFooter = $$props.saveFooter);
        if ("$settings" in $$props) settings.set($settings = $$props.$settings);
      };

      return [pdfHeaderModalOpen, pdfBodyModalOpen, pdfFooterModalOpen, previewModalOpen, docErrorModalOpen, headerData, bodyData, footerData, $settings, preview, saveHeader, saveBody, saveFooter, cp, fs, app, root, sampleData, click_handler, click_handler_1, click_handler_2, forceClose_handler, forceClose_handler_1, forceClose_handler_2, forceClose_handler_3, forceClose_handler_4, forceClose_handler_5, forceClose_handler_6, click_handler_3, forceClose_handler_7];
    }

    class LOATemplate extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$d, create_fragment$d, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "LOATemplate",
          options,
          id: create_fragment$d.name
        });
      }

    }

    /* src\Reports.svelte generated by Svelte v3.17.1 */

    function create_fragment$e(ctx) {
      const block = {
        c: noop,
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: noop,
        p: noop,
        i: noop,
        o: noop,
        d: noop
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$e.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    class Reports extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, null, create_fragment$e, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Reports",
          options,
          id: create_fragment$e.name
        });
      }

    }

    /* src\App.svelte generated by Svelte v3.17.1 */
    const file$e = "src\\App.svelte"; // (463:0) {#if showAuthModal}

    function create_if_block_1$7(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot_1$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler*/
      ctx[14]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty &
          /*$$scope, showAuthModal*/
          524289) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$7.name,
        type: "if",
        source: "(463:0) {#if showAuthModal}",
        ctx
      });
      return block;
    } // (464:4) <Modal on:forceClose={()=>{ showAuthModal = false }}>


    function create_default_slot_1$4(ctx) {
      let h3;
      let t1;
      let p;
      let t3;
      let button;
      let dispose;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "Unauthorized";
          t1 = space();
          p = element("p");
          p.textContent = "You are not authorized to view this content based on the password you provided.";
          t3 = space();
          button = element("button");
          button.textContent = "OK";
          add_location(h3, file$e, 464, 8, 25955);
          add_location(p, file$e, 465, 8, 25986);
          attr_dev(button, "class", "centered blue");
          attr_dev(button, "type", "submit");
          add_location(button, file$e, 466, 8, 26082);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, p, anchor);
          insert_dev(target, t3, anchor);
          insert_dev(target, button, anchor);
          dispose = listen_dev(button, "click", prevent_default(
          /*click_handler*/
          ctx[13]), false, true, false);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(p);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(button);
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$4.name,
        type: "slot",
        source: "(464:4) <Modal on:forceClose={()=>{ showAuthModal = false }}>",
        ctx
      });
      return block;
    } // (471:0) {#if showPassModal}


    function create_if_block$9(ctx) {
      let current;
      const modal = new Modal({
        props: {
          $$slots: {
            default: [create_default_slot$7]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      modal.$on("forceClose",
      /*forceClose_handler_1*/
      ctx[18]);
      const block = {
        c: function create() {
          create_component(modal.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(modal, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const modal_changes = {};

          if (dirty &
          /*$$scope, showPassModal, pageBuffer, curPassword*/
          524302) {
            modal_changes.$$scope = {
              dirty,
              ctx
            };
          }

          modal.$set(modal_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(modal.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(modal.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(modal, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$9.name,
        type: "if",
        source: "(471:0) {#if showPassModal}",
        ctx
      });
      return block;
    } // (472:4) <Modal on:forceClose={()=>{ showPassModal = false }}>


    function create_default_slot$7(ctx) {
      let h3;
      let t1;
      let p;
      let t3;
      let div;
      let input;
      let br;
      let t4;
      let button0;
      let t6;
      let button1;
      let dispose;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "Password";
          t1 = space();
          p = element("p");
          p.textContent = "Enter a password to view this content.";
          t3 = space();
          div = element("div");
          input = element("input");
          br = element("br");
          t4 = space();
          button0 = element("button");
          button0.textContent = "OK";
          t6 = space();
          button1 = element("button");
          button1.textContent = "Cancel";
          add_location(h3, file$e, 472, 8, 26307);
          add_location(p, file$e, 473, 8, 26334);
          attr_dev(input, "type", "password");
          add_location(input, file$e, 475, 12, 26432);
          add_location(br, file$e, 475, 60, 26480);
          attr_dev(button0, "class", "blue");
          attr_dev(button0, "type", "submit");
          add_location(button0, file$e, 476, 12, 26498);
          attr_dev(button1, "type", "submit");
          add_location(button1, file$e, 477, 12, 26625);
          attr_dev(div, "class", "inline centered");
          add_location(div, file$e, 474, 8, 26389);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, p, anchor);
          insert_dev(target, t3, anchor);
          insert_dev(target, div, anchor);
          append_dev(div, input);
          set_input_value(input,
          /*curPassword*/
          ctx[2]);
          append_dev(div, br);
          append_dev(div, t4);
          append_dev(div, button0);
          append_dev(div, t6);
          append_dev(div, button1);
          dispose = [listen_dev(input, "input",
          /*input_input_handler*/
          ctx[15]), listen_dev(button0, "click", prevent_default(
          /*click_handler_1*/
          ctx[16]), false, true, false), listen_dev(button1, "click", prevent_default(
          /*click_handler_2*/
          ctx[17]), false, true, false)];
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*curPassword*/
          4 && input.value !==
          /*curPassword*/
          ctx[2]) {
            set_input_value(input,
            /*curPassword*/
            ctx[2]);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(p);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(div);
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$7.name,
        type: "slot",
        source: "(472:4) <Modal on:forceClose={()=>{ showPassModal = false }}>",
        ctx
      });
      return block;
    }

    function create_fragment$f(ctx) {
      let section;
      let div0;
      let svg0;
      let path0;
      let t0;
      let h1;
      let t2;
      let nav;
      let svg1;
      let g;
      let path1;
      let t3;
      let ul;
      let li0;
      let a0;
      let t4;
      let t5_value = formatText(
      /*$settings*/
      ctx[6].abbrev, false, false, true) + "";
      let t5;
      let t6;
      let li1;
      let a1;
      let t7_value = formatText(
      /*$settings*/
      ctx[6].students, true, true) + "";
      let t7;
      let t8;
      let li2;
      let a2;
      let t9_value = formatText(
      /*$settings*/
      ctx[6].services, true, true) + "";
      let t9;
      let t10;
      let li3;
      let a3;
      let t11_value = formatText(
      /*$settings*/
      ctx[6].abbrev, false, false, true) + "";
      let t11;
      let t12;
      let t13;
      let li4;
      let a4;
      let t15;
      let li5;
      let a5;
      let t17;
      let div2;
      let div1;
      let t18;
      let t19;
      let if_block1_anchor;
      let current;
      var switch_value =
      /*page*/
      ctx[7][
      /*curPage*/
      ctx[5]];

      function switch_props(ctx) {
        return {
          $$inline: true
        };
      }

      if (switch_value) {
        var switch_instance = new switch_value(switch_props());
        switch_instance.$on("scrollUp",
        /*scrollUp_handler*/
        ctx[11]);
      }

      let if_block0 =
      /*showAuthModal*/
      ctx[0] && create_if_block_1$7(ctx);
      let if_block1 =
      /*showPassModal*/
      ctx[1] && create_if_block$9(ctx);
      const block = {
        c: function create() {
          section = element("section");
          div0 = element("div");
          svg0 = svg_element("svg");
          path0 = svg_element("path");
          t0 = space();
          h1 = element("h1");
          h1.textContent = "Accommodate";
          t2 = space();
          nav = element("nav");
          svg1 = svg_element("svg");
          g = svg_element("g");
          path1 = svg_element("path");
          t3 = space();
          ul = element("ul");
          li0 = element("li");
          a0 = element("a");
          t4 = text("Write ");
          t5 = text(t5_value);
          t6 = space();
          li1 = element("li");
          a1 = element("a");
          t7 = text(t7_value);
          t8 = space();
          li2 = element("li");
          a2 = element("a");
          t9 = text(t9_value);
          t10 = space();
          li3 = element("li");
          a3 = element("a");
          t11 = text(t11_value);
          t12 = text(" Template");
          t13 = space();
          li4 = element("li");
          a4 = element("a");
          a4.textContent = "Settings";
          t15 = space();
          li5 = element("li");
          a5 = element("a");
          a5.textContent = "Reports";
          t17 = space();
          div2 = element("div");
          div1 = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          t18 = space();
          if (if_block0) if_block0.c();
          t19 = space();
          if (if_block1) if_block1.c();
          if_block1_anchor = empty();
          attr_dev(path0, "fill", "#C33C54");
          attr_dev(path0, "d", "M86.60254037844386 0L173.20508075688772 50L173.20508075688772 150L86.60254037844386 200L0 150L0 50Z");
          add_location(path0, file$e, 441, 202, 24358);
          attr_dev(svg0, "id", "logo");
          attr_dev(svg0, "version", "1.1");
          attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
          attr_dev(svg0, "width", "174");
          attr_dev(svg0, "height", "200");
          attr_dev(svg0, "viewBox", "0 0 173.20508075688772 200");
          set_style(svg0, "filter", "drop-shadow(rgba(255, 255, 255, 0.5) 0px 0px 10px)");
          attr_dev(svg0, "class", "svelte-14jajyx");
          add_location(svg0, file$e, 441, 8, 24164);
          attr_dev(h1, "class", "svelte-14jajyx");
          add_location(h1, file$e, 442, 8, 24506);
          attr_dev(div0, "id", "header");
          attr_dev(div0, "class", "svelte-14jajyx");
          add_location(div0, file$e, 440, 4, 24137);
          attr_dev(path1, "d", "M 0,247 H 200 C 87.745309,251.08461 12.341004,241.11661 0,297 Z");
          set_style(path1, "opacity", "1");
          set_style(path1, "fill", "#6adfee");
          set_style(path1, "fill-opacity", "1");
          set_style(path1, "stroke", "none");
          set_style(path1, "stroke-width", "0.26499999");
          set_style(path1, "stroke-miterlimit", "4");
          set_style(path1, "stroke-dasharray", "none");
          set_style(path1, "stroke-opacity", "1");
          add_location(path1, file$e, 445, 81, 24632);
          attr_dev(g, "transform", "translate(0,-247)");
          add_location(g, file$e, 445, 48, 24599);
          attr_dev(svg1, "id", "menucurl");
          attr_dev(svg1, "viewBox", "0 0 200 50");
          attr_dev(svg1, "class", "svelte-14jajyx");
          add_location(svg1, file$e, 445, 8, 24559);
          attr_dev(a0, "href", "#write");
          attr_dev(a0, "class", "svelte-14jajyx");
          add_location(a0, file$e, 447, 51, 24925);
          attr_dev(li0, "class", "svelte-14jajyx");
          toggle_class(li0, "active",
          /*curPage*/
          ctx[5] == "#write");
          add_location(li0, file$e, 447, 12, 24886);
          attr_dev(a1, "href", "#students");
          attr_dev(a1, "class", "svelte-14jajyx");
          add_location(a1, file$e, 448, 78, 25087);
          attr_dev(li1, "class", "svelte-14jajyx");
          toggle_class(li1, "active",
          /*curPage*/
          ctx[5] == "#students" ||
          /*curPage*/
          ctx[5] == "#record");
          add_location(li1, file$e, 448, 12, 25021);
          attr_dev(a2, "href", "#accommodations");
          attr_dev(a2, "class", "svelte-14jajyx");
          add_location(a2, file$e, 449, 60, 25222);
          attr_dev(li2, "class", "svelte-14jajyx");
          toggle_class(li2, "active",
          /*curPage*/
          ctx[5] == "#accommodations");
          add_location(li2, file$e, 449, 12, 25174);
          attr_dev(a3, "href", "#pdf");
          attr_dev(a3, "class", "svelte-14jajyx");
          add_location(a3, file$e, 450, 49, 25352);
          attr_dev(li3, "class", "svelte-14jajyx");
          toggle_class(li3, "active",
          /*curPage*/
          ctx[5] == "#pdf");
          add_location(li3, file$e, 450, 12, 25315);
          attr_dev(a4, "href", "#settings");
          attr_dev(a4, "class", "svelte-14jajyx");
          add_location(a4, file$e, 451, 54, 25491);
          attr_dev(li4, "class", "svelte-14jajyx");
          toggle_class(li4, "active",
          /*curPage*/
          ctx[5] == "#settings");
          add_location(li4, file$e, 451, 12, 25449);
          attr_dev(a5, "href", "#reports");
          attr_dev(a5, "class", "svelte-14jajyx");
          add_location(a5, file$e, 452, 53, 25583);
          attr_dev(li5, "class", "svelte-14jajyx");
          toggle_class(li5, "active",
          /*curPage*/
          ctx[5] == "#reports");
          add_location(li5, file$e, 452, 12, 25542);
          attr_dev(ul, "class", "svelte-14jajyx");
          add_location(ul, file$e, 446, 8, 24868);
          attr_dev(nav, "class", "svelte-14jajyx");
          add_location(nav, file$e, 444, 4, 24544);
          attr_dev(div1, "class", "constrain svelte-14jajyx");
          add_location(div1, file$e, 456, 8, 25701);
          attr_dev(div2, "class", "inner svelte-14jajyx");
          add_location(div2, file$e, 455, 4, 25651);
          attr_dev(section, "id", "main");
          attr_dev(section, "class", "svelte-14jajyx");
          add_location(section, file$e, 439, 0, 24112);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, section, anchor);
          append_dev(section, div0);
          append_dev(div0, svg0);
          append_dev(svg0, path0);
          append_dev(div0, t0);
          append_dev(div0, h1);
          append_dev(section, t2);
          append_dev(section, nav);
          append_dev(nav, svg1);
          append_dev(svg1, g);
          append_dev(g, path1);
          append_dev(nav, t3);
          append_dev(nav, ul);
          append_dev(ul, li0);
          append_dev(li0, a0);
          append_dev(a0, t4);
          append_dev(a0, t5);
          append_dev(ul, t6);
          append_dev(ul, li1);
          append_dev(li1, a1);
          append_dev(a1, t7);
          append_dev(ul, t8);
          append_dev(ul, li2);
          append_dev(li2, a2);
          append_dev(a2, t9);
          append_dev(ul, t10);
          append_dev(ul, li3);
          append_dev(li3, a3);
          append_dev(a3, t11);
          append_dev(a3, t12);
          append_dev(ul, t13);
          append_dev(ul, li4);
          append_dev(li4, a4);
          append_dev(ul, t15);
          append_dev(ul, li5);
          append_dev(li5, a5);
          append_dev(section, t17);
          append_dev(section, div2);
          append_dev(div2, div1);

          if (switch_instance) {
            mount_component(switch_instance, div1, null);
          }
          /*div2_binding*/


          ctx[12](div2);
          insert_dev(target, t18, anchor);
          if (if_block0) if_block0.m(target, anchor);
          insert_dev(target, t19, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if ((!current || dirty &
          /*$settings*/
          64) && t5_value !== (t5_value = formatText(
          /*$settings*/
          ctx[6].abbrev, false, false, true) + "")) set_data_dev(t5, t5_value);

          if (dirty &
          /*curPage*/
          32) {
            toggle_class(li0, "active",
            /*curPage*/
            ctx[5] == "#write");
          }

          if ((!current || dirty &
          /*$settings*/
          64) && t7_value !== (t7_value = formatText(
          /*$settings*/
          ctx[6].students, true, true) + "")) set_data_dev(t7, t7_value);

          if (dirty &
          /*curPage*/
          32) {
            toggle_class(li1, "active",
            /*curPage*/
            ctx[5] == "#students" ||
            /*curPage*/
            ctx[5] == "#record");
          }

          if ((!current || dirty &
          /*$settings*/
          64) && t9_value !== (t9_value = formatText(
          /*$settings*/
          ctx[6].services, true, true) + "")) set_data_dev(t9, t9_value);

          if (dirty &
          /*curPage*/
          32) {
            toggle_class(li2, "active",
            /*curPage*/
            ctx[5] == "#accommodations");
          }

          if ((!current || dirty &
          /*$settings*/
          64) && t11_value !== (t11_value = formatText(
          /*$settings*/
          ctx[6].abbrev, false, false, true) + "")) set_data_dev(t11, t11_value);

          if (dirty &
          /*curPage*/
          32) {
            toggle_class(li3, "active",
            /*curPage*/
            ctx[5] == "#pdf");
          }

          if (dirty &
          /*curPage*/
          32) {
            toggle_class(li4, "active",
            /*curPage*/
            ctx[5] == "#settings");
          }

          if (dirty &
          /*curPage*/
          32) {
            toggle_class(li5, "active",
            /*curPage*/
            ctx[5] == "#reports");
          }

          if (switch_value !== (switch_value =
          /*page*/
          ctx[7][
          /*curPage*/
          ctx[5]])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              switch_instance.$on("scrollUp",
              /*scrollUp_handler*/
              ctx[11]);
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div1, null);
            } else {
              switch_instance = null;
            }
          }

          if (
          /*showAuthModal*/
          ctx[0]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
              transition_in(if_block0, 1);
            } else {
              if_block0 = create_if_block_1$7(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(t19.parentNode, t19);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*showPassModal*/
          ctx[1]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
              transition_in(if_block1, 1);
            } else {
              if_block1 = create_if_block$9(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          transition_in(if_block0);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          transition_out(if_block0);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(section);
          if (switch_instance) destroy_component(switch_instance);
          /*div2_binding*/

          ctx[12](null);
          if (detaching) detach_dev(t18);
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach_dev(t19);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach_dev(if_block1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$f.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
      let $settings;
      validate_store(settings, "settings");
      component_subscribe($$self, settings, $$value => $$invalidate(6, $settings = $$value));
      let showAuthModal = false;
      let showPassModal = false;
      let curPassword = "";
      let pagePasswords = "";
      let pageBuffer = "";
      let page = {
        "#write": Write,
        "#students": Students,
        "#accommodations": Accommodations,
        "#record": Record,
        "#settings": Settings,
        "#pdf": LOATemplate,
        "#reports": Reports
      };
      let viewarea;
      let curPage = "";

      let checkForPagePassword = page => {
        let pwords = [];
        $settings.passwords.forEach(pw => {
          pw.pages.forEach(p => {
            if (p.value == page) pwords.push(pw.password);
          });
        });
        return pwords;
      };

      let changePage = (page, prompt = true) => {
        pagePasswords = checkForPagePassword(page);
        $$invalidate(1, showPassModal = false);

        if (pagePasswords.length > 0) {
          if (curPassword && pagePasswords.includes(curPassword)) $$invalidate(5, curPage = page);else if (prompt) {
            $$invalidate(1, showPassModal = true);
            $$invalidate(3, pageBuffer = page);
          } else {
            $$invalidate(0, showAuthModal = true);
            window.location.hash = "";
          }
        } else $$invalidate(5, curPage = page);
      };

      window.onhashchange = () => {
        changePage(window.location.hash.split("/")[0]);
      };

      onMount(() => {
        window.location.hash = "#";
        setTimeout(() => {
          window.location.hash = "#write";
        }, 300);
        changePage("#write");
      });

      const scrollUp_handler = () => {
        $$invalidate(4, viewarea.scrollTop = 0, viewarea);
      };

      function div2_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $$invalidate(4, viewarea = $$value);
        });
      }

      const click_handler = () => {
        $$invalidate(0, showAuthModal = false);
      };

      const forceClose_handler = () => {
        $$invalidate(0, showAuthModal = false);
      };

      function input_input_handler() {
        curPassword = this.value;
        $$invalidate(2, curPassword);
      }

      const click_handler_1 = () => {
        changePage(pageBuffer, false);
      };

      const click_handler_2 = () => {
        $$invalidate(1, showPassModal = false);
      };

      const forceClose_handler_1 = () => {
        $$invalidate(1, showPassModal = false);
      };

      $$self.$capture_state = () => {
        return {};
      };

      $$self.$inject_state = $$props => {
        if ("showAuthModal" in $$props) $$invalidate(0, showAuthModal = $$props.showAuthModal);
        if ("showPassModal" in $$props) $$invalidate(1, showPassModal = $$props.showPassModal);
        if ("curPassword" in $$props) $$invalidate(2, curPassword = $$props.curPassword);
        if ("pagePasswords" in $$props) pagePasswords = $$props.pagePasswords;
        if ("pageBuffer" in $$props) $$invalidate(3, pageBuffer = $$props.pageBuffer);
        if ("page" in $$props) $$invalidate(7, page = $$props.page);
        if ("viewarea" in $$props) $$invalidate(4, viewarea = $$props.viewarea);
        if ("curPage" in $$props) $$invalidate(5, curPage = $$props.curPage);
        if ("checkForPagePassword" in $$props) checkForPagePassword = $$props.checkForPagePassword;
        if ("changePage" in $$props) $$invalidate(8, changePage = $$props.changePage);
        if ("$settings" in $$props) settings.set($settings = $$props.$settings);
      };

      return [showAuthModal, showPassModal, curPassword, pageBuffer, viewarea, curPage, $settings, page, changePage, pagePasswords, checkForPagePassword, scrollUp_handler, div2_binding, click_handler, forceClose_handler, input_input_handler, click_handler_1, click_handler_2, forceClose_handler_1];
    }

    class App extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$e, create_fragment$f, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "App",
          options,
          id: create_fragment$f.name
        });
      }

    }

    const app$3 = new App({
      target: document.body
    });

    return app$3;

}());
//# sourceMappingURL=bundle.js.map
